/* Generated by Cython 0.21 */

#define PY_SSIZE_T_CLEAN
#ifndef CYTHON_USE_PYLONG_INTERNALS
#ifdef PYLONG_BITS_IN_DIGIT
#define CYTHON_USE_PYLONG_INTERNALS 0
#else
#include "pyconfig.h"
#ifdef PYLONG_BITS_IN_DIGIT
#define CYTHON_USE_PYLONG_INTERNALS 1
#else
#define CYTHON_USE_PYLONG_INTERNALS 0
#endif
#endif
#endif
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03020000)
    #error Cython requires Python 2.6+ or Python 3.2+.
#else
#define CYTHON_ABI "0_21"
#include <stddef.h>
#ifndef offsetof
#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
#define CYTHON_COMPILING_IN_PYPY 1
#define CYTHON_COMPILING_IN_CPYTHON 0
#else
#define CYTHON_COMPILING_IN_PYPY 0
#define CYTHON_COMPILING_IN_CPYTHON 1
#endif
#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600
#define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyType_Type
#endif
#if PY_MAJOR_VERSION >= 3
  #define Py_TPFLAGS_CHECKTYPES 0
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#if PY_MAJOR_VERSION >= 3
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#if PY_VERSION_HEX < 0x030400a1 && !defined(Py_TPFLAGS_HAVE_FINALIZE)
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
#else
  #define CYTHON_PEP393_ENABLED 0
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ? \
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#endif
#ifndef CYTHON_INLINE
  #if defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
   a quiet NaN. */
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif
#ifdef __cplusplus
template<typename T>
void __Pyx_call_destructor(T* x) {
    x->~T();
}
#endif


#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
#define _USE_MATH_DEFINES
#endif
#include <math.h>
#define __PYX_HAVE__fst
#define __PYX_HAVE_API__fst
#include "limits.h"
#include "stdint.h"
#include <utility>
#include "ios"
#include "new"
#include "stdexcept"
#include "typeinfo"
#include "string.h"
#include <string>
#include <vector>
#include <time.h>
#include <fst/types.h>
#include <fst/util.h>
#include <fst/fstlib.h>
#include <fst/script/fstscript.h>
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif

#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (    \
    (sizeof(type) < sizeof(Py_ssize_t))  ||             \
    (sizeof(type) > sizeof(Py_ssize_t) &&               \
          likely(v < (type)PY_SSIZE_T_MAX ||            \
                 v == (type)PY_SSIZE_T_MAX)  &&         \
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||       \
                                v == (type)PY_SSIZE_T_MIN)))  ||  \
    (sizeof(type) == sizeof(Py_ssize_t) &&              \
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||        \
                               v == (type)PY_SSIZE_T_MAX)))  )
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyObject_AsSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromUString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((const char*)s)
#if PY_MAJOR_VERSION < 3
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
{
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#else
#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
#endif
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
#if CYTHON_COMPILING_IN_CPYTHON
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */

static PyObject *__pyx_m;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "fst.pyx",
  "stringsource",
  "stringsource",
};

/*--- Type declarations ---*/
struct __pyx_obj_3fst_Weight;
struct __pyx_obj_3fst__Fst;
struct __pyx_obj_3fst__MutableFst;

/* "fst.pyx":275
 * 
 * 
 * ctypedef pair[int64, const FstClass *] FstTuple             # <<<<<<<<<<<<<<
 * 
 * 
 */
typedef std::pair<int64,fst::script::FstClass const *>  __pyx_t_3fst_FstTuple;

/* "fst.pyx":682
 * 
 * 
 * cdef class Weight(object):             # <<<<<<<<<<<<<<
 * 
 *   cdef WeightClass *weight
 */
struct __pyx_obj_3fst_Weight {
  PyObject_HEAD
  fst::script::WeightClass *weight;
};


/* "fst.pyx":715
 * 
 * 
 * cdef class _Fst(object):             # <<<<<<<<<<<<<<
 * 
 *   """Base Python FST class, wrapping FstClass.
 */
struct __pyx_obj_3fst__Fst {
  PyObject_HEAD
  fst::script::FstClass *fst;
};


/* "fst.pyx":791
 * 
 * 
 * cdef class _MutableFst(_Fst):             # <<<<<<<<<<<<<<
 * 
 *   """Python FST class with destructive operations, wrapping MutableFstClass."""
 */
struct __pyx_obj_3fst__MutableFst {
  struct __pyx_obj_3fst__Fst __pyx_base;
  fst::script::MutableFstClass *mfst;
};

#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          if (acquire_gil) { \
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
              PyGILState_Release(__pyx_gilstate_save); \
          } else { \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext() \
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {                            \
        PyObject *tmp = (PyObject *) r;                         \
        r = v; __Pyx_XDECREF(tmp);                              \
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {                             \
        PyObject *tmp = (PyObject *) r;                         \
        r = v; __Pyx_DECREF(tmp);                               \
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

static PyObject *__Pyx_GetBuiltinName(PyObject *name);

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb);
static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb);

static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb);

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);

static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name);

static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);

static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);

static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[], \
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args, \
    const char* function_name);

static void __Pyx_WriteUnraisable(const char *name, int clineno,
                                  int lineno, const char *filename,
                                  int full_traceback);

static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact);

#include <string.h>

static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
#else
#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
#endif

static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);

static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);

static CYTHON_INLINE int __Pyx_IterFinish(void);

static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);

static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);

#define __Pyx_PyIter_Next(obj) __Pyx_PyIter_Next2(obj, NULL)
static CYTHON_INLINE PyObject *__Pyx_PyIter_Next2(PyObject *, PyObject *);

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
#endif

static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases);

static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name, PyObject *qualname,
                                           PyObject *mkw, PyObject *modname, PyObject *doc);
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases, PyObject *dict,
                                      PyObject *mkw, int calculate_metaclass, int allow_py2_metaclass);

static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name);

typedef struct {
    int code_line;
    PyCodeObject* code_object;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint64_t(uint64_t value);

static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

static CYTHON_INLINE uint64_t __Pyx_PyInt_As_uint64_t(PyObject *);

static CYTHON_INLINE int64_t __Pyx_PyInt_As_int64_t(PyObject *);

static CYTHON_INLINE int32_t __Pyx_PyInt_As_int32_t(PyObject *);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);

#ifndef __Pyx_CppExn2PyErr
#include <new>
#include <typeinfo>
#include <stdexcept>
#include <ios>
static void __Pyx_CppExn2PyErr() {
  try {
    if (PyErr_Occurred())
      ; // let the latest Python exn pass through and ignore the current one
    else
      throw;
  } catch (const std::bad_alloc& exn) {
    PyErr_SetString(PyExc_MemoryError, exn.what());
  } catch (const std::bad_cast& exn) {
    PyErr_SetString(PyExc_TypeError, exn.what());
  } catch (const std::domain_error& exn) {
    PyErr_SetString(PyExc_ValueError, exn.what());
  } catch (const std::invalid_argument& exn) {
    PyErr_SetString(PyExc_ValueError, exn.what());
  } catch (const std::ios_base::failure& exn) {
    PyErr_SetString(PyExc_IOError, exn.what());
  } catch (const std::out_of_range& exn) {
    PyErr_SetString(PyExc_IndexError, exn.what());
  } catch (const std::overflow_error& exn) {
    PyErr_SetString(PyExc_OverflowError, exn.what());
  } catch (const std::range_error& exn) {
    PyErr_SetString(PyExc_ArithmeticError, exn.what());
  } catch (const std::underflow_error& exn) {
    PyErr_SetString(PyExc_ArithmeticError, exn.what());
  } catch (const std::exception& exn) {
    PyErr_SetString(PyExc_RuntimeError, exn.what());
  }
  catch (...)
  {
    PyErr_SetString(PyExc_RuntimeError, "Unknown exception");
  }
}
#endif

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

static int __Pyx_check_binary_version(void);

static int __Pyx_ExportFunction(const char *name, void (*f)(void), const char *sig);

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);


/* Module declarations from 'libc.limits' */

/* Module declarations from 'libc.stdint' */

/* Module declarations from 'libcpp' */

/* Module declarations from 'libcpp.utility' */

/* Module declarations from 'libcpp.pair' */

/* Module declarations from 'libc.string' */

/* Module declarations from 'libcpp.string' */

/* Module declarations from 'libcpp.vector' */

/* Module declarations from 'fst' */
static PyTypeObject *__pyx_ptype_3fst_Weight = 0;
static PyTypeObject *__pyx_ptype_3fst__Fst = 0;
static PyTypeObject *__pyx_ptype_3fst__MutableFst = 0;
static PyObject *__pyx_f_3fst_tobytes(PyObject *); /*proto*/
static fst::script::WeightClass __pyx_f_3fst__get_weight_class(PyObject *, PyObject *); /*proto*/
static PyObject *__pyx_f_3fst__init_Fst(fst::script::FstClass *); /*proto*/
static PyObject *__pyx_f_3fst__init_MutableFst(fst::script::MutableFstClass *); /*proto*/
static PyObject *__pyx_f_3fst__init_XFst(fst::script::FstClass *); /*proto*/
static std::string __pyx_convert_string_from_py_(PyObject *); /*proto*/
static PyObject *__pyx_convert_string_to_py_(std::string const &); /*proto*/
#define __Pyx_MODULE_NAME "fst"
int __pyx_module_is_main_fst = 0;

/* Implementation of 'fst' */
static PyObject *__pyx_builtin_UserWarning;
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_property;
static PyObject *__pyx_builtin_Exception;
static PyObject *__pyx_builtin_NotImplementedError;
static PyObject *__pyx_builtin_hex;
static PyObject *__pyx_builtin_id;
static PyObject *__pyx_pf_3fst__get_compose_filter(CYTHON_UNUSED PyObject *__pyx_self, std::string __pyx_v_cf); /* proto */
static PyObject *__pyx_pf_3fst_2_get_queue_type(CYTHON_UNUSED PyObject *__pyx_self, std::string __pyx_v_qt); /* proto */
static PyObject *__pyx_pf_3fst_4_get_rand_arc_selection(CYTHON_UNUSED PyObject *__pyx_self, std::string __pyx_v_ras); /* proto */
static PyObject *__pyx_pf_3fst_6_get_replace_label_type(CYTHON_UNUSED PyObject *__pyx_self, std::string __pyx_v_rlt, bool __pyx_v_epsilon_on_replace); /* proto */
static PyObject *__pyx_pf_3fst_6Weight___repr__(struct __pyx_obj_3fst_Weight *__pyx_v_self); /* proto */
static int __pyx_pf_3fst_6Weight_2__init__(struct __pyx_obj_3fst_Weight *__pyx_v_self, PyObject *__pyx_v_weight_type, PyObject *__pyx_v_weight_string); /* proto */
static void __pyx_pf_3fst_6Weight_4__dealloc__(struct __pyx_obj_3fst_Weight *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_3fst_6Weight_6__richcmp__(struct __pyx_obj_3fst_Weight *__pyx_v_x, struct __pyx_obj_3fst_Weight *__pyx_v_y, int __pyx_v_op); /* proto */
static PyObject *__pyx_pf_3fst_6Weight_8type(struct __pyx_obj_3fst_Weight *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_3fst_6Weight_10string(struct __pyx_obj_3fst_Weight *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_3fst_4_Fst___repr__(struct __pyx_obj_3fst__Fst *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_3fst_4_Fst_2write(struct __pyx_obj_3fst__Fst *__pyx_v_self, PyObject *__pyx_v_filename); /* proto */
static PyObject *__pyx_pf_3fst_4_Fst_4properties(struct __pyx_obj_3fst__Fst *__pyx_v_self, uint64 __pyx_v_mask, bool __pyx_v_test); /* proto */
static PyObject *__pyx_pf_3fst_4_Fst_6_arc_type(struct __pyx_obj_3fst__Fst *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_3fst_4_Fst_8_fst_type(struct __pyx_obj_3fst__Fst *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_3fst_4_Fst_10_weight_type(struct __pyx_obj_3fst__Fst *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_3fst_4_Fst_12verify(struct __pyx_obj_3fst__Fst *__pyx_v_self); /* proto */
static void __pyx_pf_3fst_11_MutableFst___dealloc__(struct __pyx_obj_3fst__MutableFst *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_2_check_mutating_imethod(struct __pyx_obj_3fst__MutableFst *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_4arcsort(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_sort_type); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_6closure(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_closure_plus); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_8concat(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_10connect(struct __pyx_obj_3fst__MutableFst *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_12decode(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_codex_filename); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_14encode(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_codex_filename, PyObject *__pyx_v_encode_labels, bool __pyx_v_encode_reuse, PyObject *__pyx_v_encode_weights); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_16invert(struct __pyx_obj_3fst__MutableFst *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_18minimize(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, float __pyx_v_delta); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_20project(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_project_output); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_22prune(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, float __pyx_v_delta, int64 __pyx_v_nstate, PyObject *__pyx_v_weight); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_24push(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, float __pyx_v_delta, PyObject *__pyx_v_remove_total_weight, PyObject *__pyx_v_to_final); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_26relabel(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_ipairs, PyObject *__pyx_v_opairs); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_28reweight(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_potentials, bool __pyx_v_to_final); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_30rmepsilon(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, bool __pyx_v_connect, float __pyx_v_delta, int64 __pyx_v_nstate, PyObject *__pyx_v_weight); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_32topsort(struct __pyx_obj_3fst__MutableFst *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_3fst_11_MutableFst_34union(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst); /* proto */
static PyObject *__pyx_pf_3fst_8Fst(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_filename, PyObject *__pyx_v_fst_type); /* proto */
static PyObject *__pyx_pf_3fst_10arcmap(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, PyObject *__pyx_v_map_type, PyObject *__pyx_v_weight); /* proto */
static PyObject *__pyx_pf_3fst_12compose(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, PyObject *__pyx_v_cf, bool __pyx_v_connect); /* proto */
static PyObject *__pyx_pf_3fst_14convert(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, PyObject *__pyx_v_fst_type); /* proto */
static PyObject *__pyx_pf_3fst_16determinize(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, PyObject *__pyx_v_det_type, int64 __pyx_v_nstate, int64 __pyx_v_subsequential_label, PyObject *__pyx_v_weight, bool __pyx_v_increment_subsequential_label); /* proto */
static PyObject *__pyx_pf_3fst_18difference(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, PyObject *__pyx_v_cf, bool __pyx_v_connect); /* proto */
static PyObject *__pyx_pf_3fst_20disambiguate(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, int64 __pyx_v_nstate, int64 __pyx_v_subsequential_label, std::string __pyx_v_weight); /* proto */
static PyObject *__pyx_pf_3fst_22epsnormalize(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, bool __pyx_v_eps_norm_output); /* proto */
static PyObject *__pyx_pf_3fst_24equal(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, float __pyx_v_delta); /* proto */
static PyObject *__pyx_pf_3fst_26equivalent(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, float __pyx_v_delta); /* proto */
static PyObject *__pyx_pf_3fst_28intersect(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, PyObject *__pyx_v_cf, bool __pyx_v_connect); /* proto */
static PyObject *__pyx_pf_3fst_30isomorphic(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, float __pyx_v_delta); /* proto */
static PyObject *__pyx_pf_3fst_32prune(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, int64 __pyx_v_nstate, PyObject *__pyx_v_weight); /* proto */
static PyObject *__pyx_pf_3fst_34push(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, bool __pyx_v_push_weights, bool __pyx_v_push_labels, bool __pyx_v_remove_common_affix, bool __pyx_v_remove_total_weight, bool __pyx_v_to_final); /* proto */
static PyObject *__pyx_pf_3fst_36randequivalent(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, float __pyx_v_delta, int32 __pyx_v_max_length, int32 __pyx_v_npath, int32 __pyx_v_seed, PyObject *__pyx_v_select); /* proto */
static PyObject *__pyx_pf_3fst_38randgen(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, int32 __pyx_v_max_length, CYTHON_UNUSED int32 __pyx_v_npath, CYTHON_UNUSED bool __pyx_v_remove_total_weight, int32 __pyx_v_seed, PyObject *__pyx_v_select, CYTHON_UNUSED bool __pyx_v_weighted); /* proto */
static PyObject *__pyx_pf_3fst_40replace(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_pairs, PyObject *__pyx_v_call_arc_labeling, PyObject *__pyx_v_return_arc_labeling, bool __pyx_v_epsilon_on_replace, int64 __pyx_v_return_label); /* proto */
static PyObject *__pyx_pf_3fst_42reverse(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, bool __pyx_v_require_superinitial); /* proto */
static PyObject *__pyx_pf_3fst_44rmepsilon(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, bool __pyx_v_connect, float __pyx_v_delta, int64 __pyx_v_nstate, PyObject *__pyx_v_queue_type, bool __pyx_v_reverse, PyObject *__pyx_v_weight); /* proto */
static PyObject *__pyx_pf_3fst_46shortestdistance(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, int64 __pyx_v_nstate, PyObject *__pyx_v_queue_type, bool __pyx_v_reverse); /* proto */
static PyObject *__pyx_pf_3fst_48shortestpath(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, int64 __pyx_v_nshortest, int64 __pyx_v_nstate, PyObject *__pyx_v_queue_type, bool __pyx_v_unique, PyObject *__pyx_v_weight); /* proto */
static PyObject *__pyx_pf_3fst_50synchronize(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst); /* proto */
static PyObject *__pyx_tp_new_3fst_Weight(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_3fst__Fst(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_3fst__MutableFst(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static char __pyx_k__5[] = "";
static char __pyx_k_cf[] = "cf";
static char __pyx_k_dt[] = "dt";
static char __pyx_k_id[] = "id";
static char __pyx_k_it[] = "it";
static char __pyx_k_mt[] = "mt";
static char __pyx_k_qt[] = "qt";
static char __pyx_k_rt[] = "rt";
static char __pyx_k_wc[] = "wc";
static char __pyx_k_Fst[] = "Fst";
static char __pyx_k_cal[] = "cal";
static char __pyx_k_doc[] = "__doc__";
static char __pyx_k_fst[] = "fst";
static char __pyx_k_hex[] = "hex";
static char __pyx_k_ral[] = "ral";
static char __pyx_k_ras[] = "ras";
static char __pyx_k_rlt[] = "rlt";
static char __pyx_k_top[] = "top";
static char __pyx_k_auto[] = "auto";
static char __pyx_k_both[] = "both";
static char __pyx_k_fifo[] = "fifo";
static char __pyx_k_ifst[] = "ifst";
static char __pyx_k_lifo[] = "lifo";
static char __pyx_k_main[] = "__main__";
static char __pyx_k_mask[] = "mask";
static char __pyx_k_name[] = "__name__";
static char __pyx_k_null[] = "null";
static char __pyx_k_opts[] = "opts";
static char __pyx_k_plus[] = "plus";
static char __pyx_k_push[] = "push";
static char __pyx_k_seed[] = "seed";
static char __pyx_k_test[] = "test";
static char __pyx_k_tfst[] = "tfst";
static char __pyx_k_type[] = "type";
static char __pyx_k_ERROR[] = "ERROR";
static char __pyx_k_UTF_8[] = "UTF-8";
static char __pyx_k_class[] = "__class__";
static char __pyx_k_delta[] = "delta";
static char __pyx_k_equal[] = "equal";
static char __pyx_k_error[] = "error";
static char __pyx_k_flags[] = "flags";
static char __pyx_k_ifst1[] = "ifst1";
static char __pyx_k_ifst2[] = "ifst2";
static char __pyx_k_input[] = "input";
static char __pyx_k_label[] = "label";
static char __pyx_k_match[] = "match";
static char __pyx_k_npath[] = "npath";
static char __pyx_k_pairs[] = "pairs";
static char __pyx_k_prune[] = "prune";
static char __pyx_k_state[] = "state";
static char __pyx_k_times[] = "times";
static char __pyx_k_CYCLIC[] = "CYCLIC";
static char __pyx_k_Fst_at[] = "<{} Fst at {}>";
static char __pyx_k_STRING[] = "STRING";
static char __pyx_k_arcmap[] = "arcmap";
static char __pyx_k_encode[] = "encode";
static char __pyx_k_format[] = "format";
static char __pyx_k_ilabel[] = "ilabel";
static char __pyx_k_invert[] = "invert";
static char __pyx_k_ipairs[] = "ipairs";
static char __pyx_k_module[] = "__module__";
static char __pyx_k_nstate[] = "nstate";
static char __pyx_k_olabel[] = "olabel";
static char __pyx_k_opairs[] = "opairs";
static char __pyx_k_output[] = "output";
static char __pyx_k_result[] = "result";
static char __pyx_k_select[] = "select";
static char __pyx_k_string[] = "string";
static char __pyx_k_test_2[] = "__test__";
static char __pyx_k_to_log[] = "to_log";
static char __pyx_k_unique[] = "unique";
static char __pyx_k_weight[] = "weight";
static char __pyx_k_ACYCLIC[] = "ACYCLIC";
static char __pyx_k_MUTABLE[] = "MUTABLE";
static char __pyx_k_arc_sum[] = "arc_sum";
static char __pyx_k_compose[] = "compose";
static char __pyx_k_connect[] = "connect";
static char __pyx_k_convert[] = "convert";
static char __pyx_k_neither[] = "neither";
static char __pyx_k_pairs_2[] = "_pairs";
static char __pyx_k_prepare[] = "__prepare__";
static char __pyx_k_randgen[] = "randgen";
static char __pyx_k_replace[] = "replace";
static char __pyx_k_reverse[] = "reverse";
static char __pyx_k_uniform[] = "uniform";
static char __pyx_k_ACCEPTOR[] = "ACCEPTOR";
static char __pyx_k_EPSILONS[] = "EPSILONS";
static char __pyx_k_EXPANDED[] = "EXPANDED";
static char __pyx_k_FstError[] = "FstError";
static char __pyx_k_WEIGHTED[] = "WEIGHTED";
static char __pyx_k_arc_type[] = "_arc_type";
static char __pyx_k_det_type[] = "det_type";
static char __pyx_k_distance[] = "distance";
static char __pyx_k_filename[] = "filename";
static char __pyx_k_fst_type[] = "_fst_type";
static char __pyx_k_identity[] = "identity";
static char __pyx_k_log_prob[] = "log_prob";
static char __pyx_k_map_type[] = "map_type";
static char __pyx_k_property[] = "property";
static char __pyx_k_qualname[] = "__qualname__";
static char __pyx_k_quantize[] = "quantize";
static char __pyx_k_rmweight[] = "rmweight";
static char __pyx_k_sequence[] = "sequence";
static char __pyx_k_shortest[] = "shortest";
static char __pyx_k_to_final[] = "to_final";
static char __pyx_k_to_log64[] = "to_log64";
static char __pyx_k_weighted[] = "weighted";
static char __pyx_k_Exception[] = "Exception";
static char __pyx_k_intersect[] = "intersect";
static char __pyx_k_metaclass[] = "__metaclass__";
static char __pyx_k_nshortest[] = "nshortest";
static char __pyx_k_rmepsilon[] = "rmepsilon";
static char __pyx_k_sort_type[] = "sort_type";
static char __pyx_k_ACCESSIBLE[] = "ACCESSIBLE";
static char __pyx_k_FstWarning[] = "FstWarning";
static char __pyx_k_I_EPSILONS[] = "I_EPSILONS";
static char __pyx_k_NOT_STRING[] = "NOT_STRING";
static char __pyx_k_O_EPSILONS[] = "O_EPSILONS";
static char __pyx_k_TOP_SORTED[] = "TOP_SORTED";
static char __pyx_k_UNWEIGHTED[] = "UNWEIGHTED";
static char __pyx_k_ValueError[] = "ValueError";
static char __pyx_k_difference[] = "difference";
static char __pyx_k_equivalent[] = "equivalent";
static char __pyx_k_fst_type_2[] = "fst_type";
static char __pyx_k_functional[] = "functional";
static char __pyx_k_isomorphic[] = "isomorphic";
static char __pyx_k_max_length[] = "max_length";
static char __pyx_k_potentials[] = "potentials";
static char __pyx_k_properties[] = "properties";
static char __pyx_k_queue_type[] = "queue_type";
static char __pyx_k_root_label[] = "root_label";
static char __pyx_k_superfinal[] = "superfinal";
static char __pyx_k_NO_EPSILONS[] = "NO_EPSILONS";
static char __pyx_k_Read_failed[] = "Read failed";
static char __pyx_k_UserWarning[] = "UserWarning";
static char __pyx_k_determinize[] = "determinize";
static char __pyx_k_push_labels[] = "push_labels";
static char __pyx_k_synchronize[] = "synchronize";
static char __pyx_k_to_standard[] = "to_standard";
static char __pyx_k_weight_type[] = "weight_type";
static char __pyx_k_COACCESSIBLE[] = "COACCESSIBLE";
static char __pyx_k_NOT_ACCEPTOR[] = "NOT_ACCEPTOR";
static char __pyx_k_Write_failed[] = "Write failed";
static char __pyx_k_alt_sequence[] = "alt_sequence";
static char __pyx_k_closure_plus[] = "closure_plus";
static char __pyx_k_disambiguate[] = "disambiguate";
static char __pyx_k_encode_reuse[] = "encode_reuse";
static char __pyx_k_epsnormalize[] = "epsnormalize";
static char __pyx_k_push_weights[] = "push_weights";
static char __pyx_k_return_label[] = "return_label";
static char __pyx_k_shortestpath[] = "shortestpath";
static char __pyx_k_NO_I_EPSILONS[] = "NO_I_EPSILONS";
static char __pyx_k_encode_labels[] = "encode_labels";
static char __pyx_k_fast_log_prob[] = "fast_log_prob";
static char __pyx_k_nonfunctional[] = "nonfunctional";
static char __pyx_k_weight_string[] = "weight_string";
static char __pyx_k_weight_type_2[] = "_weight_type";
static char __pyx_k_FST_PROPERTIES[] = "FST_PROPERTIES";
static char __pyx_k_INITIAL_CYCLIC[] = "INITIAL_CYCLIC";
static char __pyx_k_I_LABEL_SORTED[] = "I_LABEL_SORTED";
static char __pyx_k_NOT_ACCESSIBLE[] = "NOT_ACCESSIBLE";
static char __pyx_k_NOT_TOP_SORTED[] = "NOT_TOP_SORTED";
static char __pyx_k_NO_O_EPSILSONS[] = "NO_O_EPSILSONS";
static char __pyx_k_O_LABEL_SORTED[] = "O_LABEL_SORTED";
static char __pyx_k_codex_filename[] = "codex_filename";
static char __pyx_k_encode_weights[] = "encode_weights";
static char __pyx_k_get_queue_type[] = "_get_queue_type";
static char __pyx_k_project_output[] = "project_output";
static char __pyx_k_randequivalent[] = "randequivalent";
static char __pyx_k_COPY_PROPERTIES[] = "COPY_PROPERTIES";
static char __pyx_k_INITIAL_ACYCLIC[] = "INITIAL_ACYCLIC";
static char __pyx_k_I_DETERMINISTIC[] = "I_DETERMINISTIC";
static char __pyx_k_NULL_PROPERTIES[] = "NULL_PROPERTIES";
static char __pyx_k_O_DETERMINISTIC[] = "O_DETERMINISTIC";
static char __pyx_k_eps_norm_output[] = "eps_norm_output";
static char __pyx_k_type_r_string_r[] = "{}(type={!r}, string={!r})";
static char __pyx_k_NOT_COACCESSIBLE[] = "NOT_COACCESSIBLE";
static char __pyx_k_Operation_failed[] = "Operation failed";
static char __pyx_k_shortestdistance[] = "shortestdistance";
static char __pyx_k_BINARY_PROPERTIES[] = "BINARY_PROPERTIES";
static char __pyx_k_call_arc_labeling[] = "call_arc_labeling";
static char __pyx_k_ADD_ARC_PROPERTIES[] = "ADD_ARC_PROPERTIES";
static char __pyx_k_Invalid_operator_r[] = "Invalid operator {!r}";
static char __pyx_k_NOT_I_LABEL_SORTED[] = "NOT_I_LABEL_SORTED";
static char __pyx_k_NOT_O_LABEL_SORTED[] = "NOT_O_LABEL_SORTED";
static char __pyx_k_SET_ARC_PROPERTIES[] = "SET_ARC_PROPERTIES";
static char __pyx_k_TRINARY_PROPERTIES[] = "TRINARY_PROPERTIES";
static char __pyx_k_Unknown_map_type_r[] = "Unknown map type: {!r}";
static char __pyx_k_epsilon_on_replace[] = "epsilon_on_replace";
static char __pyx_k_get_compose_filter[] = "_get_compose_filter";
static char __pyx_k_ARC_SORT_PROPERTIES[] = "ARC_SORT_PROPERTIES";
static char __pyx_k_Input_FST_is_cyclic[] = "Input FST is cyclic.";
static char __pyx_k_NON_I_DETERMINISTIC[] = "NON_I_DETERMINISTIC";
static char __pyx_k_NON_O_DETERMINISTIC[] = "NON_O_DETERMINISTIC";
static char __pyx_k_NotImplementedError[] = "NotImplementedError";
static char __pyx_k_Unknown_sort_type_r[] = "Unknown sort type {!r}";
static char __pyx_k_fst_error_fatal_old[] = "_fst_error_fatal_old";
static char __pyx_k_remove_common_affix[] = "remove_common_affix";
static char __pyx_k_remove_total_weight[] = "remove_total_weight";
static char __pyx_k_return_arc_labeling[] = "return_arc_labeling";
static char __pyx_k_subsequential_label[] = "subsequential_label";
static char __pyx_k_ADD_STATE_PROPERTIES[] = "ADD_STATE_PROPERTIES";
static char __pyx_k_EXTRINSIC_PROPERTIES[] = "EXTRINSIC_PROPERTIES";
static char __pyx_k_INTRINSIC_PROPERTIES[] = "INTRINSIC_PROPERTIES";
static char __pyx_k_SET_FINAL_PROPERTIES[] = "SET_FINAL_PROPERTIES";
static char __pyx_k_SET_START_PROPERTIES[] = "SET_START_PROPERTIES";
static char __pyx_k_Unknown_queue_type_r[] = "Unknown queue type: {!r}";
static char __pyx_k_require_superinitial[] = "require_superinitial";
static char __pyx_k_DELETE_ARC_PROPERTIES[] = "DELETE_ARC_PROPERTIES";
static char __pyx_k_STATE_SORT_PROPERTIES[] = "STATE_SORT_PROPERTIES";
static char __pyx_k_NEG_TRINARY_PROPERTIES[] = "NEG_TRINARY_PROPERTIES";
static char __pyx_k_POS_TRINARY_PROPERTIES[] = "POS_TRINARY_PROPERTIES";
static char __pyx_k_check_mutating_imethod[] = "_check_mutating_imethod";
static char __pyx_k_get_rand_arc_selection[] = "_get_rand_arc_selection";
static char __pyx_k_get_replace_label_type[] = "_get_replace_label_type";
static char __pyx_k_DELETE_STATE_PROPERTIES[] = "DELETE_STATE_PROPERTIES";
static char __pyx_k_RM_SUPERFINAL_PROPERTIES[] = "RM_SUPERFINAL_PROPERTIES";
static char __pyx_k_ADD_SUPERFINAL_PROPERTIES[] = "ADD_SUPERFINAL_PROPERTIES";
static char __pyx_k_Unknown_determinize_type_r[] = "Unknown determinize type: {!r}";
static char __pyx_k_Warning_for_FST_operations[] = "Warning for FST operations.";
static char __pyx_k_WEIGHT_INVARIANT_PROPERTIES[] = "WEIGHT_INVARIANT_PROPERTIES";
static char __pyx_k_I_LABEL_INVARIANT_PROPERTIES[] = "I_LABEL_INVARIANT_PROPERTIES";
static char __pyx_k_O_LABEL_INVARIANT_PROPERTIES[] = "O_LABEL_INVARIANT_PROPERTIES";
static char __pyx_k_Unknown_replace_label_type_r[] = "Unknown replace label type: {!r}";
static char __pyx_k_Cannot_encode_r_as_bytestring[] = "Cannot encode {!r} as bytestring";
static char __pyx_k_No_relabeling_pairs_specified[] = "No relabeling pairs specified";
static char __pyx_k_Unknown_compose_filter_type_r[] = "Unknown compose filter type: {!r}";
static char __pyx_k_increment_subsequential_label[] = "increment_subsequential_label";
static char __pyx_k_usr_local_google_home_kbg_tmp_O[] = "/usr/local/google/home/kbg/tmp/OpenFst/src/extensions/python/fst.pyx";
static char __pyx_k_Equivalence_test_encountered_err[] = "Equivalence test encountered error";
static char __pyx_k_Exception_thrown_when_FST_operat[] = "Exception thrown when FST operations fails.";
static char __pyx_k_Input_FSTs_must_have_the_same_ar[] = "Input FSTs must have the same arc type";
static char __pyx_k_Isomorphism_test_encountered_err[] = "Isomorphism test encountered error";
static char __pyx_k_Python_interface_to_nlp_fst_scri[] = "Python interface to //nlp/fst/script.\n\nOperations which construct new FSTs are implemented as traditional functions,\nas are two-argument boolean functions like `equal` and `equivalent`. Destructive)\noperations---those that mutate an FST, in place---are instance methods, as is\n`write`. Operator overloading is not used. The following example, based on Mohri\net al. 2002, shows the construction of an ASR system given a pronunciation\nlexicon L, grammar G, a transducer from context-dependent phones to\ncontext-independent phones C, and an HMM set H:\n\n  L = fst.Fst(\"L.fst\")\n  G = fst.Fst(\"G.fst\")\n  C = fst.Fst(\"C.fst\")\n  H = fst.Fst(\"H.fst\")\n  LG = fst.determinize(fst.compose(L, G))\n  CLG = fst.determinize(fst.compose(C, LG))\n  HCLG = fst.determinize(fst.compose(H, CLG))\n  HCLG.minimize()                                    # NB: works in-place\n\nPython variables here use snake_case and constants are in all caps, minus the\nnormal `k` prefix.\n";
static char __pyx_k_Random_equivalence_test_encounte[] = "Random equivalence test encountered error";
static char __pyx_k_Read_time_conversion_to_r_failed[] = "Read-time conversion to {!r} failed.";
static char __pyx_k_Unknown_random_arc_selection_typ[] = "Unknown random arc selection type: {!r}";
static PyObject *__pyx_n_s_ACCEPTOR;
static PyObject *__pyx_n_s_ACCESSIBLE;
static PyObject *__pyx_n_s_ACYCLIC;
static PyObject *__pyx_n_s_ADD_ARC_PROPERTIES;
static PyObject *__pyx_n_s_ADD_STATE_PROPERTIES;
static PyObject *__pyx_n_s_ADD_SUPERFINAL_PROPERTIES;
static PyObject *__pyx_n_s_ARC_SORT_PROPERTIES;
static PyObject *__pyx_n_s_BINARY_PROPERTIES;
static PyObject *__pyx_n_s_COACCESSIBLE;
static PyObject *__pyx_n_s_COPY_PROPERTIES;
static PyObject *__pyx_n_s_CYCLIC;
static PyObject *__pyx_kp_s_Cannot_encode_r_as_bytestring;
static PyObject *__pyx_n_s_DELETE_ARC_PROPERTIES;
static PyObject *__pyx_n_s_DELETE_STATE_PROPERTIES;
static PyObject *__pyx_n_s_EPSILONS;
static PyObject *__pyx_n_s_ERROR;
static PyObject *__pyx_n_s_EXPANDED;
static PyObject *__pyx_n_s_EXTRINSIC_PROPERTIES;
static PyObject *__pyx_kp_s_Equivalence_test_encountered_err;
static PyObject *__pyx_n_s_Exception;
static PyObject *__pyx_kp_s_Exception_thrown_when_FST_operat;
static PyObject *__pyx_n_s_FST_PROPERTIES;
static PyObject *__pyx_n_s_Fst;
static PyObject *__pyx_n_s_FstError;
static PyObject *__pyx_n_s_FstWarning;
static PyObject *__pyx_kp_s_Fst_at;
static PyObject *__pyx_n_s_INITIAL_ACYCLIC;
static PyObject *__pyx_n_s_INITIAL_CYCLIC;
static PyObject *__pyx_n_s_INTRINSIC_PROPERTIES;
static PyObject *__pyx_n_s_I_DETERMINISTIC;
static PyObject *__pyx_n_s_I_EPSILONS;
static PyObject *__pyx_n_s_I_LABEL_INVARIANT_PROPERTIES;
static PyObject *__pyx_n_s_I_LABEL_SORTED;
static PyObject *__pyx_kp_s_Input_FST_is_cyclic;
static PyObject *__pyx_kp_s_Input_FSTs_must_have_the_same_ar;
static PyObject *__pyx_kp_s_Invalid_operator_r;
static PyObject *__pyx_kp_s_Isomorphism_test_encountered_err;
static PyObject *__pyx_n_s_MUTABLE;
static PyObject *__pyx_n_s_NEG_TRINARY_PROPERTIES;
static PyObject *__pyx_n_s_NON_I_DETERMINISTIC;
static PyObject *__pyx_n_s_NON_O_DETERMINISTIC;
static PyObject *__pyx_n_s_NOT_ACCEPTOR;
static PyObject *__pyx_n_s_NOT_ACCESSIBLE;
static PyObject *__pyx_n_s_NOT_COACCESSIBLE;
static PyObject *__pyx_n_s_NOT_I_LABEL_SORTED;
static PyObject *__pyx_n_s_NOT_O_LABEL_SORTED;
static PyObject *__pyx_n_s_NOT_STRING;
static PyObject *__pyx_n_s_NOT_TOP_SORTED;
static PyObject *__pyx_n_s_NO_EPSILONS;
static PyObject *__pyx_n_s_NO_I_EPSILONS;
static PyObject *__pyx_n_s_NO_O_EPSILSONS;
static PyObject *__pyx_n_s_NULL_PROPERTIES;
static PyObject *__pyx_kp_s_No_relabeling_pairs_specified;
static PyObject *__pyx_n_s_NotImplementedError;
static PyObject *__pyx_n_s_O_DETERMINISTIC;
static PyObject *__pyx_n_s_O_EPSILONS;
static PyObject *__pyx_n_s_O_LABEL_INVARIANT_PROPERTIES;
static PyObject *__pyx_n_s_O_LABEL_SORTED;
static PyObject *__pyx_kp_s_Operation_failed;
static PyObject *__pyx_n_s_POS_TRINARY_PROPERTIES;
static PyObject *__pyx_n_s_RM_SUPERFINAL_PROPERTIES;
static PyObject *__pyx_kp_s_Random_equivalence_test_encounte;
static PyObject *__pyx_kp_s_Read_failed;
static PyObject *__pyx_kp_s_Read_time_conversion_to_r_failed;
static PyObject *__pyx_n_s_SET_ARC_PROPERTIES;
static PyObject *__pyx_n_s_SET_FINAL_PROPERTIES;
static PyObject *__pyx_n_s_SET_START_PROPERTIES;
static PyObject *__pyx_n_s_STATE_SORT_PROPERTIES;
static PyObject *__pyx_n_s_STRING;
static PyObject *__pyx_n_s_TOP_SORTED;
static PyObject *__pyx_n_s_TRINARY_PROPERTIES;
static PyObject *__pyx_n_s_UNWEIGHTED;
static PyObject *__pyx_kp_s_UTF_8;
static PyObject *__pyx_kp_s_Unknown_compose_filter_type_r;
static PyObject *__pyx_kp_s_Unknown_determinize_type_r;
static PyObject *__pyx_kp_s_Unknown_map_type_r;
static PyObject *__pyx_kp_s_Unknown_queue_type_r;
static PyObject *__pyx_kp_s_Unknown_random_arc_selection_typ;
static PyObject *__pyx_kp_s_Unknown_replace_label_type_r;
static PyObject *__pyx_kp_s_Unknown_sort_type_r;
static PyObject *__pyx_n_s_UserWarning;
static PyObject *__pyx_n_s_ValueError;
static PyObject *__pyx_n_s_WEIGHTED;
static PyObject *__pyx_n_s_WEIGHT_INVARIANT_PROPERTIES;
static PyObject *__pyx_kp_s_Warning_for_FST_operations;
static PyObject *__pyx_kp_s_Write_failed;
static PyObject *__pyx_kp_b__5;
static PyObject *__pyx_n_b_arc_sum;
static PyObject *__pyx_n_s_arc_type;
static PyObject *__pyx_n_s_arcmap;
static PyObject *__pyx_n_b_auto;
static PyObject *__pyx_n_s_cal;
static PyObject *__pyx_n_s_call_arc_labeling;
static PyObject *__pyx_n_s_cf;
static PyObject *__pyx_n_s_check_mutating_imethod;
static PyObject *__pyx_n_s_class;
static PyObject *__pyx_n_s_closure_plus;
static PyObject *__pyx_n_s_codex_filename;
static PyObject *__pyx_n_s_compose;
static PyObject *__pyx_n_s_connect;
static PyObject *__pyx_n_s_convert;
static PyObject *__pyx_n_s_delta;
static PyObject *__pyx_n_s_det_type;
static PyObject *__pyx_n_s_determinize;
static PyObject *__pyx_n_s_difference;
static PyObject *__pyx_n_b_disambiguate;
static PyObject *__pyx_n_s_disambiguate;
static PyObject *__pyx_n_s_distance;
static PyObject *__pyx_n_s_doc;
static PyObject *__pyx_n_s_dt;
static PyObject *__pyx_n_s_encode;
static PyObject *__pyx_n_s_encode_labels;
static PyObject *__pyx_n_s_encode_reuse;
static PyObject *__pyx_n_s_encode_weights;
static PyObject *__pyx_n_s_eps_norm_output;
static PyObject *__pyx_n_s_epsilon_on_replace;
static PyObject *__pyx_n_s_epsnormalize;
static PyObject *__pyx_n_s_equal;
static PyObject *__pyx_n_s_equivalent;
static PyObject *__pyx_n_s_error;
static PyObject *__pyx_n_s_filename;
static PyObject *__pyx_n_s_flags;
static PyObject *__pyx_n_s_format;
static PyObject *__pyx_n_s_fst;
static PyObject *__pyx_n_s_fst_error_fatal_old;
static PyObject *__pyx_n_s_fst_type;
static PyObject *__pyx_n_s_fst_type_2;
static PyObject *__pyx_n_b_functional;
static PyObject *__pyx_n_s_get_compose_filter;
static PyObject *__pyx_n_s_get_queue_type;
static PyObject *__pyx_n_s_get_rand_arc_selection;
static PyObject *__pyx_n_s_get_replace_label_type;
static PyObject *__pyx_n_s_hex;
static PyObject *__pyx_n_s_id;
static PyObject *__pyx_n_b_identity;
static PyObject *__pyx_n_s_ifst;
static PyObject *__pyx_n_s_ifst1;
static PyObject *__pyx_n_s_ifst2;
static PyObject *__pyx_n_b_ilabel;
static PyObject *__pyx_n_s_increment_subsequential_label;
static PyObject *__pyx_n_b_input;
static PyObject *__pyx_n_s_intersect;
static PyObject *__pyx_n_b_invert;
static PyObject *__pyx_n_s_ipairs;
static PyObject *__pyx_n_s_isomorphic;
static PyObject *__pyx_n_s_it;
static PyObject *__pyx_n_s_label;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_map_type;
static PyObject *__pyx_n_s_mask;
static PyObject *__pyx_n_s_max_length;
static PyObject *__pyx_n_s_metaclass;
static PyObject *__pyx_n_s_module;
static PyObject *__pyx_n_s_mt;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_b_neither;
static PyObject *__pyx_n_b_nonfunctional;
static PyObject *__pyx_n_s_npath;
static PyObject *__pyx_n_s_nshortest;
static PyObject *__pyx_n_s_nstate;
static PyObject *__pyx_n_b_olabel;
static PyObject *__pyx_n_s_opairs;
static PyObject *__pyx_n_s_opts;
static PyObject *__pyx_n_s_pairs;
static PyObject *__pyx_n_s_pairs_2;
static PyObject *__pyx_n_b_plus;
static PyObject *__pyx_n_s_potentials;
static PyObject *__pyx_n_s_prepare;
static PyObject *__pyx_n_s_project_output;
static PyObject *__pyx_n_s_properties;
static PyObject *__pyx_n_s_property;
static PyObject *__pyx_n_s_prune;
static PyObject *__pyx_n_s_push;
static PyObject *__pyx_n_s_push_labels;
static PyObject *__pyx_n_s_push_weights;
static PyObject *__pyx_n_s_qt;
static PyObject *__pyx_n_s_qualname;
static PyObject *__pyx_n_b_quantize;
static PyObject *__pyx_n_s_queue_type;
static PyObject *__pyx_n_s_ral;
static PyObject *__pyx_n_s_randequivalent;
static PyObject *__pyx_n_s_randgen;
static PyObject *__pyx_n_s_ras;
static PyObject *__pyx_n_s_remove_common_affix;
static PyObject *__pyx_n_s_remove_total_weight;
static PyObject *__pyx_n_s_replace;
static PyObject *__pyx_n_s_require_superinitial;
static PyObject *__pyx_n_s_result;
static PyObject *__pyx_n_s_return_arc_labeling;
static PyObject *__pyx_n_s_return_label;
static PyObject *__pyx_n_s_reverse;
static PyObject *__pyx_n_s_rlt;
static PyObject *__pyx_n_s_rmepsilon;
static PyObject *__pyx_n_b_rmweight;
static PyObject *__pyx_n_s_root_label;
static PyObject *__pyx_n_s_rt;
static PyObject *__pyx_n_s_seed;
static PyObject *__pyx_n_s_select;
static PyObject *__pyx_n_s_shortestdistance;
static PyObject *__pyx_n_s_shortestpath;
static PyObject *__pyx_n_s_sort_type;
static PyObject *__pyx_n_s_string;
static PyObject *__pyx_n_s_subsequential_label;
static PyObject *__pyx_n_b_superfinal;
static PyObject *__pyx_n_s_synchronize;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_n_s_test_2;
static PyObject *__pyx_n_s_tfst;
static PyObject *__pyx_n_b_times;
static PyObject *__pyx_n_s_to_final;
static PyObject *__pyx_n_b_to_log;
static PyObject *__pyx_n_b_to_log64;
static PyObject *__pyx_n_b_to_standard;
static PyObject *__pyx_n_s_type;
static PyObject *__pyx_kp_s_type_r_string_r;
static PyObject *__pyx_n_b_uniform;
static PyObject *__pyx_n_s_unique;
static PyObject *__pyx_kp_s_usr_local_google_home_kbg_tmp_O;
static PyObject *__pyx_n_s_wc;
static PyObject *__pyx_n_s_weight;
static PyObject *__pyx_n_s_weight_string;
static PyObject *__pyx_n_s_weight_type;
static PyObject *__pyx_n_s_weight_type_2;
static PyObject *__pyx_n_s_weighted;
static float __pyx_k__4;
static float __pyx_k__6;
static int64 __pyx_k__7;
static float __pyx_k__8;
static float __pyx_k__10;
static int64 __pyx_k__11;
static float __pyx_k__16;
static float __pyx_k__18;
static int64 __pyx_k__19;
static float __pyx_k__20;
static int64 __pyx_k__21;
static std::string __pyx_k__22;
static float __pyx_k__23;
static float __pyx_k__24;
static float __pyx_k__26;
static float __pyx_k__28;
static int64 __pyx_k__29;
static float __pyx_k__30;
static float __pyx_k__31;
static int32 __pyx_k__32;
static int32 __pyx_k__33;
static int32 __pyx_k__35;
static int32 __pyx_k__36;
static float __pyx_k__37;
static int64 __pyx_k__38;
static float __pyx_k__39;
static int64 __pyx_k__40;
static float __pyx_k__41;
static int64 __pyx_k__42;
static PyObject *__pyx_tuple_;
static PyObject *__pyx_tuple__2;
static PyObject *__pyx_tuple__3;
static PyObject *__pyx_tuple__9;
static PyObject *__pyx_tuple__12;
static PyObject *__pyx_tuple__13;
static PyObject *__pyx_tuple__14;
static PyObject *__pyx_tuple__15;
static PyObject *__pyx_tuple__17;
static PyObject *__pyx_tuple__25;
static PyObject *__pyx_tuple__27;
static PyObject *__pyx_tuple__34;
static PyObject *__pyx_tuple__43;
static PyObject *__pyx_tuple__45;
static PyObject *__pyx_tuple__47;
static PyObject *__pyx_tuple__49;
static PyObject *__pyx_tuple__51;
static PyObject *__pyx_tuple__53;
static PyObject *__pyx_tuple__55;
static PyObject *__pyx_tuple__57;
static PyObject *__pyx_tuple__59;
static PyObject *__pyx_tuple__61;
static PyObject *__pyx_tuple__63;
static PyObject *__pyx_tuple__65;
static PyObject *__pyx_tuple__67;
static PyObject *__pyx_tuple__69;
static PyObject *__pyx_tuple__71;
static PyObject *__pyx_tuple__73;
static PyObject *__pyx_tuple__75;
static PyObject *__pyx_tuple__77;
static PyObject *__pyx_tuple__79;
static PyObject *__pyx_tuple__81;
static PyObject *__pyx_tuple__83;
static PyObject *__pyx_tuple__85;
static PyObject *__pyx_tuple__87;
static PyObject *__pyx_tuple__89;
static PyObject *__pyx_tuple__91;
static PyObject *__pyx_tuple__93;
static PyObject *__pyx_codeobj__44;
static PyObject *__pyx_codeobj__46;
static PyObject *__pyx_codeobj__48;
static PyObject *__pyx_codeobj__50;
static PyObject *__pyx_codeobj__52;
static PyObject *__pyx_codeobj__54;
static PyObject *__pyx_codeobj__56;
static PyObject *__pyx_codeobj__58;
static PyObject *__pyx_codeobj__60;
static PyObject *__pyx_codeobj__62;
static PyObject *__pyx_codeobj__64;
static PyObject *__pyx_codeobj__66;
static PyObject *__pyx_codeobj__68;
static PyObject *__pyx_codeobj__70;
static PyObject *__pyx_codeobj__72;
static PyObject *__pyx_codeobj__74;
static PyObject *__pyx_codeobj__76;
static PyObject *__pyx_codeobj__78;
static PyObject *__pyx_codeobj__80;
static PyObject *__pyx_codeobj__82;
static PyObject *__pyx_codeobj__84;
static PyObject *__pyx_codeobj__86;
static PyObject *__pyx_codeobj__88;
static PyObject *__pyx_codeobj__90;
static PyObject *__pyx_codeobj__92;
static PyObject *__pyx_codeobj__94;

/* "fst.pyx":519
 * 
 * 
 * cdef bytes tobytes(data):             # <<<<<<<<<<<<<<
 *   """Converts strings to bytestrings.
 * 
 */

static PyObject *__pyx_f_3fst_tobytes(PyObject *__pyx_v_data) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tobytes", 0);

  /* "fst.pyx":540
 *   """
 *   # Python 2 strings and Python 3 bytestrings are both instances of `bytes`.
 *   if isinstance(data, bytes):             # <<<<<<<<<<<<<<
 *     return data
 *   # Attempts to encode anything not known to be a bytestring.
 */
  __pyx_t_1 = PyBytes_Check(__pyx_v_data); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "fst.pyx":541
 *   # Python 2 strings and Python 3 bytestrings are both instances of `bytes`.
 *   if isinstance(data, bytes):
 *     return data             # <<<<<<<<<<<<<<
 *   # Attempts to encode anything not known to be a bytestring.
 *   try:
 */
    __Pyx_XDECREF(__pyx_r);
    if (!(likely(PyBytes_CheckExact(__pyx_v_data))||((__pyx_v_data) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_data)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 541; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_INCREF(__pyx_v_data);
    __pyx_r = ((PyObject*)__pyx_v_data);
    goto __pyx_L0;
  }

  /* "fst.pyx":543
 *     return data
 *   # Attempts to encode anything not known to be a bytestring.
 *   try:             # <<<<<<<<<<<<<<
 *     # Tries to cast to string if necessary
 *     return (data if hasattr(data, "encode") else str(data)).encode("UTF-8")
 */
  {
    __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_4, &__pyx_t_5);
    __Pyx_XGOTREF(__pyx_t_3);
    __Pyx_XGOTREF(__pyx_t_4);
    __Pyx_XGOTREF(__pyx_t_5);
    /*try:*/ {

      /* "fst.pyx":545
 *   try:
 *     # Tries to cast to string if necessary
 *     return (data if hasattr(data, "encode") else str(data)).encode("UTF-8")             # <<<<<<<<<<<<<<
 *   except Exception:
 *     raise ValueError("Cannot encode {!r} as bytestring".format(data))
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_2 = PyObject_HasAttr(__pyx_v_data, __pyx_n_s_encode); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      if ((__pyx_t_2 != 0)) {
        __Pyx_INCREF(__pyx_v_data);
        __pyx_t_6 = __pyx_v_data;
      } else {
        __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_INCREF(__pyx_v_data);
        PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_v_data);
        __Pyx_GIVEREF(__pyx_v_data);
        __pyx_t_8 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)(&PyString_Type))), __pyx_t_7, NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __pyx_t_6 = __pyx_t_8;
        __pyx_t_8 = 0;
      }
      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_encode); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      if (!(likely(PyBytes_CheckExact(__pyx_t_6))||((__pyx_t_6) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_6)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      __pyx_r = ((PyObject*)__pyx_t_6);
      __pyx_t_6 = 0;
      goto __pyx_L8_try_return;
    }
    __pyx_L4_error:;
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "fst.pyx":546
 *     # Tries to cast to string if necessary
 *     return (data if hasattr(data, "encode") else str(data)).encode("UTF-8")
 *   except Exception:             # <<<<<<<<<<<<<<
 *     raise ValueError("Cannot encode {!r} as bytestring".format(data))
 * 
 */
    __pyx_t_9 = PyErr_ExceptionMatches(__pyx_builtin_Exception);
    if (__pyx_t_9) {
      __Pyx_AddTraceback("fst.tobytes", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_6, &__pyx_t_8, &__pyx_t_7) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 546; __pyx_clineno = __LINE__; goto __pyx_L6_except_error;}
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_GOTREF(__pyx_t_7);

      /* "fst.pyx":547
 *     return (data if hasattr(data, "encode") else str(data)).encode("UTF-8")
 *   except Exception:
 *     raise ValueError("Cannot encode {!r} as bytestring".format(data))             # <<<<<<<<<<<<<<
 * 
 * 
 */
      __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Cannot_encode_r_as_bytestring, __pyx_n_s_format); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L6_except_error;}
      __Pyx_GOTREF(__pyx_t_11);
      __pyx_t_12 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_11))) {
        __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_11);
        if (likely(__pyx_t_12)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_11);
          __Pyx_INCREF(__pyx_t_12);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_11, function);
        }
      }
      if (!__pyx_t_12) {
        __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_t_11, __pyx_v_data); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L6_except_error;}
        __Pyx_GOTREF(__pyx_t_10);
      } else {
        __pyx_t_13 = PyTuple_New(1+1); if (unlikely(!__pyx_t_13)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L6_except_error;}
        __Pyx_GOTREF(__pyx_t_13);
        PyTuple_SET_ITEM(__pyx_t_13, 0, __pyx_t_12); __Pyx_GIVEREF(__pyx_t_12); __pyx_t_12 = NULL;
        __Pyx_INCREF(__pyx_v_data);
        PyTuple_SET_ITEM(__pyx_t_13, 0+1, __pyx_v_data);
        __Pyx_GIVEREF(__pyx_v_data);
        __pyx_t_10 = __Pyx_PyObject_Call(__pyx_t_11, __pyx_t_13, NULL); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L6_except_error;}
        __Pyx_GOTREF(__pyx_t_10);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      }
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
      __pyx_t_11 = PyTuple_New(1); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L6_except_error;}
      __Pyx_GOTREF(__pyx_t_11);
      PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_10);
      __Pyx_GIVEREF(__pyx_t_10);
      __pyx_t_10 = 0;
      __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_11, NULL); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L6_except_error;}
      __Pyx_GOTREF(__pyx_t_10);
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_Raise(__pyx_t_10, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L6_except_error;}
    }
    goto __pyx_L6_except_error;
    __pyx_L6_except_error:;
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_XGIVEREF(__pyx_t_4);
    __Pyx_XGIVEREF(__pyx_t_5);
    __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
    goto __pyx_L1_error;
    __pyx_L8_try_return:;
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_XGIVEREF(__pyx_t_4);
    __Pyx_XGIVEREF(__pyx_t_5);
    __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
    goto __pyx_L0;
  }

  /* "fst.pyx":519
 * 
 * 
 * cdef bytes tobytes(data):             # <<<<<<<<<<<<<<
 *   """Converts strings to bytestrings.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_AddTraceback("fst.tobytes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":550
 * 
 * 
 * def _get_compose_filter(string cf):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate ComposeFilter enum value.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_1_get_compose_filter(PyObject *__pyx_self, PyObject *__pyx_arg_cf); /*proto*/
static char __pyx_doc_3fst__get_compose_filter[] = "Matches string with the appropriate ComposeFilter enum value.\n\n  This function takes a string argument and returns the matching ComposeFilter\n  enum value used to initialize ComposeOptions instances. ComposeOptions is used\n  by difference and intersection in addition to composition.\n\n  Args:\n    cf: A string matching a known composition filter.\n\n  Returns:\n    A ComposeFilter enum value.\n\n  Raises:\n    FstError\n  ";
static PyMethodDef __pyx_mdef_3fst_1_get_compose_filter = {"_get_compose_filter", (PyCFunction)__pyx_pw_3fst_1_get_compose_filter, METH_O, __pyx_doc_3fst__get_compose_filter};
static PyObject *__pyx_pw_3fst_1_get_compose_filter(PyObject *__pyx_self, PyObject *__pyx_arg_cf) {
  std::string __pyx_v_cf;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_get_compose_filter (wrapper)", 0);
  assert(__pyx_arg_cf); {
    __pyx_v_cf = __pyx_convert_string_from_py_(__pyx_arg_cf); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 550; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._get_compose_filter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst__get_compose_filter(__pyx_self, ((std::string)__pyx_v_cf));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst__get_compose_filter(CYTHON_UNUSED PyObject *__pyx_self, std::string __pyx_v_cf) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_get_compose_filter", 0);

  /* "fst.pyx":566
 *     FstError
 *   """
 *   if cf == b"alt_sequence":             # <<<<<<<<<<<<<<
 *     return ALT_SEQUENCE_FILTER
 *   if cf == b"auto":
 */
  __pyx_t_1 = ((__pyx_v_cf == __pyx_k_alt_sequence) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":567
 *   """
 *   if cf == b"alt_sequence":
 *     return ALT_SEQUENCE_FILTER             # <<<<<<<<<<<<<<
 *   if cf == b"auto":
 *     return AUTO_FILTER
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::ALT_SEQUENCE_FILTER); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 567; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":568
 *   if cf == b"alt_sequence":
 *     return ALT_SEQUENCE_FILTER
 *   if cf == b"auto":             # <<<<<<<<<<<<<<
 *     return AUTO_FILTER
 *   if cf == b"match":
 */
  __pyx_t_1 = ((__pyx_v_cf == __pyx_k_auto) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":569
 *     return ALT_SEQUENCE_FILTER
 *   if cf == b"auto":
 *     return AUTO_FILTER             # <<<<<<<<<<<<<<
 *   if cf == b"match":
 *     return MATCH_FILTER
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::AUTO_FILTER); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":570
 *   if cf == b"auto":
 *     return AUTO_FILTER
 *   if cf == b"match":             # <<<<<<<<<<<<<<
 *     return MATCH_FILTER
 *   if cf == b"null":
 */
  __pyx_t_1 = ((__pyx_v_cf == __pyx_k_match) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":571
 *     return AUTO_FILTER
 *   if cf == b"match":
 *     return MATCH_FILTER             # <<<<<<<<<<<<<<
 *   if cf == b"null":
 *     return NULL_FILTER
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::MATCH_FILTER); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":572
 *   if cf == b"match":
 *     return MATCH_FILTER
 *   if cf == b"null":             # <<<<<<<<<<<<<<
 *     return NULL_FILTER
 *   if cf == b"sequence":
 */
  __pyx_t_1 = ((__pyx_v_cf == __pyx_k_null) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":573
 *     return MATCH_FILTER
 *   if cf == b"null":
 *     return NULL_FILTER             # <<<<<<<<<<<<<<
 *   if cf == b"sequence":
 *     return SEQUENCE_FILTER
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::NULL_FILTER); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":574
 *   if cf == b"null":
 *     return NULL_FILTER
 *   if cf == b"sequence":             # <<<<<<<<<<<<<<
 *     return SEQUENCE_FILTER
 *   raise FstError("Unknown compose filter type: {!r}".format(cf))
 */
  __pyx_t_1 = ((__pyx_v_cf == __pyx_k_sequence) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":575
 *     return NULL_FILTER
 *   if cf == b"sequence":
 *     return SEQUENCE_FILTER             # <<<<<<<<<<<<<<
 *   raise FstError("Unknown compose filter type: {!r}".format(cf))
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::SEQUENCE_FILTER); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":576
 *   if cf == b"sequence":
 *     return SEQUENCE_FILTER
 *   raise FstError("Unknown compose filter type: {!r}".format(cf))             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Unknown_compose_filter_type_r, __pyx_n_s_format); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = __pyx_convert_string_to_py_(__pyx_v_cf); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_7 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_7)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  if (!__pyx_t_7) {
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_4);
  } else {
    __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __Pyx_GIVEREF(__pyx_t_7); __pyx_t_7 = NULL;
    PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    __pyx_t_6 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  }
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_5) {
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_2);
  } else {
    __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_5); __Pyx_GIVEREF(__pyx_t_5); __pyx_t_5 = NULL;
    PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_8, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_Raise(__pyx_t_2, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":550
 * 
 * 
 * def _get_compose_filter(string cf):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate ComposeFilter enum value.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("fst._get_compose_filter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":579
 * 
 * 
 * def _get_queue_type(string qt):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate QueueType enum value.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_3_get_queue_type(PyObject *__pyx_self, PyObject *__pyx_arg_qt); /*proto*/
static char __pyx_doc_3fst_2_get_queue_type[] = "Matches string with the appropriate QueueType enum value.\n\n  This function takes a string argument and returns the matching QueueType enum\n  value passed to the RmEpsilonOptions constructor.\n\n  Args:\n    qt: A string matching a known queue type.\n\n  Returns:\n    A QueueType enum value.\n\n  Raises:\n    FstError.\n  ";
static PyMethodDef __pyx_mdef_3fst_3_get_queue_type = {"_get_queue_type", (PyCFunction)__pyx_pw_3fst_3_get_queue_type, METH_O, __pyx_doc_3fst_2_get_queue_type};
static PyObject *__pyx_pw_3fst_3_get_queue_type(PyObject *__pyx_self, PyObject *__pyx_arg_qt) {
  std::string __pyx_v_qt;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_get_queue_type (wrapper)", 0);
  assert(__pyx_arg_qt); {
    __pyx_v_qt = __pyx_convert_string_from_py_(__pyx_arg_qt); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 579; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._get_queue_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_2_get_queue_type(__pyx_self, ((std::string)__pyx_v_qt));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_2_get_queue_type(CYTHON_UNUSED PyObject *__pyx_self, std::string __pyx_v_qt) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_get_queue_type", 0);

  /* "fst.pyx":594
 *     FstError.
 *   """
 *   if qt == b"auto":             # <<<<<<<<<<<<<<
 *     return AUTO_QUEUE
 *   if qt == b"fifo":
 */
  __pyx_t_1 = ((__pyx_v_qt == __pyx_k_auto) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":595
 *   """
 *   if qt == b"auto":
 *     return AUTO_QUEUE             # <<<<<<<<<<<<<<
 *   if qt == b"fifo":
 *     return FIFO_QUEUE
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::AUTO_QUEUE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 595; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":596
 *   if qt == b"auto":
 *     return AUTO_QUEUE
 *   if qt == b"fifo":             # <<<<<<<<<<<<<<
 *     return FIFO_QUEUE
 *   if qt == b"lifo":
 */
  __pyx_t_1 = ((__pyx_v_qt == __pyx_k_fifo) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":597
 *     return AUTO_QUEUE
 *   if qt == b"fifo":
 *     return FIFO_QUEUE             # <<<<<<<<<<<<<<
 *   if qt == b"lifo":
 *     return LIFO_QUEUE
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::FIFO_QUEUE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":598
 *   if qt == b"fifo":
 *     return FIFO_QUEUE
 *   if qt == b"lifo":             # <<<<<<<<<<<<<<
 *     return LIFO_QUEUE
 *   if qt == b"shortest":
 */
  __pyx_t_1 = ((__pyx_v_qt == __pyx_k_lifo) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":599
 *     return FIFO_QUEUE
 *   if qt == b"lifo":
 *     return LIFO_QUEUE             # <<<<<<<<<<<<<<
 *   if qt == b"shortest":
 *     return SHORTEST_FIRST_QUEUE
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::LIFO_QUEUE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 599; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":600
 *   if qt == b"lifo":
 *     return LIFO_QUEUE
 *   if qt == b"shortest":             # <<<<<<<<<<<<<<
 *     return SHORTEST_FIRST_QUEUE
 *   if qt == b"state":
 */
  __pyx_t_1 = ((__pyx_v_qt == __pyx_k_shortest) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":601
 *     return LIFO_QUEUE
 *   if qt == b"shortest":
 *     return SHORTEST_FIRST_QUEUE             # <<<<<<<<<<<<<<
 *   if qt == b"state":
 *     return STATE_ORDER_QUEUE
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::SHORTEST_FIRST_QUEUE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 601; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":602
 *   if qt == b"shortest":
 *     return SHORTEST_FIRST_QUEUE
 *   if qt == b"state":             # <<<<<<<<<<<<<<
 *     return STATE_ORDER_QUEUE
 *   if qt == b"top":
 */
  __pyx_t_1 = ((__pyx_v_qt == __pyx_k_state) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":603
 *     return SHORTEST_FIRST_QUEUE
 *   if qt == b"state":
 *     return STATE_ORDER_QUEUE             # <<<<<<<<<<<<<<
 *   if qt == b"top":
 *     return TOP_ORDER_QUEUE
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::STATE_ORDER_QUEUE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 603; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":604
 *   if qt == b"state":
 *     return STATE_ORDER_QUEUE
 *   if qt == b"top":             # <<<<<<<<<<<<<<
 *     return TOP_ORDER_QUEUE
 *   raise FstError("Unknown queue type: {!r}".format(qt))
 */
  __pyx_t_1 = ((__pyx_v_qt == __pyx_k_top) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":605
 *     return STATE_ORDER_QUEUE
 *   if qt == b"top":
 *     return TOP_ORDER_QUEUE             # <<<<<<<<<<<<<<
 *   raise FstError("Unknown queue type: {!r}".format(qt))
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::TOP_ORDER_QUEUE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 605; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":606
 *   if qt == b"top":
 *     return TOP_ORDER_QUEUE
 *   raise FstError("Unknown queue type: {!r}".format(qt))             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 606; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Unknown_queue_type_r, __pyx_n_s_format); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 606; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = __pyx_convert_string_to_py_(__pyx_v_qt); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 606; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_7 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_7)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  if (!__pyx_t_7) {
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 606; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_4);
  } else {
    __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 606; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __Pyx_GIVEREF(__pyx_t_7); __pyx_t_7 = NULL;
    PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    __pyx_t_6 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 606; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  }
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_5) {
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 606; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_2);
  } else {
    __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 606; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_5); __Pyx_GIVEREF(__pyx_t_5); __pyx_t_5 = NULL;
    PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_8, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 606; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_Raise(__pyx_t_2, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 606; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":579
 * 
 * 
 * def _get_queue_type(string qt):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate QueueType enum value.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("fst._get_queue_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":609
 * 
 * 
 * def _get_rand_arc_selection(string ras):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate RandArcSelection enum value.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_5_get_rand_arc_selection(PyObject *__pyx_self, PyObject *__pyx_arg_ras); /*proto*/
static char __pyx_doc_3fst_4_get_rand_arc_selection[] = "Matches string with the appropriate RandArcSelection enum value.\n\n  This function takes a string argument and returns the matching\n  RandArcSelection enum value passed to the RandGenOptions constructor.\n\n  Args:\n    ras: A string matching a known random arc selection type.\n\n  Returns:\n    A RandArcSelection enum value.\n\n  Raises:\n    FstError.\n  ";
static PyMethodDef __pyx_mdef_3fst_5_get_rand_arc_selection = {"_get_rand_arc_selection", (PyCFunction)__pyx_pw_3fst_5_get_rand_arc_selection, METH_O, __pyx_doc_3fst_4_get_rand_arc_selection};
static PyObject *__pyx_pw_3fst_5_get_rand_arc_selection(PyObject *__pyx_self, PyObject *__pyx_arg_ras) {
  std::string __pyx_v_ras;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_get_rand_arc_selection (wrapper)", 0);
  assert(__pyx_arg_ras); {
    __pyx_v_ras = __pyx_convert_string_from_py_(__pyx_arg_ras); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 609; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._get_rand_arc_selection", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_4_get_rand_arc_selection(__pyx_self, ((std::string)__pyx_v_ras));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_4_get_rand_arc_selection(CYTHON_UNUSED PyObject *__pyx_self, std::string __pyx_v_ras) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_get_rand_arc_selection", 0);

  /* "fst.pyx":624
 *     FstError.
 *   """
 *   if ras == b"uniform":             # <<<<<<<<<<<<<<
 *     return UNIFORM_ARC_SELECTOR
 *   if ras == b"log_prob":
 */
  __pyx_t_1 = ((__pyx_v_ras == __pyx_k_uniform) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":625
 *   """
 *   if ras == b"uniform":
 *     return UNIFORM_ARC_SELECTOR             # <<<<<<<<<<<<<<
 *   if ras == b"log_prob":
 *     return LOG_PROB_ARC_SELECTOR
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::script::UNIFORM_ARC_SELECTOR); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 625; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":626
 *   if ras == b"uniform":
 *     return UNIFORM_ARC_SELECTOR
 *   if ras == b"log_prob":             # <<<<<<<<<<<<<<
 *     return LOG_PROB_ARC_SELECTOR
 *   if ras == b"fast_log_prob":
 */
  __pyx_t_1 = ((__pyx_v_ras == __pyx_k_log_prob) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":627
 *     return UNIFORM_ARC_SELECTOR
 *   if ras == b"log_prob":
 *     return LOG_PROB_ARC_SELECTOR             # <<<<<<<<<<<<<<
 *   if ras == b"fast_log_prob":
 *     return FAST_LOG_PROB_ARC_SELECTOR
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::script::LOG_PROB_ARC_SELECTOR); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":628
 *   if ras == b"log_prob":
 *     return LOG_PROB_ARC_SELECTOR
 *   if ras == b"fast_log_prob":             # <<<<<<<<<<<<<<
 *     return FAST_LOG_PROB_ARC_SELECTOR
 *   raise FstError("Unknown random arc selection type: {!r}".format(ras))
 */
  __pyx_t_1 = ((__pyx_v_ras == __pyx_k_fast_log_prob) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":629
 *     return LOG_PROB_ARC_SELECTOR
 *   if ras == b"fast_log_prob":
 *     return FAST_LOG_PROB_ARC_SELECTOR             # <<<<<<<<<<<<<<
 *   raise FstError("Unknown random arc selection type: {!r}".format(ras))
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = PyInt_FromLong(fst::script::FAST_LOG_PROB_ARC_SELECTOR); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 629; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":630
 *   if ras == b"fast_log_prob":
 *     return FAST_LOG_PROB_ARC_SELECTOR
 *   raise FstError("Unknown random arc selection type: {!r}".format(ras))             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Unknown_random_arc_selection_typ, __pyx_n_s_format); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = __pyx_convert_string_to_py_(__pyx_v_ras); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_7 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_7)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  if (!__pyx_t_7) {
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_4);
  } else {
    __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __Pyx_GIVEREF(__pyx_t_7); __pyx_t_7 = NULL;
    PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    __pyx_t_6 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  }
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_5) {
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_2);
  } else {
    __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_5); __Pyx_GIVEREF(__pyx_t_5); __pyx_t_5 = NULL;
    PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_8, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_Raise(__pyx_t_2, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":609
 * 
 * 
 * def _get_rand_arc_selection(string ras):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate RandArcSelection enum value.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("fst._get_rand_arc_selection", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":633
 * 
 * 
 * def _get_replace_label_type(string rlt, bool epsilon_on_replace):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate ReplaceLabelType enum value.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_7_get_replace_label_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_6_get_replace_label_type[] = "Matches string with the appropriate ReplaceLabelType enum value.\n\n  This function takes a string argument and returns the matching\n  ReplaceLabelType enum value passed to the ReplaceOptions constructor.\n\n  Args:\n    rlt: A string matching a known replace label type.\n    epsilon_on_replace: Should call/return arcs be epsilon arcs?\n\n  Returns:\n    A ReplaceLabelType enum value.\n\n  Raises:\n    FstError.\n  ";
static PyMethodDef __pyx_mdef_3fst_7_get_replace_label_type = {"_get_replace_label_type", (PyCFunction)__pyx_pw_3fst_7_get_replace_label_type, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_6_get_replace_label_type};
static PyObject *__pyx_pw_3fst_7_get_replace_label_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  std::string __pyx_v_rlt;
  bool __pyx_v_epsilon_on_replace;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_get_replace_label_type (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_rlt,&__pyx_n_s_epsilon_on_replace,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_rlt)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_epsilon_on_replace)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_get_replace_label_type", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_get_replace_label_type") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_rlt = __pyx_convert_string_from_py_(values[0]); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_epsilon_on_replace = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_epsilon_on_replace == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_get_replace_label_type", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._get_replace_label_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_6_get_replace_label_type(__pyx_self, __pyx_v_rlt, __pyx_v_epsilon_on_replace);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_6_get_replace_label_type(CYTHON_UNUSED PyObject *__pyx_self, std::string __pyx_v_rlt, bool __pyx_v_epsilon_on_replace) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_get_replace_label_type", 0);

  /* "fst.pyx":649
 *     FstError.
 *   """
 *   if rlt == b"neither" or epsilon_on_replace:             # <<<<<<<<<<<<<<
 *     return REPLACE_LABEL_NEITHER
 *   if rlt == b"input":
 */
  __pyx_t_2 = ((__pyx_v_rlt == __pyx_k_neither) != 0);
  if (!__pyx_t_2) {
    goto __pyx_L5_next_or;
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_L5_next_or:;
  __pyx_t_2 = (__pyx_v_epsilon_on_replace != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_1) {

    /* "fst.pyx":650
 *   """
 *   if rlt == b"neither" or epsilon_on_replace:
 *     return REPLACE_LABEL_NEITHER             # <<<<<<<<<<<<<<
 *   if rlt == b"input":
 *     return REPLACE_LABEL_INPUT
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = PyInt_FromLong(fst::REPLACE_LABEL_NEITHER); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 650; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":651
 *   if rlt == b"neither" or epsilon_on_replace:
 *     return REPLACE_LABEL_NEITHER
 *   if rlt == b"input":             # <<<<<<<<<<<<<<
 *     return REPLACE_LABEL_INPUT
 *   if rlt == b"output":
 */
  __pyx_t_1 = ((__pyx_v_rlt == __pyx_k_input) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":652
 *     return REPLACE_LABEL_NEITHER
 *   if rlt == b"input":
 *     return REPLACE_LABEL_INPUT             # <<<<<<<<<<<<<<
 *   if rlt == b"output":
 *     return REPLACE_LABEL_OUTPUT
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = PyInt_FromLong(fst::REPLACE_LABEL_INPUT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 652; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":653
 *   if rlt == b"input":
 *     return REPLACE_LABEL_INPUT
 *   if rlt == b"output":             # <<<<<<<<<<<<<<
 *     return REPLACE_LABEL_OUTPUT
 *   if rlt == b"both":
 */
  __pyx_t_1 = ((__pyx_v_rlt == __pyx_k_output) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":654
 *     return REPLACE_LABEL_INPUT
 *   if rlt == b"output":
 *     return REPLACE_LABEL_OUTPUT             # <<<<<<<<<<<<<<
 *   if rlt == b"both":
 *     return REPLACE_LABEL_BOTH
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = PyInt_FromLong(fst::REPLACE_LABEL_OUTPUT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 654; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":655
 *   if rlt == b"output":
 *     return REPLACE_LABEL_OUTPUT
 *   if rlt == b"both":             # <<<<<<<<<<<<<<
 *     return REPLACE_LABEL_BOTH
 *   raise FstError("Unknown replace label type: {!r}".format(rlt))
 */
  __pyx_t_1 = ((__pyx_v_rlt == __pyx_k_both) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":656
 *     return REPLACE_LABEL_OUTPUT
 *   if rlt == b"both":
 *     return REPLACE_LABEL_BOTH             # <<<<<<<<<<<<<<
 *   raise FstError("Unknown replace label type: {!r}".format(rlt))
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = PyInt_FromLong(fst::REPLACE_LABEL_BOTH); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 656; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":657
 *   if rlt == b"both":
 *     return REPLACE_LABEL_BOTH
 *   raise FstError("Unknown replace label type: {!r}".format(rlt))             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Unknown_replace_label_type_r, __pyx_n_s_format); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_7 = __pyx_convert_string_to_py_(__pyx_v_rlt); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_8 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_8)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_8);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
    }
  }
  if (!__pyx_t_8) {
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_GOTREF(__pyx_t_5);
  } else {
    __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_9);
    PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_8); __Pyx_GIVEREF(__pyx_t_8); __pyx_t_8 = NULL;
    PyTuple_SET_ITEM(__pyx_t_9, 0+1, __pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    __pyx_t_7 = 0;
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_9, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  }
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  if (!__pyx_t_6) {
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_3);
  } else {
    __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_9);
    PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_6); __Pyx_GIVEREF(__pyx_t_6); __pyx_t_6 = NULL;
    PyTuple_SET_ITEM(__pyx_t_9, 0+1, __pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_5);
    __pyx_t_5 = 0;
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_9, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_Raise(__pyx_t_3, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":633
 * 
 * 
 * def _get_replace_label_type(string rlt, bool epsilon_on_replace):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate ReplaceLabelType enum value.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("fst._get_replace_label_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":660
 * 
 * 
 * cdef WeightClass _get_weight_class(weight_type, weight):             # <<<<<<<<<<<<<<
 *   """Converts weight string to Weightclass instance.
 * 
 */

static fst::script::WeightClass __pyx_f_3fst__get_weight_class(PyObject *__pyx_v_weight_type, PyObject *__pyx_v_weight) {
  fst::script::WeightClass __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  fst::script::WeightClass __pyx_t_2;
  Py_ssize_t __pyx_t_3;
  std::string __pyx_t_4;
  std::string __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_get_weight_class", 0);
  __Pyx_INCREF(__pyx_v_weight_type);
  __Pyx_INCREF(__pyx_v_weight);

  /* "fst.pyx":676
 *   This function is not visible to Python users.
 *   """
 *   weight_type = tobytes(weight_type)             # <<<<<<<<<<<<<<
 *   weight = tobytes(weight)
 *   return (Zero() if len(weight) == 0 else
 */
  __pyx_t_1 = __pyx_f_3fst_tobytes(__pyx_v_weight_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 676; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF_SET(__pyx_v_weight_type, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "fst.pyx":677
 *   """
 *   weight_type = tobytes(weight_type)
 *   weight = tobytes(weight)             # <<<<<<<<<<<<<<
 *   return (Zero() if len(weight) == 0 else
 *                     WeightClass(weight_type, weight))
 */
  __pyx_t_1 = __pyx_f_3fst_tobytes(__pyx_v_weight); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 677; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF_SET(__pyx_v_weight, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "fst.pyx":678
 *   weight_type = tobytes(weight_type)
 *   weight = tobytes(weight)
 *   return (Zero() if len(weight) == 0 else             # <<<<<<<<<<<<<<
 *                     WeightClass(weight_type, weight))
 * 
 */
  __pyx_t_3 = PyObject_Length(__pyx_v_weight); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 678; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (((__pyx_t_3 == 0) != 0)) {
    __pyx_t_2 = fst::script::WeightClass::Zero();
  } else {

    /* "fst.pyx":679
 *   weight = tobytes(weight)
 *   return (Zero() if len(weight) == 0 else
 *                     WeightClass(weight_type, weight))             # <<<<<<<<<<<<<<
 * 
 * 
 */
    __pyx_t_4 = __pyx_convert_string_from_py_(__pyx_v_weight_type); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_5 = __pyx_convert_string_from_py_(__pyx_v_weight); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_2 = fst::script::WeightClass(__pyx_t_4, __pyx_t_5);
  }
  __pyx_r = __pyx_t_2;
  goto __pyx_L0;

  /* "fst.pyx":660
 * 
 * 
 * cdef WeightClass _get_weight_class(weight_type, weight):             # <<<<<<<<<<<<<<
 *   """Converts weight string to Weightclass instance.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_WriteUnraisable("fst._get_weight_class", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_weight_type);
  __Pyx_XDECREF(__pyx_v_weight);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":686
 *   cdef WeightClass *weight
 * 
 *   def __repr__(self):             # <<<<<<<<<<<<<<
 *     return "{}(type={!r}, string={!r})".format(self.__class__.__name__,
 *                                                self.type, self.string)
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_6Weight_1__repr__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_3fst_6Weight_1__repr__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__repr__ (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_6Weight___repr__(((struct __pyx_obj_3fst_Weight *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_6Weight___repr__(struct __pyx_obj_3fst_Weight *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  Py_ssize_t __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__repr__", 0);

  /* "fst.pyx":687
 * 
 *   def __repr__(self):
 *     return "{}(type={!r}, string={!r})".format(self.__class__.__name__,             # <<<<<<<<<<<<<<
 *                                                self.type, self.string)
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_type_r_string_r, __pyx_n_s_format); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 687; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_class); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 687; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_name); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 687; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "fst.pyx":688
 *   def __repr__(self):
 *     return "{}(type={!r}, string={!r})".format(self.__class__.__name__,
 *                                                self.type, self.string)             # <<<<<<<<<<<<<<
 * 
 *   def __init__(self, weight_type, weight_string):
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_type); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 688; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_string); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 688; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = NULL;
  __pyx_t_7 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_7 = 1;
    }
  }
  __pyx_t_8 = PyTuple_New(3+__pyx_t_7); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 687; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_8);
  if (__pyx_t_6) {
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __Pyx_GIVEREF(__pyx_t_6); __pyx_t_6 = NULL;
  }
  PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_8, 2+__pyx_t_7, __pyx_t_5);
  __Pyx_GIVEREF(__pyx_t_5);
  __pyx_t_4 = 0;
  __pyx_t_3 = 0;
  __pyx_t_5 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 687; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":686
 *   cdef WeightClass *weight
 * 
 *   def __repr__(self):             # <<<<<<<<<<<<<<
 *     return "{}(type={!r}, string={!r})".format(self.__class__.__name__,
 *                                                self.type, self.string)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("fst.Weight.__repr__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":690
 *                                                self.type, self.string)
 * 
 *   def __init__(self, weight_type, weight_string):             # <<<<<<<<<<<<<<
 *     self.weight = new WeightClass(tobytes(weight_type), tobytes(weight_string))
 * 
 */

/* Python wrapper */
static int __pyx_pw_3fst_6Weight_3__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_3fst_6Weight_3__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_weight_type = 0;
  PyObject *__pyx_v_weight_string = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_weight_type,&__pyx_n_s_weight_string,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_weight_type)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_weight_string)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 690; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 690; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_weight_type = values[0];
    __pyx_v_weight_string = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 690; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.Weight.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_6Weight_2__init__(((struct __pyx_obj_3fst_Weight *)__pyx_v_self), __pyx_v_weight_type, __pyx_v_weight_string);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_3fst_6Weight_2__init__(struct __pyx_obj_3fst_Weight *__pyx_v_self, PyObject *__pyx_v_weight_type, PyObject *__pyx_v_weight_string) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  std::string __pyx_t_3;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "fst.pyx":691
 * 
 *   def __init__(self, weight_type, weight_string):
 *     self.weight = new WeightClass(tobytes(weight_type), tobytes(weight_string))             # <<<<<<<<<<<<<<
 * 
 *   def __dealloc__(self):
 */
  __pyx_t_1 = __pyx_f_3fst_tobytes(__pyx_v_weight_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 691; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 691; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __pyx_f_3fst_tobytes(__pyx_v_weight_string); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 691; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 691; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_self->weight = new fst::script::WeightClass(__pyx_t_2, __pyx_t_3);

  /* "fst.pyx":690
 *                                                self.type, self.string)
 * 
 *   def __init__(self, weight_type, weight_string):             # <<<<<<<<<<<<<<
 *     self.weight = new WeightClass(tobytes(weight_type), tobytes(weight_string))
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst.Weight.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":693
 *     self.weight = new WeightClass(tobytes(weight_type), tobytes(weight_string))
 * 
 *   def __dealloc__(self):             # <<<<<<<<<<<<<<
 *     del self.weight
 * 
 */

/* Python wrapper */
static void __pyx_pw_3fst_6Weight_5__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_3fst_6Weight_5__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_3fst_6Weight_4__dealloc__(((struct __pyx_obj_3fst_Weight *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_3fst_6Weight_4__dealloc__(struct __pyx_obj_3fst_Weight *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "fst.pyx":694
 * 
 *   def __dealloc__(self):
 *     del self.weight             # <<<<<<<<<<<<<<
 * 
 *   def __richcmp__(Weight x, Weight y, int op):
 */
  delete __pyx_v_self->weight;

  /* "fst.pyx":693
 *     self.weight = new WeightClass(tobytes(weight_type), tobytes(weight_string))
 * 
 *   def __dealloc__(self):             # <<<<<<<<<<<<<<
 *     del self.weight
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "fst.pyx":696
 *     del self.weight
 * 
 *   def __richcmp__(Weight x, Weight y, int op):             # <<<<<<<<<<<<<<
 *     # This is useful for unit tests.
 *     if op == 2:  # `==`
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_6Weight_7__richcmp__(PyObject *__pyx_v_x, PyObject *__pyx_v_y, int __pyx_v_op); /*proto*/
static PyObject *__pyx_pw_3fst_6Weight_7__richcmp__(PyObject *__pyx_v_x, PyObject *__pyx_v_y, int __pyx_v_op) {
  CYTHON_UNUSED int __pyx_lineno = 0;
  CYTHON_UNUSED const char *__pyx_filename = NULL;
  CYTHON_UNUSED int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__richcmp__ (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_x), __pyx_ptype_3fst_Weight, 1, "x", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 696; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_y), __pyx_ptype_3fst_Weight, 1, "y", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 696; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_6Weight_6__richcmp__(((struct __pyx_obj_3fst_Weight *)__pyx_v_x), ((struct __pyx_obj_3fst_Weight *)__pyx_v_y), ((int)__pyx_v_op));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_6Weight_6__richcmp__(struct __pyx_obj_3fst_Weight *__pyx_v_x, struct __pyx_obj_3fst_Weight *__pyx_v_y, int __pyx_v_op) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__richcmp__", 0);

  /* "fst.pyx":701
 *       return (x.weight.Type() == y.weight.Type() and
 *               x.weight.to_string() == y.weight.to_string())
 *     elif op == 3:  # `!=`             # <<<<<<<<<<<<<<
 *       return not (x == y)
 *     else:
 */
  switch (__pyx_v_op) {

    /* "fst.pyx":698
 *   def __richcmp__(Weight x, Weight y, int op):
 *     # This is useful for unit tests.
 *     if op == 2:  # `==`             # <<<<<<<<<<<<<<
 *       return (x.weight.Type() == y.weight.Type() and
 *               x.weight.to_string() == y.weight.to_string())
 */
    case 2:

    /* "fst.pyx":699
 *     # This is useful for unit tests.
 *     if op == 2:  # `==`
 *       return (x.weight.Type() == y.weight.Type() and             # <<<<<<<<<<<<<<
 *               x.weight.to_string() == y.weight.to_string())
 *     elif op == 3:  # `!=`
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = (__pyx_v_x->weight->Type() == __pyx_v_y->weight->Type());
    if (__pyx_t_2) {
      goto __pyx_L4_next_and;
    } else {
      __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 699; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_1 = __pyx_t_3;
      __pyx_t_3 = 0;
      goto __pyx_L3_bool_binop_done;
    }
    __pyx_L4_next_and:;

    /* "fst.pyx":700
 *     if op == 2:  # `==`
 *       return (x.weight.Type() == y.weight.Type() and
 *               x.weight.to_string() == y.weight.to_string())             # <<<<<<<<<<<<<<
 *     elif op == 3:  # `!=`
 *       return not (x == y)
 */
    __pyx_t_2 = (__pyx_v_x->weight->to_string() == __pyx_v_y->weight->to_string());
    __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 700; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __pyx_t_3;
    __pyx_t_3 = 0;
    __pyx_L3_bool_binop_done:;
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;
    break;

    /* "fst.pyx":701
 *       return (x.weight.Type() == y.weight.Type() and
 *               x.weight.to_string() == y.weight.to_string())
 *     elif op == 3:  # `!=`             # <<<<<<<<<<<<<<
 *       return not (x == y)
 *     else:
 */
    case 3:

    /* "fst.pyx":702
 *               x.weight.to_string() == y.weight.to_string())
 *     elif op == 3:  # `!=`
 *       return not (x == y)             # <<<<<<<<<<<<<<
 *     else:
 *       raise NotImplementedError("Invalid operator {!r}".format(op))
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = PyObject_RichCompare(((PyObject *)__pyx_v_x), ((PyObject *)__pyx_v_y), Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyBool_FromLong((!__pyx_t_2)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;
    break;
    default:

    /* "fst.pyx":704
 *       return not (x == y)
 *     else:
 *       raise NotImplementedError("Invalid operator {!r}".format(op))             # <<<<<<<<<<<<<<
 * 
 *   @property
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Invalid_operator_r, __pyx_n_s_format); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_op); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __Pyx_GIVEREF(__pyx_t_5); __pyx_t_5 = NULL;
      PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_1);
    __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    break;
  }

  /* "fst.pyx":696
 *     del self.weight
 * 
 *   def __richcmp__(Weight x, Weight y, int op):             # <<<<<<<<<<<<<<
 *     # This is useful for unit tests.
 *     if op == 2:  # `==`
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("fst.Weight.__richcmp__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":707
 * 
 *   @property
 *   def type(self):             # <<<<<<<<<<<<<<
 *     return self.weight.Type()
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_6Weight_9type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_3fst_6Weight_9type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("type (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_6Weight_8type(((struct __pyx_obj_3fst_Weight *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_6Weight_8type(struct __pyx_obj_3fst_Weight *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("type", 0);

  /* "fst.pyx":708
 *   @property
 *   def type(self):
 *     return self.weight.Type()             # <<<<<<<<<<<<<<
 * 
 *   @property
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_convert_string_to_py_(__pyx_v_self->weight->Type()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":707
 * 
 *   @property
 *   def type(self):             # <<<<<<<<<<<<<<
 *     return self.weight.Type()
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst.Weight.type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":711
 * 
 *   @property
 *   def string(self):             # <<<<<<<<<<<<<<
 *     return self.weight.to_string()
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_6Weight_11string(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_3fst_6Weight_11string(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("string (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_6Weight_10string(((struct __pyx_obj_3fst_Weight *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_6Weight_10string(struct __pyx_obj_3fst_Weight *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("string", 0);

  /* "fst.pyx":712
 *   @property
 *   def string(self):
 *     return self.weight.to_string()             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_convert_string_to_py_(__pyx_v_self->weight->to_string()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 712; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":711
 * 
 *   @property
 *   def string(self):             # <<<<<<<<<<<<<<
 *     return self.weight.to_string()
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst.Weight.string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":724
 *   cdef FstClass *fst
 * 
 *   def __repr__(self):             # <<<<<<<<<<<<<<
 *     return "<{} Fst at {}>".format(self._fst_type, hex(id(self)))
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_4_Fst_1__repr__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_3fst_4_Fst_1__repr__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__repr__ (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_4_Fst___repr__(((struct __pyx_obj_3fst__Fst *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_4_Fst___repr__(struct __pyx_obj_3fst__Fst *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  Py_ssize_t __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__repr__", 0);

  /* "fst.pyx":725
 * 
 *   def __repr__(self):
 *     return "<{} Fst at {}>".format(self._fst_type, hex(id(self)))             # <<<<<<<<<<<<<<
 * 
 *   def write(self, filename):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Fst_at, __pyx_n_s_format); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_fst_type); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_id, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5);
  __Pyx_GIVEREF(__pyx_t_5);
  __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_hex, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_6 = 1;
    }
  }
  __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_7);
  if (__pyx_t_4) {
    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __Pyx_GIVEREF(__pyx_t_4); __pyx_t_4 = NULL;
  }
  PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_t_5);
  __Pyx_GIVEREF(__pyx_t_5);
  __pyx_t_3 = 0;
  __pyx_t_5 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":724
 *   cdef FstClass *fst
 * 
 *   def __repr__(self):             # <<<<<<<<<<<<<<
 *     return "<{} Fst at {}>".format(self._fst_type, hex(id(self)))
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("fst._Fst.__repr__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":727
 *     return "<{} Fst at {}>".format(self._fst_type, hex(id(self)))
 * 
 *   def write(self, filename):             # <<<<<<<<<<<<<<
 *     """Writes the FST to a file.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_4_Fst_3write(PyObject *__pyx_v_self, PyObject *__pyx_v_filename); /*proto*/
static char __pyx_doc_3fst_4_Fst_2write[] = "Writes the FST to a file.\n\n    This function writes the FST to disk.\n\n    Args:\n      filename: The string location of the output file.\n    ";
static PyObject *__pyx_pw_3fst_4_Fst_3write(PyObject *__pyx_v_self, PyObject *__pyx_v_filename) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("write (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_4_Fst_2write(((struct __pyx_obj_3fst__Fst *)__pyx_v_self), ((PyObject *)__pyx_v_filename));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_4_Fst_2write(struct __pyx_obj_3fst__Fst *__pyx_v_self, PyObject *__pyx_v_filename) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("write", 0);

  /* "fst.pyx":735
 *       filename: The string location of the output file.
 *     """
 *     if not self.fst.Write(tobytes(filename)):             # <<<<<<<<<<<<<<
 *       raise FstError("Write failed")
 * 
 */
  __pyx_t_1 = __pyx_f_3fst_tobytes(__pyx_v_filename); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 735; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 735; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = ((!(__pyx_v_self->fst->Write(__pyx_t_2) != 0)) != 0);
  if (__pyx_t_3) {

    /* "fst.pyx":736
 *     """
 *     if not self.fst.Write(tobytes(filename)):
 *       raise FstError("Write failed")             # <<<<<<<<<<<<<<
 * 
 *   def properties(self, uint64 mask, bool test=True):
 */
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 736; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 736; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 736; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "fst.pyx":727
 *     return "<{} Fst at {}>".format(self._fst_type, hex(id(self)))
 * 
 *   def write(self, filename):             # <<<<<<<<<<<<<<
 *     """Writes the FST to a file.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("fst._Fst.write", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":738
 *       raise FstError("Write failed")
 * 
 *   def properties(self, uint64 mask, bool test=True):             # <<<<<<<<<<<<<<
 *     """Provides property bits.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_4_Fst_5properties(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_4_Fst_4properties[] = "Provides property bits.\n\n    This function provides user access to the properties attribute for the FST.\n    The resulting value is a long integer, but when it is cast to a boolean,\n    it represents whether or not the FST has the `mask` property.\n\n    Args:\n      mask: The property mask to be compared to the FST's properties.\n      test: Should any unknown values be computed before comparing against\n          the mask?\n\n    Returns:\n      A long integer representing the property value.\n    ";
static PyObject *__pyx_pw_3fst_4_Fst_5properties(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  uint64 __pyx_v_mask;
  bool __pyx_v_test;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("properties (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_mask,&__pyx_n_s_test,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_mask)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_test);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "properties") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 738; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_mask = __Pyx_PyInt_As_uint64_t(values[0]); if (unlikely((__pyx_v_mask == (uint64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 738; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    if (values[1]) {
      __pyx_v_test = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_test == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 738; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_test = ((bool)1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("properties", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 738; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._Fst.properties", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_4_Fst_4properties(((struct __pyx_obj_3fst__Fst *)__pyx_v_self), __pyx_v_mask, __pyx_v_test);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_4_Fst_4properties(struct __pyx_obj_3fst__Fst *__pyx_v_self, uint64 __pyx_v_mask, bool __pyx_v_test) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("properties", 0);

  /* "fst.pyx":753
 *       A long integer representing the property value.
 *     """
 *     return self.fst.Properties(mask, test)             # <<<<<<<<<<<<<<
 * 
 *   @property
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(__pyx_v_self->fst->Properties(__pyx_v_mask, __pyx_v_test)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 753; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":738
 *       raise FstError("Write failed")
 * 
 *   def properties(self, uint64 mask, bool test=True):             # <<<<<<<<<<<<<<
 *     """Provides property bits.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst._Fst.properties", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":756
 * 
 *   @property
 *   def _arc_type(self):             # <<<<<<<<<<<<<<
 *     """Returns the arc type of the internal FST.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_4_Fst_7_arc_type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_3fst_4_Fst_6_arc_type[] = "Returns the arc type of the internal FST.\n\n    Returns:\n      A string indicating the arc type of the internal FST.\n    ";
static PyObject *__pyx_pw_3fst_4_Fst_7_arc_type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_arc_type (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_4_Fst_6_arc_type(((struct __pyx_obj_3fst__Fst *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_4_Fst_6_arc_type(struct __pyx_obj_3fst__Fst *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_arc_type", 0);

  /* "fst.pyx":762
 *       A string indicating the arc type of the internal FST.
 *     """
 *     return self.fst.ArcType()             # <<<<<<<<<<<<<<
 * 
 *   @property
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_convert_string_to_py_(__pyx_v_self->fst->ArcType()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":756
 * 
 *   @property
 *   def _arc_type(self):             # <<<<<<<<<<<<<<
 *     """Returns the arc type of the internal FST.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst._Fst._arc_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":765
 * 
 *   @property
 *   def _fst_type(self):             # <<<<<<<<<<<<<<
 *     """Returns the type (i.e., data structure) of the internal FST.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_4_Fst_9_fst_type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_3fst_4_Fst_8_fst_type[] = "Returns the type (i.e., data structure) of the internal FST.\n\n    Returns:\n      A string indicating the storage type of the internal FST.\n    ";
static PyObject *__pyx_pw_3fst_4_Fst_9_fst_type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_fst_type (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_4_Fst_8_fst_type(((struct __pyx_obj_3fst__Fst *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_4_Fst_8_fst_type(struct __pyx_obj_3fst__Fst *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_fst_type", 0);

  /* "fst.pyx":771
 *       A string indicating the storage type of the internal FST.
 *     """
 *     return self.fst.FstType()             # <<<<<<<<<<<<<<
 * 
 *   @property
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_convert_string_to_py_(__pyx_v_self->fst->FstType()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 771; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":765
 * 
 *   @property
 *   def _fst_type(self):             # <<<<<<<<<<<<<<
 *     """Returns the type (i.e., data structure) of the internal FST.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst._Fst._fst_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":774
 * 
 *   @property
 *   def _weight_type(self):             # <<<<<<<<<<<<<<
 *     """Returns the weight type of the internal FST.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_4_Fst_11_weight_type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_3fst_4_Fst_10_weight_type[] = "Returns the weight type of the internal FST.\n\n    Returns:\n      A string indicating the weight type of the internal FST.\n    ";
static PyObject *__pyx_pw_3fst_4_Fst_11_weight_type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_weight_type (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_4_Fst_10_weight_type(((struct __pyx_obj_3fst__Fst *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_4_Fst_10_weight_type(struct __pyx_obj_3fst__Fst *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_weight_type", 0);

  /* "fst.pyx":780
 *       A string indicating the weight type of the internal FST.
 *     """
 *     return self.fst.WeightType()             # <<<<<<<<<<<<<<
 * 
 *   def verify(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_convert_string_to_py_(__pyx_v_self->fst->WeightType()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":774
 * 
 *   @property
 *   def _weight_type(self):             # <<<<<<<<<<<<<<
 *     """Returns the weight type of the internal FST.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst._Fst._weight_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":782
 *     return self.fst.WeightType()
 * 
 *   def verify(self):             # <<<<<<<<<<<<<<
 *     """Verifies that an FST's contents are sane.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_4_Fst_13verify(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_3fst_4_Fst_12verify[] = "Verifies that an FST's contents are sane.\n\n    Returns:\n      True if the contents are sane, False otherwise.\n    ";
static PyObject *__pyx_pw_3fst_4_Fst_13verify(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("verify (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_4_Fst_12verify(((struct __pyx_obj_3fst__Fst *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_4_Fst_12verify(struct __pyx_obj_3fst__Fst *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("verify", 0);

  /* "fst.pyx":788
 *       True if the contents are sane, False otherwise.
 *     """
 *     return Verify(deref(self.fst))             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(fst::script::Verify((*__pyx_v_self->fst))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 788; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":782
 *     return self.fst.WeightType()
 * 
 *   def verify(self):             # <<<<<<<<<<<<<<
 *     """Verifies that an FST's contents are sane.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst._Fst.verify", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":797
 *   cdef MutableFstClass *mfst
 * 
 *   def __dealloc__(self):             # <<<<<<<<<<<<<<
 *     if type(self) is _MutableFst:
 *       del self.mfst
 */

/* Python wrapper */
static void __pyx_pw_3fst_11_MutableFst_1__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_3fst_11_MutableFst_1__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_3fst_11_MutableFst___dealloc__(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_3fst_11_MutableFst___dealloc__(struct __pyx_obj_3fst__MutableFst *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "fst.pyx":798
 * 
 *   def __dealloc__(self):
 *     if type(self) is _MutableFst:             # <<<<<<<<<<<<<<
 *       del self.mfst
 * 
 */
  __pyx_t_1 = (((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))) == ((PyObject *)((PyObject*)__pyx_ptype_3fst__MutableFst)));
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "fst.pyx":799
 *   def __dealloc__(self):
 *     if type(self) is _MutableFst:
 *       del self.mfst             # <<<<<<<<<<<<<<
 * 
 *   def _check_mutating_imethod(self):
 */
    delete __pyx_v_self->mfst;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "fst.pyx":797
 *   cdef MutableFstClass *mfst
 * 
 *   def __dealloc__(self):             # <<<<<<<<<<<<<<
 *     if type(self) is _MutableFst:
 *       del self.mfst
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "fst.pyx":801
 *       del self.mfst
 * 
 *   def _check_mutating_imethod(self):             # <<<<<<<<<<<<<<
 *     """Checks whether a method mutating the FST has produced an error.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_3_check_mutating_imethod(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_2_check_mutating_imethod[] = "Checks whether a method mutating the FST has produced an error.\n\n    Raises:\n      FstError.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_3_check_mutating_imethod(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_check_mutating_imethod (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_11_MutableFst_2_check_mutating_imethod(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_2_check_mutating_imethod(struct __pyx_obj_3fst__MutableFst *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_check_mutating_imethod", 0);

  /* "fst.pyx":807
 *       FstError.
 *     """
 *     if self.properties(ERROR):             # <<<<<<<<<<<<<<
 *       raise FstError("Operation failed")
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_properties); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 807; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_ERROR); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 807; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 807; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 807; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __Pyx_GIVEREF(__pyx_t_4); __pyx_t_4 = NULL;
    PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 807; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 807; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_6) {

    /* "fst.pyx":808
 *     """
 *     if self.properties(ERROR):
 *       raise FstError("Operation failed")             # <<<<<<<<<<<<<<
 * 
 *   def arcsort(self, sort_type=b"ilabel"):
 */
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "fst.pyx":801
 *       del self.mfst
 * 
 *   def _check_mutating_imethod(self):             # <<<<<<<<<<<<<<
 *     """Checks whether a method mutating the FST has produced an error.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("fst._MutableFst._check_mutating_imethod", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":810
 *       raise FstError("Operation failed")
 * 
 *   def arcsort(self, sort_type=b"ilabel"):             # <<<<<<<<<<<<<<
 *     """Sorts arcs leaving each state of the FST.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_5arcsort(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_4arcsort[] = "Sorts arcs leaving each state of the FST.\n\n    This operation destructively sort arcs leaving each state using either input\n    or output labels.\n\n    Args:\n      sort_type: Either \"ilabel\" (sort arcs according to input labels) or\n          \"olabel\" (sort arcs according to output labels).\n\n    Raises:\n      FstError.\n\n    See also: `topsort`.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_5arcsort(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_sort_type = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("arcsort (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_sort_type,0};
    PyObject* values[1] = {0};
    values[0] = ((PyObject *)__pyx_n_b_ilabel);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_sort_type);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "arcsort") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 810; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_sort_type = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("arcsort", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 810; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._MutableFst.arcsort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_11_MutableFst_4arcsort(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), __pyx_v_sort_type);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_4arcsort(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_sort_type) {
  enum fst::script::ArcSortType __pyx_v_ast;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("arcsort", 0);
  __Pyx_INCREF(__pyx_v_sort_type);

  /* "fst.pyx":826
 *     """
 *     cdef ArcSortType ast
 *     sort_type = tobytes(sort_type)             # <<<<<<<<<<<<<<
 *     if sort_type == b"ilabel":
 *       ast = ILABEL_COMPARE
 */
  __pyx_t_1 = __pyx_f_3fst_tobytes(__pyx_v_sort_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF_SET(__pyx_v_sort_type, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "fst.pyx":827
 *     cdef ArcSortType ast
 *     sort_type = tobytes(sort_type)
 *     if sort_type == b"ilabel":             # <<<<<<<<<<<<<<
 *       ast = ILABEL_COMPARE
 *     elif sort_type == b"olabel":
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_sort_type, __pyx_n_b_ilabel, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":828
 *     sort_type = tobytes(sort_type)
 *     if sort_type == b"ilabel":
 *       ast = ILABEL_COMPARE             # <<<<<<<<<<<<<<
 *     elif sort_type == b"olabel":
 *       ast = OLABEL_COMPARE
 */
    __pyx_v_ast = fst::script::ILABEL_COMPARE;
    goto __pyx_L3;
  }

  /* "fst.pyx":829
 *     if sort_type == b"ilabel":
 *       ast = ILABEL_COMPARE
 *     elif sort_type == b"olabel":             # <<<<<<<<<<<<<<
 *       ast = OLABEL_COMPARE
 *     else:
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_sort_type, __pyx_n_b_olabel, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":830
 *       ast = ILABEL_COMPARE
 *     elif sort_type == b"olabel":
 *       ast = OLABEL_COMPARE             # <<<<<<<<<<<<<<
 *     else:
 *       raise FstError("Unknown sort type {!r}".format(sort_type))
 */
    __pyx_v_ast = fst::script::OLABEL_COMPARE;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "fst.pyx":832
 *       ast = OLABEL_COMPARE
 *     else:
 *       raise FstError("Unknown sort type {!r}".format(sort_type))             # <<<<<<<<<<<<<<
 *     ArcSort(self.mfst, ast)
 *     self._check_mutating_imethod()
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Unknown_sort_type_r, __pyx_n_s_format); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    if (!__pyx_t_6) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_sort_type); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_7);
      PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6); __Pyx_GIVEREF(__pyx_t_6); __pyx_t_6 = NULL;
      __Pyx_INCREF(__pyx_v_sort_type);
      PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_v_sort_type);
      __Pyx_GIVEREF(__pyx_v_sort_type);
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_7, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_7);
      PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __Pyx_GIVEREF(__pyx_t_5); __pyx_t_5 = NULL;
      PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L3:;

  /* "fst.pyx":833
 *     else:
 *       raise FstError("Unknown sort type {!r}".format(sort_type))
 *     ArcSort(self.mfst, ast)             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  fst::script::ArcSort(__pyx_v_self->mfst, __pyx_v_ast);

  /* "fst.pyx":834
 *       raise FstError("Unknown sort type {!r}".format(sort_type))
 *     ArcSort(self.mfst, ast)
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def closure(self, closure_plus=False):
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_7 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_7)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (__pyx_t_7) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_7); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":810
 *       raise FstError("Operation failed")
 * 
 *   def arcsort(self, sort_type=b"ilabel"):             # <<<<<<<<<<<<<<
 *     """Sorts arcs leaving each state of the FST.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("fst._MutableFst.arcsort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_sort_type);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":836
 *     self._check_mutating_imethod()
 * 
 *   def closure(self, closure_plus=False):             # <<<<<<<<<<<<<<
 *     """Computes concatenative closure.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_7closure(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_6closure[] = "Computes concatenative closure.\n\n    This operation destructively converts the FST to its concatenative closure.\n    If A transduces string x to y with weight a, then the closure transduces x\n    to y with weight a, xx to yy with weight a \\otimes a, xxx to yyy with weight\n    a \\otimes a \\otimes a, and so on. The the empty string is also transduced to\n    itself with weight 1 if `closure_plus` is False.\n\n    Args:\n      closure_plus: If False, do not accept the empty string.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_7closure(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_closure_plus = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("closure (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_closure_plus,0};
    PyObject* values[1] = {0};
    values[0] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_closure_plus);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "closure") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_closure_plus = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("closure", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._MutableFst.closure", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_11_MutableFst_6closure(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), __pyx_v_closure_plus);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_6closure(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_closure_plus) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  enum fst::ClosureType __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("closure", 0);

  /* "fst.pyx":848
 *       closure_plus: If False, do not accept the empty string.
 *     """
 *     Closure(self.mfst, CLOSURE_PLUS if closure_plus else CLOSURE_STAR)             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_closure_plus); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 848; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {
    __pyx_t_1 = fst::CLOSURE_PLUS;
  } else {
    __pyx_t_1 = fst::CLOSURE_STAR;
  }
  fst::script::Closure(__pyx_v_self->mfst, __pyx_t_1);

  /* "fst.pyx":849
 *     """
 *     Closure(self.mfst, CLOSURE_PLUS if closure_plus else CLOSURE_STAR)
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def concat(self, _Fst ifst):
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 849; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  if (__pyx_t_5) {
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 849; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  } else {
    __pyx_t_3 = __Pyx_PyObject_CallNoArg(__pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 849; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "fst.pyx":836
 *     self._check_mutating_imethod()
 * 
 *   def closure(self, closure_plus=False):             # <<<<<<<<<<<<<<
 *     """Computes concatenative closure.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("fst._MutableFst.closure", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":851
 *     self._check_mutating_imethod()
 * 
 *   def concat(self, _Fst ifst):             # <<<<<<<<<<<<<<
 *     """Computes the concatenation (product) of two FSTs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_9concat(PyObject *__pyx_v_self, PyObject *__pyx_v_ifst); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_8concat[] = "Computes the concatenation (product) of two FSTs.\n\n    This operation destructively concatenates the FST with a second FST. If A\n    transduces string x to y with weight a and B transduces string w to v with\n    weight b, then their concatenation transduces string xw to yv with weight a\n    \\otimes b.\n\n    Args:\n      ifst: The second input Fst.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_9concat(PyObject *__pyx_v_self, PyObject *__pyx_v_ifst) {
  CYTHON_UNUSED int __pyx_lineno = 0;
  CYTHON_UNUSED const char *__pyx_filename = NULL;
  CYTHON_UNUSED int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("concat (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 851; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_11_MutableFst_8concat(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), ((struct __pyx_obj_3fst__Fst *)__pyx_v_ifst));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_8concat(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("concat", 0);

  /* "fst.pyx":862
 *       ifst: The second input Fst.
 *     """
 *     Concat(self.mfst, deref(ifst.fst))             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  fst::script::Concat(__pyx_v_self->mfst, (*__pyx_v_ifst->fst));

  /* "fst.pyx":863
 *     """
 *     Concat(self.mfst, deref(ifst.fst))
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def connect(self):
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 863; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 863; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 863; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":851
 *     self._check_mutating_imethod()
 * 
 *   def concat(self, _Fst ifst):             # <<<<<<<<<<<<<<
 *     """Computes the concatenation (product) of two FSTs.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("fst._MutableFst.concat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":865
 *     self._check_mutating_imethod()
 * 
 *   def connect(self):             # <<<<<<<<<<<<<<
 *     """Removes unsuccessful paths.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_11connect(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_10connect[] = "Removes unsuccessful paths.\n\n    This operation destructively trims the FST, removing states and arcs that\n    are not part of any successful path.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_11connect(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("connect (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_11_MutableFst_10connect(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_10connect(struct __pyx_obj_3fst__MutableFst *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("connect", 0);

  /* "fst.pyx":871
 *     are not part of any successful path.
 *     """
 *     Connect(self.mfst)             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  fst::script::Connect(__pyx_v_self->mfst);

  /* "fst.pyx":872
 *     """
 *     Connect(self.mfst)
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def decode(self, codex_filename):
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 872; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 872; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 872; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":865
 *     self._check_mutating_imethod()
 * 
 *   def connect(self):             # <<<<<<<<<<<<<<
 *     """Removes unsuccessful paths.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("fst._MutableFst.connect", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":874
 *     self._check_mutating_imethod()
 * 
 *   def decode(self, codex_filename):             # <<<<<<<<<<<<<<
 *     """Decodes FST with encoded labels and/or weights.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_13decode(PyObject *__pyx_v_self, PyObject *__pyx_v_codex_filename); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_12decode[] = "Decodes FST with encoded labels and/or weights.\n\n    This operation reverses the encoding performed by `encode`.\n\n    Args:\n      filename: The string location of the codex to use.\n\n    See also: `encode`.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_13decode(PyObject *__pyx_v_self, PyObject *__pyx_v_codex_filename) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("decode (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_11_MutableFst_12decode(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), ((PyObject *)__pyx_v_codex_filename));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_12decode(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_codex_filename) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("decode", 0);

  /* "fst.pyx":884
 *     See also: `encode`.
 *     """
 *     Decode(self.mfst, tobytes(codex_filename))             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  __pyx_t_1 = __pyx_f_3fst_tobytes(__pyx_v_codex_filename); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  fst::script::Decode(__pyx_v_self->mfst, __pyx_t_2);

  /* "fst.pyx":885
 *     """
 *     Decode(self.mfst, tobytes(codex_filename))
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def encode(self, codex_filename, encode_labels=False,
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 885; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 885; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 885; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":874
 *     self._check_mutating_imethod()
 * 
 *   def decode(self, codex_filename):             # <<<<<<<<<<<<<<
 *     """Decodes FST with encoded labels and/or weights.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("fst._MutableFst.decode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":887
 *     self._check_mutating_imethod()
 * 
 *   def encode(self, codex_filename, encode_labels=False,             # <<<<<<<<<<<<<<
 *              bool encode_reuse=False, encode_weights=False):
 *     """Encodes FST labels and/or weights.
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_15encode(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_14encode[] = "Encodes FST labels and/or weights.\n\n    This operation allows for the representation of a weighted transducer as a\n    weighted acceptor, an unweighted transducer, or an unweighted acceptor by\n    considering the pair (input label, output label), the pair (input label,\n    weight), or the triple (input label, output label, weight) as a single\n    label.\n\n    Args:\n      filename: The string location of the codex to use.\n      encode_labels: Should labels be used as part of the encoding?\n      encode_weights: Should weights be used as part of the encoding?\n\n    See also: `decode`.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_15encode(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_codex_filename = 0;
  PyObject *__pyx_v_encode_labels = 0;
  bool __pyx_v_encode_reuse;
  PyObject *__pyx_v_encode_weights = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("encode (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_codex_filename,&__pyx_n_s_encode_labels,&__pyx_n_s_encode_reuse,&__pyx_n_s_encode_weights,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_False);

    /* "fst.pyx":888
 * 
 *   def encode(self, codex_filename, encode_labels=False,
 *              bool encode_reuse=False, encode_weights=False):             # <<<<<<<<<<<<<<
 *     """Encodes FST labels and/or weights.
 * 
 */
    values[3] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_codex_filename)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_encode_labels);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_encode_reuse);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_encode_weights);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "encode") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 887; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_codex_filename = values[0];
    __pyx_v_encode_labels = values[1];
    if (values[2]) {
      __pyx_v_encode_reuse = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_encode_reuse == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 888; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_encode_reuse = ((bool)0);
    }
    __pyx_v_encode_weights = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("encode", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 887; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._MutableFst.encode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_11_MutableFst_14encode(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), __pyx_v_codex_filename, __pyx_v_encode_labels, __pyx_v_encode_reuse, __pyx_v_encode_weights);

  /* "fst.pyx":887
 *     self._check_mutating_imethod()
 * 
 *   def encode(self, codex_filename, encode_labels=False,             # <<<<<<<<<<<<<<
 *              bool encode_reuse=False, encode_weights=False):
 *     """Encodes FST labels and/or weights.
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_14encode(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_codex_filename, PyObject *__pyx_v_encode_labels, bool __pyx_v_encode_reuse, PyObject *__pyx_v_encode_weights) {
  uint32 __pyx_v_flags;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  std::string __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("encode", 0);

  /* "fst.pyx":904
 *     See also: `decode`.
 *     """
 *     cdef uint32 flags = 0             # <<<<<<<<<<<<<<
 *     if encode_labels:
 *       flags |= kEncodeLabels
 */
  __pyx_v_flags = 0;

  /* "fst.pyx":905
 *     """
 *     cdef uint32 flags = 0
 *     if encode_labels:             # <<<<<<<<<<<<<<
 *       flags |= kEncodeLabels
 *     if encode_weights:
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_encode_labels); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 905; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_1) {

    /* "fst.pyx":906
 *     cdef uint32 flags = 0
 *     if encode_labels:
 *       flags |= kEncodeLabels             # <<<<<<<<<<<<<<
 *     if encode_weights:
 *       flags |= kEncodeWeights
 */
    __pyx_v_flags = (__pyx_v_flags | fst::kEncodeLabels);
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "fst.pyx":907
 *     if encode_labels:
 *       flags |= kEncodeLabels
 *     if encode_weights:             # <<<<<<<<<<<<<<
 *       flags |= kEncodeWeights
 *     Encode(self.mfst, flags, encode_reuse, tobytes(codex_filename))
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_encode_weights); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 907; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_1) {

    /* "fst.pyx":908
 *       flags |= kEncodeLabels
 *     if encode_weights:
 *       flags |= kEncodeWeights             # <<<<<<<<<<<<<<
 *     Encode(self.mfst, flags, encode_reuse, tobytes(codex_filename))
 *     self._check_mutating_imethod()
 */
    __pyx_v_flags = (__pyx_v_flags | fst::kEncodeWeights);
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "fst.pyx":909
 *     if encode_weights:
 *       flags |= kEncodeWeights
 *     Encode(self.mfst, flags, encode_reuse, tobytes(codex_filename))             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  __pyx_t_2 = __pyx_f_3fst_tobytes(__pyx_v_codex_filename); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 909; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __pyx_convert_string_from_py_(__pyx_t_2); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 909; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  fst::script::Encode(__pyx_v_self->mfst, __pyx_v_flags, __pyx_v_encode_reuse, __pyx_t_3);

  /* "fst.pyx":910
 *       flags |= kEncodeWeights
 *     Encode(self.mfst, flags, encode_reuse, tobytes(codex_filename))
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def invert(self):
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  if (__pyx_t_5) {
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  } else {
    __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_4); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "fst.pyx":887
 *     self._check_mutating_imethod()
 * 
 *   def encode(self, codex_filename, encode_labels=False,             # <<<<<<<<<<<<<<
 *              bool encode_reuse=False, encode_weights=False):
 *     """Encodes FST labels and/or weights.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("fst._MutableFst.encode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":912
 *     self._check_mutating_imethod()
 * 
 *   def invert(self):             # <<<<<<<<<<<<<<
 *     """Inverts the FST's transduction.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_17invert(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_16invert[] = "Inverts the FST's transduction.\n\n    This operation destructively inverts the FST's transduction by exchanging\n    input and output labels.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_17invert(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("invert (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_11_MutableFst_16invert(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_16invert(struct __pyx_obj_3fst__MutableFst *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("invert", 0);

  /* "fst.pyx":918
 *     input and output labels.
 *     """
 *     Invert(self.mfst)             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  fst::script::Invert(__pyx_v_self->mfst);

  /* "fst.pyx":919
 *     """
 *     Invert(self.mfst)
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def minimize(self, float delta=kDelta):
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 919; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 919; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 919; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":912
 *     self._check_mutating_imethod()
 * 
 *   def invert(self):             # <<<<<<<<<<<<<<
 *     """Inverts the FST's transduction.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("fst._MutableFst.invert", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":921
 *     self._check_mutating_imethod()
 * 
 *   def minimize(self, float delta=kDelta):             # <<<<<<<<<<<<<<
 *     """Minimizes the FST.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_19minimize(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_18minimize[] = "Minimizes the FST.\n\n    This operation destructively performs the minimization of deterministic\n    weighted automata and transducers. If the input FST A is an acceptor, this\n    operation produces the minimal acceptor B equivalent to A, i.e. the\n    acceptor with a minimal number of states that is equivalent to A. If the\n    input FST A is a transducer, this operation internally builds an equivalent\n    transducer with a minimal number of states. However, this minimality is\n    obtained by allowing transition having strings of symbols as output labels,\n    this known in the litterature as a real-time transducer. Such transducers\n    are not directly supported by the library. This function will convert such\n    transducer by expanding each string-labeled transition into a sequence of\n    transitions. This will results in the creation of new states, hence losing\n    the minimality property.\n\n    Args:\n      delta: Comparison/quantization delta.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_19minimize(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  float __pyx_v_delta;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("minimize (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_delta,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "minimize") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    if (values[0]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[0]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__4;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("minimize", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._MutableFst.minimize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_11_MutableFst_18minimize(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), __pyx_v_delta);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_18minimize(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, float __pyx_v_delta) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("minimize", 0);

  /* "fst.pyx":941
 *     """
 *     # This runs in-place when the second argument is null.
 *     Minimize(self.mfst, NULL, delta)             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  fst::script::Minimize(__pyx_v_self->mfst, NULL, __pyx_v_delta);

  /* "fst.pyx":942
 *     # This runs in-place when the second argument is null.
 *     Minimize(self.mfst, NULL, delta)
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def project(self, project_output=False):
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 942; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 942; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 942; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":921
 *     self._check_mutating_imethod()
 * 
 *   def minimize(self, float delta=kDelta):             # <<<<<<<<<<<<<<
 *     """Minimizes the FST.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("fst._MutableFst.minimize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":944
 *     self._check_mutating_imethod()
 * 
 *   def project(self, project_output=False):             # <<<<<<<<<<<<<<
 *     """Converts the FST to an acceptor using input or output labels.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_21project(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_20project[] = "Converts the FST to an acceptor using input or output labels.\n\n    This operation destructively projects an FST onto its domain or range by\n    either copying each arc's input label to its output label (the default) or\n    vice versa.\n\n    Args:\n      project_output: Should the output labels be projected?\n\n    See also: `decode`, `encode`, `relabel`.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_21project(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_project_output = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("project (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_project_output,0};
    PyObject* values[1] = {0};
    values[0] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_project_output);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "project") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 944; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_project_output = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("project", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 944; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._MutableFst.project", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_11_MutableFst_20project(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), __pyx_v_project_output);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_20project(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_project_output) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  enum fst::ProjectType __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("project", 0);

  /* "fst.pyx":956
 *     See also: `decode`, `encode`, `relabel`.
 *     """
 *     Project(self.mfst, PROJECT_OUTPUT if project_output else PROJECT_INPUT)             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_project_output); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 956; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {
    __pyx_t_1 = fst::PROJECT_OUTPUT;
  } else {
    __pyx_t_1 = fst::PROJECT_INPUT;
  }
  fst::script::Project(__pyx_v_self->mfst, __pyx_t_1);

  /* "fst.pyx":957
 *     """
 *     Project(self.mfst, PROJECT_OUTPUT if project_output else PROJECT_INPUT)
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def prune(self, float delta=kDelta, int64 nstate=kNoStateId, weight=b""):
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  if (__pyx_t_5) {
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  } else {
    __pyx_t_3 = __Pyx_PyObject_CallNoArg(__pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "fst.pyx":944
 *     self._check_mutating_imethod()
 * 
 *   def project(self, project_output=False):             # <<<<<<<<<<<<<<
 *     """Converts the FST to an acceptor using input or output labels.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("fst._MutableFst.project", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":959
 *     self._check_mutating_imethod()
 * 
 *   def prune(self, float delta=kDelta, int64 nstate=kNoStateId, weight=b""):             # <<<<<<<<<<<<<<
 *     """Removes paths with weights below a certain threshold.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_23prune(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_22prune[] = "Removes paths with weights below a certain threshold.\n\n    This operation deletes states and arcs in the input FST that do not belong\n    to a successful path whose weight is no more (w.r.t the natural semiring\n    order) than the threshold t \\otimes-times the weight of the shortest path in\n    the input FST. Weights must be commutative and have the path property.\n\n    Args:\n      delta: Comparison/quantization delta.\n      nstate: State number threshold.\n      weight: A string representing a desired weight threshold; paths with\n          weights below this threshold will be pruned.\n\n    See also: The constructive variant (`pywrapfst.prune`).\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_23prune(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  float __pyx_v_delta;
  int64 __pyx_v_nstate;
  PyObject *__pyx_v_weight = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("prune (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_delta,&__pyx_n_s_nstate,&__pyx_n_s_weight,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_kp_b__5);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nstate);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_weight);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "prune") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 959; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    if (values[0]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[0]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 959; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__6;
    }
    if (values[1]) {
      __pyx_v_nstate = __Pyx_PyInt_As_int64_t(values[1]); if (unlikely((__pyx_v_nstate == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 959; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_nstate = __pyx_k__7;
    }
    __pyx_v_weight = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("prune", 0, 0, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 959; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._MutableFst.prune", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_11_MutableFst_22prune(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), __pyx_v_delta, __pyx_v_nstate, __pyx_v_weight);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_22prune(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, float __pyx_v_delta, int64 __pyx_v_nstate, PyObject *__pyx_v_weight) {
  fst::script::WeightClass __pyx_v_wc;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("prune", 0);

  /* "fst.pyx":975
 *     See also: The constructive variant (`pywrapfst.prune`).
 *     """
 *     cdef WeightClass wc = _get_weight_class(self._weight_type, tobytes(weight))             # <<<<<<<<<<<<<<
 *     Prune(self.mfst, wc, nstate, delta)
 *     self._check_mutating_imethod()
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_weight_type_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_f_3fst_tobytes(__pyx_v_weight); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_wc = __pyx_f_3fst__get_weight_class(__pyx_t_1, __pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "fst.pyx":976
 *     """
 *     cdef WeightClass wc = _get_weight_class(self._weight_type, tobytes(weight))
 *     Prune(self.mfst, wc, nstate, delta)             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  fst::script::Prune(__pyx_v_self->mfst, __pyx_v_wc, __pyx_v_nstate, __pyx_v_delta);

  /* "fst.pyx":977
 *     cdef WeightClass wc = _get_weight_class(self._weight_type, tobytes(weight))
 *     Prune(self.mfst, wc, nstate, delta)
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def push(self, float delta=kDelta, remove_total_weight=False,
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 977; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 977; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 977; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "fst.pyx":959
 *     self._check_mutating_imethod()
 * 
 *   def prune(self, float delta=kDelta, int64 nstate=kNoStateId, weight=b""):             # <<<<<<<<<<<<<<
 *     """Removes paths with weights below a certain threshold.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("fst._MutableFst.prune", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":979
 *     self._check_mutating_imethod()
 * 
 *   def push(self, float delta=kDelta, remove_total_weight=False,             # <<<<<<<<<<<<<<
 *            to_final=False):
 *     """Pushes weights towards the initial or final states.
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_25push(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_24push[] = "Pushes weights towards the initial or final states.\n\n    This operation destructively produces an equivalent transducer by pushing\n    the weights towards the initial state or toward the final states. When\n    pushing weights towards the initial state, the sum of the weight of the\n    outgoing transitions and final weight at any non-initial state is equal to\n    1 in the resulting machine. When pushing weights towards the final states,\n    the sum of the weight of the incoming transitions at any state is equal to\n    1. Weights need to be left distributive when pushing towards the initial\n    state and right distributive when pushing towards the final states.\n\n    Args:\n      delta: Comparison/quantization delta.\n      remove_total_weight: If pushing weights, should total weight be removed?\n      to_final: Push towards final states?\n\n    See also: The constructive variant (`pywrapfst.push`), which also supports\n        label pushing.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_25push(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  float __pyx_v_delta;
  PyObject *__pyx_v_remove_total_weight = 0;
  PyObject *__pyx_v_to_final = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("push (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_delta,&__pyx_n_s_remove_total_weight,&__pyx_n_s_to_final,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_False);

    /* "fst.pyx":980
 * 
 *   def push(self, float delta=kDelta, remove_total_weight=False,
 *            to_final=False):             # <<<<<<<<<<<<<<
 *     """Pushes weights towards the initial or final states.
 * 
 */
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_remove_total_weight);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_to_final);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "push") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 979; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    if (values[0]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[0]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 979; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__8;
    }
    __pyx_v_remove_total_weight = values[1];
    __pyx_v_to_final = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("push", 0, 0, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 979; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._MutableFst.push", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_11_MutableFst_24push(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), __pyx_v_delta, __pyx_v_remove_total_weight, __pyx_v_to_final);

  /* "fst.pyx":979
 *     self._check_mutating_imethod()
 * 
 *   def push(self, float delta=kDelta, remove_total_weight=False,             # <<<<<<<<<<<<<<
 *            to_final=False):
 *     """Pushes weights towards the initial or final states.
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_24push(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, float __pyx_v_delta, PyObject *__pyx_v_remove_total_weight, PyObject *__pyx_v_to_final) {
  enum fst::ReweightType __pyx_v_rt;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  enum fst::ReweightType __pyx_t_1;
  int __pyx_t_2;
  bool __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("push", 0);

  /* "fst.pyx":1000
 *         label pushing.
 *     """
 *     cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else             # <<<<<<<<<<<<<<
 *                             REWEIGHT_TO_INITIAL)
 *     Push(self.mfst, rt, delta, remove_total_weight)
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_to_final); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1000; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {
    __pyx_t_1 = fst::REWEIGHT_TO_FINAL;
  } else {

    /* "fst.pyx":1001
 *     """
 *     cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else
 *                             REWEIGHT_TO_INITIAL)             # <<<<<<<<<<<<<<
 *     Push(self.mfst, rt, delta, remove_total_weight)
 *     self._check_mutating_imethod()
 */
    __pyx_t_1 = fst::REWEIGHT_TO_INITIAL;
  }
  __pyx_v_rt = __pyx_t_1;

  /* "fst.pyx":1002
 *     cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else
 *                             REWEIGHT_TO_INITIAL)
 *     Push(self.mfst, rt, delta, remove_total_weight)             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_remove_total_weight); if (unlikely((__pyx_t_3 == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1002; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  fst::script::Push(__pyx_v_self->mfst, __pyx_v_rt, __pyx_v_delta, __pyx_t_3);

  /* "fst.pyx":1003
 *                             REWEIGHT_TO_INITIAL)
 *     Push(self.mfst, rt, delta, remove_total_weight)
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def relabel(self, ipairs=None, opairs=None):
 */
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1003; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  if (__pyx_t_6) {
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1003; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  } else {
    __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1003; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "fst.pyx":979
 *     self._check_mutating_imethod()
 * 
 *   def push(self, float delta=kDelta, remove_total_weight=False,             # <<<<<<<<<<<<<<
 *            to_final=False):
 *     """Pushes weights towards the initial or final states.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("fst._MutableFst.push", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1005
 *     self._check_mutating_imethod()
 * 
 *   def relabel(self, ipairs=None, opairs=None):             # <<<<<<<<<<<<<<
 *     """Replaces input and/or output labels.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_27relabel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_26relabel[] = "Replaces input and/or output labels.\n\n    This operation destructively relabels the input and/or output labels of the\n    FST. The input and/or output relabeling are specified by pairs of the form\n    (old_ID, new_ID); omitted indices are identity-mapped.\n\n    Args:\n      ipairs: An iterable containing (older index, newer index) integer pairs.\n      opairs: An iterable containing (older index, newer index) integer pairs.\n\n    See also: `decode`, `encode`, `project`.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_27relabel(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_ipairs = 0;
  PyObject *__pyx_v_opairs = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("relabel (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ipairs,&__pyx_n_s_opairs,0};
    PyObject* values[2] = {0,0};
    values[0] = ((PyObject *)Py_None);
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ipairs);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_opairs);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "relabel") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1005; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ipairs = values[0];
    __pyx_v_opairs = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("relabel", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1005; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._MutableFst.relabel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_11_MutableFst_26relabel(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), __pyx_v_ipairs, __pyx_v_opairs);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_26relabel(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_ipairs, PyObject *__pyx_v_opairs) {
  std::vector<std::pair<int64,int64> >  __pyx_v__ipairs;
  std::vector<std::pair<int64,int64> >  __pyx_v__opairs;
  int64 __pyx_v_before;
  int64 __pyx_v_after;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *(*__pyx_t_4)(PyObject *);
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *(*__pyx_t_9)(PyObject *);
  int64 __pyx_t_10;
  int64 __pyx_t_11;
  std::pair<int64,int64>  __pyx_t_12;
  int __pyx_t_13;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("relabel", 0);

  /* "fst.pyx":1021
 *     # This asserts that all elements in `ipairs` and `opairs` are int/int pairs.
 *     cdef int64 before, after
 *     if ipairs:             # <<<<<<<<<<<<<<
 *       for (before, after) in ipairs:
 *         _ipairs.push_back(pair[int64, int64](before, after))
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_ipairs); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1021; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_1) {

    /* "fst.pyx":1022
 *     cdef int64 before, after
 *     if ipairs:
 *       for (before, after) in ipairs:             # <<<<<<<<<<<<<<
 *         _ipairs.push_back(pair[int64, int64](before, after))
 *     if opairs:
 */
    if (likely(PyList_CheckExact(__pyx_v_ipairs)) || PyTuple_CheckExact(__pyx_v_ipairs)) {
      __pyx_t_2 = __pyx_v_ipairs; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
      __pyx_t_4 = NULL;
    } else {
      __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_ipairs); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    for (;;) {
      if (likely(!__pyx_t_4)) {
        if (likely(PyList_CheckExact(__pyx_t_2))) {
          if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          #endif
        } else {
          if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          #endif
        }
      } else {
        __pyx_t_5 = __pyx_t_4(__pyx_t_2);
        if (unlikely(!__pyx_t_5)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_5);
      }
      if ((likely(PyTuple_CheckExact(__pyx_t_5))) || (PyList_CheckExact(__pyx_t_5))) {
        PyObject* sequence = __pyx_t_5;
        #if CYTHON_COMPILING_IN_CPYTHON
        Py_ssize_t size = Py_SIZE(sequence);
        #else
        Py_ssize_t size = PySequence_Size(sequence);
        #endif
        if (unlikely(size != 2)) {
          if (size > 2) __Pyx_RaiseTooManyValuesError(2);
          else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        }
        #if CYTHON_COMPILING_IN_CPYTHON
        if (likely(PyTuple_CheckExact(sequence))) {
          __pyx_t_6 = PyTuple_GET_ITEM(sequence, 0); 
          __pyx_t_7 = PyTuple_GET_ITEM(sequence, 1); 
        } else {
          __pyx_t_6 = PyList_GET_ITEM(sequence, 0); 
          __pyx_t_7 = PyList_GET_ITEM(sequence, 1); 
        }
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_7);
        #else
        __pyx_t_6 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_7);
        #endif
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else {
        Py_ssize_t index = -1;
        __pyx_t_8 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_9 = Py_TYPE(__pyx_t_8)->tp_iternext;
        index = 0; __pyx_t_6 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_6)) goto __pyx_L6_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_6);
        index = 1; __pyx_t_7 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_7)) goto __pyx_L6_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_7);
        if (__Pyx_IternextUnpackEndCheck(__pyx_t_9(__pyx_t_8), 2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __pyx_t_9 = NULL;
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        goto __pyx_L7_unpacking_done;
        __pyx_L6_unpacking_failed:;
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        __pyx_t_9 = NULL;
        if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __pyx_L7_unpacking_done:;
      }
      __pyx_t_10 = __Pyx_PyInt_As_int64_t(__pyx_t_6); if (unlikely((__pyx_t_10 == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_11 = __Pyx_PyInt_As_int64_t(__pyx_t_7); if (unlikely((__pyx_t_11 == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_v_before = __pyx_t_10;
      __pyx_v_after = __pyx_t_11;

      /* "fst.pyx":1023
 *     if ipairs:
 *       for (before, after) in ipairs:
 *         _ipairs.push_back(pair[int64, int64](before, after))             # <<<<<<<<<<<<<<
 *     if opairs:
 *       for (before, after) in opairs:
 */
      try {
        __pyx_t_12 = std::pair<int64,int64> (__pyx_v_before, __pyx_v_after);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1023; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      }
      __pyx_v__ipairs.push_back(__pyx_t_12);

      /* "fst.pyx":1022
 *     cdef int64 before, after
 *     if ipairs:
 *       for (before, after) in ipairs:             # <<<<<<<<<<<<<<
 *         _ipairs.push_back(pair[int64, int64](before, after))
 *     if opairs:
 */
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "fst.pyx":1024
 *       for (before, after) in ipairs:
 *         _ipairs.push_back(pair[int64, int64](before, after))
 *     if opairs:             # <<<<<<<<<<<<<<
 *       for (before, after) in opairs:
 *         _opairs.push_back(pair[int64, int64](before, after))
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_opairs); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1024; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_1) {

    /* "fst.pyx":1025
 *         _ipairs.push_back(pair[int64, int64](before, after))
 *     if opairs:
 *       for (before, after) in opairs:             # <<<<<<<<<<<<<<
 *         _opairs.push_back(pair[int64, int64](before, after))
 *     if _ipairs.empty() and _opairs.empty():
 */
    if (likely(PyList_CheckExact(__pyx_v_opairs)) || PyTuple_CheckExact(__pyx_v_opairs)) {
      __pyx_t_2 = __pyx_v_opairs; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
      __pyx_t_4 = NULL;
    } else {
      __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_opairs); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    for (;;) {
      if (likely(!__pyx_t_4)) {
        if (likely(PyList_CheckExact(__pyx_t_2))) {
          if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          #endif
        } else {
          if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          #endif
        }
      } else {
        __pyx_t_5 = __pyx_t_4(__pyx_t_2);
        if (unlikely(!__pyx_t_5)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_5);
      }
      if ((likely(PyTuple_CheckExact(__pyx_t_5))) || (PyList_CheckExact(__pyx_t_5))) {
        PyObject* sequence = __pyx_t_5;
        #if CYTHON_COMPILING_IN_CPYTHON
        Py_ssize_t size = Py_SIZE(sequence);
        #else
        Py_ssize_t size = PySequence_Size(sequence);
        #endif
        if (unlikely(size != 2)) {
          if (size > 2) __Pyx_RaiseTooManyValuesError(2);
          else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        }
        #if CYTHON_COMPILING_IN_CPYTHON
        if (likely(PyTuple_CheckExact(sequence))) {
          __pyx_t_7 = PyTuple_GET_ITEM(sequence, 0); 
          __pyx_t_6 = PyTuple_GET_ITEM(sequence, 1); 
        } else {
          __pyx_t_7 = PyList_GET_ITEM(sequence, 0); 
          __pyx_t_6 = PyList_GET_ITEM(sequence, 1); 
        }
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_6);
        #else
        __pyx_t_7 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_7);
        __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_6);
        #endif
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else {
        Py_ssize_t index = -1;
        __pyx_t_8 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_9 = Py_TYPE(__pyx_t_8)->tp_iternext;
        index = 0; __pyx_t_7 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_7)) goto __pyx_L11_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_7);
        index = 1; __pyx_t_6 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_6)) goto __pyx_L11_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_6);
        if (__Pyx_IternextUnpackEndCheck(__pyx_t_9(__pyx_t_8), 2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __pyx_t_9 = NULL;
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        goto __pyx_L12_unpacking_done;
        __pyx_L11_unpacking_failed:;
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        __pyx_t_9 = NULL;
        if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __pyx_L12_unpacking_done:;
      }
      __pyx_t_11 = __Pyx_PyInt_As_int64_t(__pyx_t_7); if (unlikely((__pyx_t_11 == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_10 = __Pyx_PyInt_As_int64_t(__pyx_t_6); if (unlikely((__pyx_t_10 == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_v_before = __pyx_t_11;
      __pyx_v_after = __pyx_t_10;

      /* "fst.pyx":1026
 *     if opairs:
 *       for (before, after) in opairs:
 *         _opairs.push_back(pair[int64, int64](before, after))             # <<<<<<<<<<<<<<
 *     if _ipairs.empty() and _opairs.empty():
 *       raise FstError("No relabeling pairs specified")
 */
      try {
        __pyx_t_12 = std::pair<int64,int64> (__pyx_v_before, __pyx_v_after);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1026; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      }
      __pyx_v__opairs.push_back(__pyx_t_12);

      /* "fst.pyx":1025
 *         _ipairs.push_back(pair[int64, int64](before, after))
 *     if opairs:
 *       for (before, after) in opairs:             # <<<<<<<<<<<<<<
 *         _opairs.push_back(pair[int64, int64](before, after))
 *     if _ipairs.empty() and _opairs.empty():
 */
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L8;
  }
  __pyx_L8:;

  /* "fst.pyx":1027
 *       for (before, after) in opairs:
 *         _opairs.push_back(pair[int64, int64](before, after))
 *     if _ipairs.empty() and _opairs.empty():             # <<<<<<<<<<<<<<
 *       raise FstError("No relabeling pairs specified")
 *     Relabel(self.mfst, _ipairs, _opairs)
 */
  __pyx_t_13 = (__pyx_v__ipairs.empty() != 0);
  if (__pyx_t_13) {
    goto __pyx_L15_next_and;
  } else {
    __pyx_t_1 = __pyx_t_13;
    goto __pyx_L14_bool_binop_done;
  }
  __pyx_L15_next_and:;
  __pyx_t_13 = (__pyx_v__opairs.empty() != 0);
  __pyx_t_1 = __pyx_t_13;
  __pyx_L14_bool_binop_done:;
  if (__pyx_t_1) {

    /* "fst.pyx":1028
 *         _opairs.push_back(pair[int64, int64](before, after))
 *     if _ipairs.empty() and _opairs.empty():
 *       raise FstError("No relabeling pairs specified")             # <<<<<<<<<<<<<<
 *     Relabel(self.mfst, _ipairs, _opairs)
 *     self._check_mutating_imethod()
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1028; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1028; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1028; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "fst.pyx":1029
 *     if _ipairs.empty() and _opairs.empty():
 *       raise FstError("No relabeling pairs specified")
 *     Relabel(self.mfst, _ipairs, _opairs)             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  fst::script::Relabel(__pyx_v_self->mfst, __pyx_v__ipairs, __pyx_v__opairs);

  /* "fst.pyx":1030
 *       raise FstError("No relabeling pairs specified")
 *     Relabel(self.mfst, _ipairs, _opairs)
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def reweight(self, potentials, bool to_final=False):
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_6 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_6) {
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_6); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  } else {
    __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "fst.pyx":1005
 *     self._check_mutating_imethod()
 * 
 *   def relabel(self, ipairs=None, opairs=None):             # <<<<<<<<<<<<<<
 *     """Replaces input and/or output labels.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("fst._MutableFst.relabel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1032
 *     self._check_mutating_imethod()
 * 
 *   def reweight(self, potentials, bool to_final=False):             # <<<<<<<<<<<<<<
 *     """Reweights an FST using a list of potentials.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_29reweight(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_28reweight[] = "Reweights an FST using a list of potentials.\n\n    This operation destructively reweights an FST according to the potentials\n    and in the direction specified by the user. An arc of weight w, with an\n    origin state of potential p and destination state of potential q, is\n    reweighted by p^{-1} \\otimes (w \\otimes q) when reweighting towards the\n    initial state, and by (p \\otimes w) \\otimes q^{-1} when reweighting towards\n    the final states. The weights must be left distributive when reweighting\n    towards the initial state and right distributive when reweighting towards\n    the final states (e.g., TropicalWeight and LogWeight).\n\n    Args:\n      potentials: An iterable of Weight instances.\n      to_final: Push towards final states?\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_29reweight(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_potentials = 0;
  bool __pyx_v_to_final;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("reweight (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_potentials,&__pyx_n_s_to_final,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_potentials)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_to_final);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "reweight") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1032; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_potentials = values[0];
    if (values[1]) {
      __pyx_v_to_final = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_to_final == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1032; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_to_final = ((bool)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("reweight", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1032; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._MutableFst.reweight", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_11_MutableFst_28reweight(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), __pyx_v_potentials, __pyx_v_to_final);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_28reweight(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, PyObject *__pyx_v_potentials, bool __pyx_v_to_final) {
  std::vector<fst::script::WeightClass>  __pyx_v__potentials;
  std::string __pyx_v_weight_type;
  struct __pyx_obj_3fst_Weight *__pyx_v_weight = 0;
  enum fst::ReweightType __pyx_v_rt;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  Py_ssize_t __pyx_t_3;
  PyObject *(*__pyx_t_4)(PyObject *);
  PyObject *__pyx_t_5 = NULL;
  enum fst::ReweightType __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("reweight", 0);

  /* "fst.pyx":1049
 *     """
 *     cdef vector[WeightClass] _potentials
 *     cdef string weight_type = self._weight_type             # <<<<<<<<<<<<<<
 *     # This asserts that all elements in `potentials` are Weight instances.
 *     cdef Weight weight
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_weight_type_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1049; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1049; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_weight_type = __pyx_t_2;

  /* "fst.pyx":1052
 *     # This asserts that all elements in `potentials` are Weight instances.
 *     cdef Weight weight
 *     for weight in potentials:             # <<<<<<<<<<<<<<
 *         _potentials.push_back(WeightClass(weight_type, weight.string))
 *     cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else
 */
  if (likely(PyList_CheckExact(__pyx_v_potentials)) || PyTuple_CheckExact(__pyx_v_potentials)) {
    __pyx_t_1 = __pyx_v_potentials; __Pyx_INCREF(__pyx_t_1); __pyx_t_3 = 0;
    __pyx_t_4 = NULL;
  } else {
    __pyx_t_3 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_potentials); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1052; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1052; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  for (;;) {
    if (likely(!__pyx_t_4)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1052; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        #else
        __pyx_t_5 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1052; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        #endif
      } else {
        if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1052; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        #else
        __pyx_t_5 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1052; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        #endif
      }
    } else {
      __pyx_t_5 = __pyx_t_4(__pyx_t_1);
      if (unlikely(!__pyx_t_5)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1052; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_5);
    }
    if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_3fst_Weight))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1052; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_XDECREF_SET(__pyx_v_weight, ((struct __pyx_obj_3fst_Weight *)__pyx_t_5));
    __pyx_t_5 = 0;

    /* "fst.pyx":1053
 *     cdef Weight weight
 *     for weight in potentials:
 *         _potentials.push_back(WeightClass(weight_type, weight.string))             # <<<<<<<<<<<<<<
 *     cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else
 *                             REWEIGHT_TO_INITIAL)
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_weight), __pyx_n_s_string); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1053; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_5); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1053; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_v__potentials.push_back(fst::script::WeightClass(__pyx_v_weight_type, __pyx_t_2));

    /* "fst.pyx":1052
 *     # This asserts that all elements in `potentials` are Weight instances.
 *     cdef Weight weight
 *     for weight in potentials:             # <<<<<<<<<<<<<<
 *         _potentials.push_back(WeightClass(weight_type, weight.string))
 *     cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1054
 *     for weight in potentials:
 *         _potentials.push_back(WeightClass(weight_type, weight.string))
 *     cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else             # <<<<<<<<<<<<<<
 *                             REWEIGHT_TO_INITIAL)
 *     Reweight(self.mfst, _potentials, rt)
 */
  if ((__pyx_v_to_final != 0)) {
    __pyx_t_6 = fst::REWEIGHT_TO_FINAL;
  } else {

    /* "fst.pyx":1055
 *         _potentials.push_back(WeightClass(weight_type, weight.string))
 *     cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else
 *                             REWEIGHT_TO_INITIAL)             # <<<<<<<<<<<<<<
 *     Reweight(self.mfst, _potentials, rt)
 *     self._check_mutating_imethod()
 */
    __pyx_t_6 = fst::REWEIGHT_TO_INITIAL;
  }
  __pyx_v_rt = __pyx_t_6;

  /* "fst.pyx":1056
 *     cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else
 *                             REWEIGHT_TO_INITIAL)
 *     Reweight(self.mfst, _potentials, rt)             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  fst::script::Reweight(__pyx_v_self->mfst, __pyx_v__potentials, __pyx_v_rt);

  /* "fst.pyx":1057
 *                             REWEIGHT_TO_INITIAL)
 *     Reweight(self.mfst, _potentials, rt)
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def rmepsilon(self, bool connect=True, float delta=kDelta,
 */
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1057; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_7 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_7)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  if (__pyx_t_7) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_7); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1057; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1057; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1032
 *     self._check_mutating_imethod()
 * 
 *   def reweight(self, potentials, bool to_final=False):             # <<<<<<<<<<<<<<
 *     """Reweights an FST using a list of potentials.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("fst._MutableFst.reweight", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_weight);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1059
 *     self._check_mutating_imethod()
 * 
 *   def rmepsilon(self, bool connect=True, float delta=kDelta,             # <<<<<<<<<<<<<<
 *                 int64 nstate=kNoStateId, weight=b""):
 *     """Removes epsilon transitions.
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_31rmepsilon(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_30rmepsilon[] = "Removes epsilon transitions.\n\n    This operation destructively removes epsilon transitions, i.e., those where\n    both input and output labels are epsilon) from an FST.\n\n    Args:\n      connect: Should output be trimmed?\n      delta: Comparison/quantization delta.\n      nstate: State number threshold.\n      weight: A string representing a desired weight threshold; paths with\n          weights below this threshold will be pruned.\n\n    See also: The constructive variant (`pywrapfst.rmepsilon`), which also\n        supports epsilon removal in reverse (which may be more efficient).\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_31rmepsilon(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  bool __pyx_v_connect;
  float __pyx_v_delta;
  int64 __pyx_v_nstate;
  PyObject *__pyx_v_weight = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rmepsilon (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_connect,&__pyx_n_s_delta,&__pyx_n_s_nstate,&__pyx_n_s_weight,0};
    PyObject* values[4] = {0,0,0,0};
    values[3] = ((PyObject *)__pyx_kp_b__5);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_connect);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nstate);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_weight);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "rmepsilon") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1059; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    if (values[0]) {
      __pyx_v_connect = __Pyx_PyObject_IsTrue(values[0]); if (unlikely((__pyx_v_connect == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1059; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_connect = ((bool)1);
    }
    if (values[1]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[1]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1059; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__10;
    }
    if (values[2]) {
      __pyx_v_nstate = __Pyx_PyInt_As_int64_t(values[2]); if (unlikely((__pyx_v_nstate == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1060; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_nstate = __pyx_k__11;
    }
    __pyx_v_weight = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("rmepsilon", 0, 0, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1059; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst._MutableFst.rmepsilon", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_11_MutableFst_30rmepsilon(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), __pyx_v_connect, __pyx_v_delta, __pyx_v_nstate, __pyx_v_weight);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_30rmepsilon(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, bool __pyx_v_connect, float __pyx_v_delta, int64 __pyx_v_nstate, PyObject *__pyx_v_weight) {
  fst::script::WeightClass __pyx_v_wc;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("rmepsilon", 0);

  /* "fst.pyx":1076
 *         supports epsilon removal in reverse (which may be more efficient).
 *     """
 *     cdef WeightClass wc = _get_weight_class(self._weight_type, tobytes(weight))             # <<<<<<<<<<<<<<
 *     RmEpsilon(self.mfst, connect, wc, nstate, delta)
 *     self._check_mutating_imethod()
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_weight_type_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1076; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_f_3fst_tobytes(__pyx_v_weight); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1076; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_wc = __pyx_f_3fst__get_weight_class(__pyx_t_1, __pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "fst.pyx":1077
 *     """
 *     cdef WeightClass wc = _get_weight_class(self._weight_type, tobytes(weight))
 *     RmEpsilon(self.mfst, connect, wc, nstate, delta)             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  fst::script::RmEpsilon(__pyx_v_self->mfst, __pyx_v_connect, __pyx_v_wc, __pyx_v_nstate, __pyx_v_delta);

  /* "fst.pyx":1078
 *     cdef WeightClass wc = _get_weight_class(self._weight_type, tobytes(weight))
 *     RmEpsilon(self.mfst, connect, wc, nstate, delta)
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def topsort(self):
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1078; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1078; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1078; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "fst.pyx":1059
 *     self._check_mutating_imethod()
 * 
 *   def rmepsilon(self, bool connect=True, float delta=kDelta,             # <<<<<<<<<<<<<<
 *                 int64 nstate=kNoStateId, weight=b""):
 *     """Removes epsilon transitions.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("fst._MutableFst.rmepsilon", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1080
 *     self._check_mutating_imethod()
 * 
 *   def topsort(self):             # <<<<<<<<<<<<<<
 *     """Sorts transitions by state IDs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_33topsort(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_32topsort[] = "Sorts transitions by state IDs.\n\n    This operation destructively topologically sorts the FST, if it is acyclic;\n    otherwise it remains unchanged. Once sorted, all transitions are from lower\n    state IDs to higher state IDs\n\n    See also: `arcsort`.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_33topsort(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("topsort (wrapper)", 0);
  __pyx_r = __pyx_pf_3fst_11_MutableFst_32topsort(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_32topsort(struct __pyx_obj_3fst__MutableFst *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("topsort", 0);

  /* "fst.pyx":1090
 *     """
 *     # TopSort returns False if the FST is cyclic, and thus can't be TopSorted.
 *     if not TopSort(self.mfst):             # <<<<<<<<<<<<<<
 *       FstWarning("Input FST is cyclic.")
 *     self._check_mutating_imethod()
 */
  __pyx_t_1 = ((!(fst::script::TopSort(__pyx_v_self->mfst) != 0)) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":1091
 *     # TopSort returns False if the FST is cyclic, and thus can't be TopSorted.
 *     if not TopSort(self.mfst):
 *       FstWarning("Input FST is cyclic.")             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstWarning); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "fst.pyx":1092
 *     if not TopSort(self.mfst):
 *       FstWarning("Input FST is cyclic.")
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 *   def union(self, _Fst ifst):
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1092; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_4) {
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1092; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else {
    __pyx_t_3 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1092; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "fst.pyx":1080
 *     self._check_mutating_imethod()
 * 
 *   def topsort(self):             # <<<<<<<<<<<<<<
 *     """Sorts transitions by state IDs.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("fst._MutableFst.topsort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1094
 *     self._check_mutating_imethod()
 * 
 *   def union(self, _Fst ifst):             # <<<<<<<<<<<<<<
 *     """Computes the union (sum) of two FSTs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11_MutableFst_35union(PyObject *__pyx_v_self, PyObject *__pyx_v_ifst); /*proto*/
static char __pyx_doc_3fst_11_MutableFst_34union[] = "Computes the union (sum) of two FSTs.\n\n    This operation computes the union (sum) of two FSTs. If A transduces string\n    x to y with weight a and B transduces string w to v with weight b, then\n    their union transduces x to y with weight a and w to v with weight b.\n\n    Args:\n      ifst: The second input Fst.\n    ";
static PyObject *__pyx_pw_3fst_11_MutableFst_35union(PyObject *__pyx_v_self, PyObject *__pyx_v_ifst) {
  CYTHON_UNUSED int __pyx_lineno = 0;
  CYTHON_UNUSED const char *__pyx_filename = NULL;
  CYTHON_UNUSED int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("union (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1094; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_11_MutableFst_34union(((struct __pyx_obj_3fst__MutableFst *)__pyx_v_self), ((struct __pyx_obj_3fst__Fst *)__pyx_v_ifst));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_11_MutableFst_34union(struct __pyx_obj_3fst__MutableFst *__pyx_v_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("union", 0);

  /* "fst.pyx":1104
 *       ifst: The second input Fst.
 *     """
 *     Union(self.mfst, deref(ifst.fst))             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  fst::script::Union(__pyx_v_self->mfst, (*__pyx_v_ifst->fst));

  /* "fst.pyx":1105
 *     """
 *     Union(self.mfst, deref(ifst.fst))
 *     self._check_mutating_imethod()             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_mutating_imethod); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1094
 *     self._check_mutating_imethod()
 * 
 *   def union(self, _Fst ifst):             # <<<<<<<<<<<<<<
 *     """Computes the union (sum) of two FSTs.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("fst._MutableFst.union", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1118
 * 
 * 
 * cdef _init_Fst(FstClass *tfst):             # <<<<<<<<<<<<<<
 *   if tfst.Properties(kError, True):
 *     raise FstError("Operation failed")
 */

static PyObject *__pyx_f_3fst__init_Fst(fst::script::FstClass *__pyx_v_tfst) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ofst = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_init_Fst", 0);

  /* "fst.pyx":1119
 * 
 * cdef _init_Fst(FstClass *tfst):
 *   if tfst.Properties(kError, True):             # <<<<<<<<<<<<<<
 *     raise FstError("Operation failed")
 *   cdef _Fst ofst = _Fst.__new__(_Fst)
 */
  __pyx_t_1 = (__pyx_v_tfst->Properties(fst::kError, 1) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":1120
 * cdef _init_Fst(FstClass *tfst):
 *   if tfst.Properties(kError, True):
 *     raise FstError("Operation failed")             # <<<<<<<<<<<<<<
 *   cdef _Fst ofst = _Fst.__new__(_Fst)
 *   ofst.fst = tfst
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "fst.pyx":1121
 *   if tfst.Properties(kError, True):
 *     raise FstError("Operation failed")
 *   cdef _Fst ofst = _Fst.__new__(_Fst)             # <<<<<<<<<<<<<<
 *   ofst.fst = tfst
 *   return ofst
 */
  __pyx_t_3 = __pyx_tp_new_3fst__Fst(((PyTypeObject *)((PyObject*)__pyx_ptype_3fst__Fst)), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (!(likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_3fst__Fst)))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_ofst = ((struct __pyx_obj_3fst__Fst *)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "fst.pyx":1122
 *     raise FstError("Operation failed")
 *   cdef _Fst ofst = _Fst.__new__(_Fst)
 *   ofst.fst = tfst             # <<<<<<<<<<<<<<
 *   return ofst
 * 
 */
  __pyx_v_ofst->fst = __pyx_v_tfst;

  /* "fst.pyx":1123
 *   cdef _Fst ofst = _Fst.__new__(_Fst)
 *   ofst.fst = tfst
 *   return ofst             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_ofst));
  __pyx_r = ((PyObject *)__pyx_v_ofst);
  goto __pyx_L0;

  /* "fst.pyx":1118
 * 
 * 
 * cdef _init_Fst(FstClass *tfst):             # <<<<<<<<<<<<<<
 *   if tfst.Properties(kError, True):
 *     raise FstError("Operation failed")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("fst._init_Fst", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_ofst);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1126
 * 
 * 
 * cdef _init_MutableFst(MutableFstClass *tfst):             # <<<<<<<<<<<<<<
 *   if tfst.Properties(kError, True):
 *     raise FstError("Operation failed")
 */

static PyObject *__pyx_f_3fst__init_MutableFst(fst::script::MutableFstClass *__pyx_v_tfst) {
  struct __pyx_obj_3fst__MutableFst *__pyx_v_ofst = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_init_MutableFst", 0);

  /* "fst.pyx":1127
 * 
 * cdef _init_MutableFst(MutableFstClass *tfst):
 *   if tfst.Properties(kError, True):             # <<<<<<<<<<<<<<
 *     raise FstError("Operation failed")
 *   cdef _MutableFst ofst = _MutableFst.__new__(_MutableFst)
 */
  __pyx_t_1 = (__pyx_v_tfst->Properties(fst::kError, 1) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":1128
 * cdef _init_MutableFst(MutableFstClass *tfst):
 *   if tfst.Properties(kError, True):
 *     raise FstError("Operation failed")             # <<<<<<<<<<<<<<
 *   cdef _MutableFst ofst = _MutableFst.__new__(_MutableFst)
 *   ofst.mfst = ofst.fst = tfst
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "fst.pyx":1129
 *   if tfst.Properties(kError, True):
 *     raise FstError("Operation failed")
 *   cdef _MutableFst ofst = _MutableFst.__new__(_MutableFst)             # <<<<<<<<<<<<<<
 *   ofst.mfst = ofst.fst = tfst
 *   return ofst
 */
  __pyx_t_3 = __pyx_tp_new_3fst__MutableFst(((PyTypeObject *)((PyObject*)__pyx_ptype_3fst__MutableFst)), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (!(likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_3fst__MutableFst)))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_ofst = ((struct __pyx_obj_3fst__MutableFst *)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "fst.pyx":1130
 *     raise FstError("Operation failed")
 *   cdef _MutableFst ofst = _MutableFst.__new__(_MutableFst)
 *   ofst.mfst = ofst.fst = tfst             # <<<<<<<<<<<<<<
 *   return ofst
 * 
 */
  __pyx_v_ofst->mfst = __pyx_v_tfst;
  __pyx_v_ofst->__pyx_base.fst = __pyx_v_tfst;

  /* "fst.pyx":1131
 *   cdef _MutableFst ofst = _MutableFst.__new__(_MutableFst)
 *   ofst.mfst = ofst.fst = tfst
 *   return ofst             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_ofst));
  __pyx_r = ((PyObject *)__pyx_v_ofst);
  goto __pyx_L0;

  /* "fst.pyx":1126
 * 
 * 
 * cdef _init_MutableFst(MutableFstClass *tfst):             # <<<<<<<<<<<<<<
 *   if tfst.Properties(kError, True):
 *     raise FstError("Operation failed")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("fst._init_MutableFst", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_ofst);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1134
 * 
 * 
 * cdef _init_XFst(FstClass *tfst):             # <<<<<<<<<<<<<<
 *   if tfst.Properties(kMutable, True):
 *     return _init_MutableFst(<MutableFstClass *> tfst)
 */

static PyObject *__pyx_f_3fst__init_XFst(fst::script::FstClass *__pyx_v_tfst) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_init_XFst", 0);

  /* "fst.pyx":1135
 * 
 * cdef _init_XFst(FstClass *tfst):
 *   if tfst.Properties(kMutable, True):             # <<<<<<<<<<<<<<
 *     return _init_MutableFst(<MutableFstClass *> tfst)
 *   else:
 */
  __pyx_t_1 = (__pyx_v_tfst->Properties(fst::kMutable, 1) != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":1136
 * cdef _init_XFst(FstClass *tfst):
 *   if tfst.Properties(kMutable, True):
 *     return _init_MutableFst(<MutableFstClass *> tfst)             # <<<<<<<<<<<<<<
 *   else:
 *     return _init_Fst(tfst)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __pyx_f_3fst__init_MutableFst(((fst::script::MutableFstClass *)__pyx_v_tfst)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "fst.pyx":1138
 *     return _init_MutableFst(<MutableFstClass *> tfst)
 *   else:
 *     return _init_Fst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __pyx_f_3fst__init_Fst(__pyx_v_tfst); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1138; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
  }

  /* "fst.pyx":1134
 * 
 * 
 * cdef _init_XFst(FstClass *tfst):             # <<<<<<<<<<<<<<
 *   if tfst.Properties(kMutable, True):
 *     return _init_MutableFst(<MutableFstClass *> tfst)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("fst._init_XFst", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1141
 * 
 * 
 * def Fst(filename, fst_type=b""):             # <<<<<<<<<<<<<<
 *   """Constructs an FST from a file.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_9Fst(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_8Fst[] = "Constructs an FST from a file.\n\n  Args:\n    filename: The string location of the output file.\n    fst_type: A string representing the FST type the FST to convert to; no\n        conversion is performed if it is left blank or the FST is already of\n        of the desired type.\n\n  Returns:\n    An FST object.\n  ";
static PyMethodDef __pyx_mdef_3fst_9Fst = {"Fst", (PyCFunction)__pyx_pw_3fst_9Fst, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_8Fst};
static PyObject *__pyx_pw_3fst_9Fst(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_filename = 0;
  PyObject *__pyx_v_fst_type = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Fst (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_filename,&__pyx_n_s_fst_type_2,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_kp_b__5);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_filename)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_fst_type_2);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "Fst") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1141; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_filename = values[0];
    __pyx_v_fst_type = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("Fst", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1141; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.Fst", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_8Fst(__pyx_self, __pyx_v_filename, __pyx_v_fst_type);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_8Fst(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_filename, PyObject *__pyx_v_fst_type) {
  fst::script::FstClass *__pyx_v_tfst;
  std::string __pyx_v__fst_type;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("Fst", 0);

  /* "fst.pyx":1153
 *     An FST object.
 *   """
 *   cdef FstClass *tfst = Read(tobytes(filename))             # <<<<<<<<<<<<<<
 *   if tfst == NULL:
 *    raise FstError("Read failed")
 */
  __pyx_t_1 = __pyx_f_3fst_tobytes(__pyx_v_filename); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = fst::script::FstClass::Read(__pyx_t_2);

  /* "fst.pyx":1154
 *   """
 *   cdef FstClass *tfst = Read(tobytes(filename))
 *   if tfst == NULL:             # <<<<<<<<<<<<<<
 *    raise FstError("Read failed")
 *   # Convert if requested.
 */
  __pyx_t_3 = ((__pyx_v_tfst == NULL) != 0);
  if (__pyx_t_3) {

    /* "fst.pyx":1155
 *   cdef FstClass *tfst = Read(tobytes(filename))
 *   if tfst == NULL:
 *    raise FstError("Read failed")             # <<<<<<<<<<<<<<
 *   # Convert if requested.
 *   cdef string _fst_type = tobytes(fst_type)
 */
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "fst.pyx":1157
 *    raise FstError("Read failed")
 *   # Convert if requested.
 *   cdef string _fst_type = tobytes(fst_type)             # <<<<<<<<<<<<<<
 *   if _fst_type.size() and _fst_type != tfst.FstType():
 *     tfst = Convert(deref(tfst), _fst_type)
 */
  __pyx_t_4 = __pyx_f_3fst_tobytes(__pyx_v_fst_type); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_4); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_v__fst_type = __pyx_t_2;

  /* "fst.pyx":1158
 *   # Convert if requested.
 *   cdef string _fst_type = tobytes(fst_type)
 *   if _fst_type.size() and _fst_type != tfst.FstType():             # <<<<<<<<<<<<<<
 *     tfst = Convert(deref(tfst), _fst_type)
 *     # SCript-land Convert returns the null pointer to signal failure.
 */
  __pyx_t_5 = (__pyx_v__fst_type.size() != 0);
  if (__pyx_t_5) {
    goto __pyx_L6_next_and;
  } else {
    __pyx_t_3 = __pyx_t_5;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_L6_next_and:;
  __pyx_t_5 = ((__pyx_v__fst_type != __pyx_v_tfst->FstType()) != 0);
  __pyx_t_3 = __pyx_t_5;
  __pyx_L5_bool_binop_done:;
  if (__pyx_t_3) {

    /* "fst.pyx":1159
 *   cdef string _fst_type = tobytes(fst_type)
 *   if _fst_type.size() and _fst_type != tfst.FstType():
 *     tfst = Convert(deref(tfst), _fst_type)             # <<<<<<<<<<<<<<
 *     # SCript-land Convert returns the null pointer to signal failure.
 *     if tfst == NULL:
 */
    __pyx_v_tfst = fst::script::Convert((*__pyx_v_tfst), __pyx_v__fst_type);

    /* "fst.pyx":1161
 *     tfst = Convert(deref(tfst), _fst_type)
 *     # SCript-land Convert returns the null pointer to signal failure.
 *     if tfst == NULL:             # <<<<<<<<<<<<<<
 *       raise FstError("Read-time conversion to {!r} failed.".format(fst_type))
 *   return _init_XFst(tfst)
 */
    __pyx_t_3 = ((__pyx_v_tfst == NULL) != 0);
    if (__pyx_t_3) {

      /* "fst.pyx":1162
 *     # SCript-land Convert returns the null pointer to signal failure.
 *     if tfst == NULL:
 *       raise FstError("Read-time conversion to {!r} failed.".format(fst_type))             # <<<<<<<<<<<<<<
 *   return _init_XFst(tfst)
 * 
 */
      __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Read_time_conversion_to_r_failed, __pyx_n_s_format); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_8 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_7))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_7, function);
        }
      }
      if (!__pyx_t_8) {
        __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_v_fst_type); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_6);
      } else {
        __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_9);
        PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_8); __Pyx_GIVEREF(__pyx_t_8); __pyx_t_8 = NULL;
        __Pyx_INCREF(__pyx_v_fst_type);
        PyTuple_SET_ITEM(__pyx_t_9, 0+1, __pyx_v_fst_type);
        __Pyx_GIVEREF(__pyx_v_fst_type);
        __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_9, NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      }
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_7 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_1))) {
        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_1);
        if (likely(__pyx_t_7)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
          __Pyx_INCREF(__pyx_t_7);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_1, function);
        }
      }
      if (!__pyx_t_7) {
        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_6); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_GOTREF(__pyx_t_4);
      } else {
        __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_9);
        PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __Pyx_GIVEREF(__pyx_t_7); __pyx_t_7 = NULL;
        PyTuple_SET_ITEM(__pyx_t_9, 0+1, __pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_6);
        __pyx_t_6 = 0;
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_9, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      }
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "fst.pyx":1163
 *     if tfst == NULL:
 *       raise FstError("Read-time conversion to {!r} failed.".format(fst_type))
 *   return _init_XFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_4 = __pyx_f_3fst__init_XFst(__pyx_v_tfst); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1141
 * 
 * 
 * def Fst(filename, fst_type=b""):             # <<<<<<<<<<<<<<
 *   """Constructs an FST from a file.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("fst.Fst", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1169
 * 
 * 
 * def arcmap(_Fst ifst, float delta=kDelta, map_type=b"identity", weight=b""):             # <<<<<<<<<<<<<<
 *   """Constructively applies a transform to all arcs and final states.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_11arcmap(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_10arcmap[] = "Constructively applies a transform to all arcs and final states.\n\n  This operation transforms each arc and final state in the input FST using\n  one of the following:\n\n    * arc_sum: sums weights of identically labeled multi-arcs.\n    * identity: maps to self.\n    * invert: reciprocates all non-0 weights.\n    * plus: adds a constant to all weights.\n    * quantize: quantizes weights.\n    * rmweight: replaces all non-zero weights with 1.\n    * superfinal: redirects final states to a new superfinal state.\n    * times: right-multiplies a constant to all weights.\n    * to_log: converts weights to the log semiring.\n    * to_log64: converts weights to the log64 semiring.\n    * to_standard: converts weights to the tropical (\"standard\") semiring.\n\n  Args:\n    ifst: The input Fst.\n    delta: Comparison/quantization delta (ignored unless `map_type` is\n        `quantize`).\n    map_type: A string matching a known mapping operation.\n    weight: Constant weight (ignored unless `map_type` is `plus` or `times`).\n\n  Returns:\n    An FST with arcs and final states remapped.\n\n  See also: `convert`, `decode`, `encode`, `invert`, `project`.\n  ";
static PyMethodDef __pyx_mdef_3fst_11arcmap = {"arcmap", (PyCFunction)__pyx_pw_3fst_11arcmap, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_10arcmap};
static PyObject *__pyx_pw_3fst_11arcmap(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  float __pyx_v_delta;
  PyObject *__pyx_v_map_type = 0;
  PyObject *__pyx_v_weight = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("arcmap (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst,&__pyx_n_s_delta,&__pyx_n_s_map_type,&__pyx_n_s_weight,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)__pyx_n_b_identity);
    values[3] = ((PyObject *)__pyx_kp_b__5);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_map_type);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_weight);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "arcmap") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1169; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)values[0]);
    if (values[1]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[1]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1169; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__16;
    }
    __pyx_v_map_type = values[2];
    __pyx_v_weight = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("arcmap", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1169; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.arcmap", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_10arcmap(__pyx_self, __pyx_v_ifst, __pyx_v_delta, __pyx_v_map_type, __pyx_v_weight);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_10arcmap(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, PyObject *__pyx_v_map_type, PyObject *__pyx_v_weight) {
  enum fst::script::MapType __pyx_v_mt;
  fst::script::WeightClass __pyx_v_wc;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("arcmap", 0);
  __Pyx_INCREF(__pyx_v_map_type);

  /* "fst.pyx":1200
 *   """
 *   cdef MapType mt
 *   map_type = tobytes(map_type)             # <<<<<<<<<<<<<<
 *   if map_type == b"arc_sum":
 *     mt = ARC_SUM_MAPPER
 */
  __pyx_t_1 = __pyx_f_3fst_tobytes(__pyx_v_map_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF_SET(__pyx_v_map_type, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "fst.pyx":1201
 *   cdef MapType mt
 *   map_type = tobytes(map_type)
 *   if map_type == b"arc_sum":             # <<<<<<<<<<<<<<
 *     mt = ARC_SUM_MAPPER
 *   elif map_type == b"identity":
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_map_type, __pyx_n_b_arc_sum, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":1202
 *   map_type = tobytes(map_type)
 *   if map_type == b"arc_sum":
 *     mt = ARC_SUM_MAPPER             # <<<<<<<<<<<<<<
 *   elif map_type == b"identity":
 *     mt = IDENTITY_MAPPER
 */
    __pyx_v_mt = fst::script::ARC_SUM_MAPPER;
    goto __pyx_L3;
  }

  /* "fst.pyx":1203
 *   if map_type == b"arc_sum":
 *     mt = ARC_SUM_MAPPER
 *   elif map_type == b"identity":             # <<<<<<<<<<<<<<
 *     mt = IDENTITY_MAPPER
 *   elif map_type == b"invert":
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_map_type, __pyx_n_b_identity, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1203; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":1204
 *     mt = ARC_SUM_MAPPER
 *   elif map_type == b"identity":
 *     mt = IDENTITY_MAPPER             # <<<<<<<<<<<<<<
 *   elif map_type == b"invert":
 *     mt = INVERT_MAPPER
 */
    __pyx_v_mt = fst::script::IDENTITY_MAPPER;
    goto __pyx_L3;
  }

  /* "fst.pyx":1205
 *   elif map_type == b"identity":
 *     mt = IDENTITY_MAPPER
 *   elif map_type == b"invert":             # <<<<<<<<<<<<<<
 *     mt = INVERT_MAPPER
 *   elif map_type == b"plus":
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_map_type, __pyx_n_b_invert, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":1206
 *     mt = IDENTITY_MAPPER
 *   elif map_type == b"invert":
 *     mt = INVERT_MAPPER             # <<<<<<<<<<<<<<
 *   elif map_type == b"plus":
 *     mt = PLUS_MAPPER
 */
    __pyx_v_mt = fst::script::INVERT_MAPPER;
    goto __pyx_L3;
  }

  /* "fst.pyx":1207
 *   elif map_type == b"invert":
 *     mt = INVERT_MAPPER
 *   elif map_type == b"plus":             # <<<<<<<<<<<<<<
 *     mt = PLUS_MAPPER
 *   elif map_type == b"quantize":
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_map_type, __pyx_n_b_plus, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":1208
 *     mt = INVERT_MAPPER
 *   elif map_type == b"plus":
 *     mt = PLUS_MAPPER             # <<<<<<<<<<<<<<
 *   elif map_type == b"quantize":
 *     mt = QUANTIZE_MAPPER
 */
    __pyx_v_mt = fst::script::PLUS_MAPPER;
    goto __pyx_L3;
  }

  /* "fst.pyx":1209
 *   elif map_type == b"plus":
 *     mt = PLUS_MAPPER
 *   elif map_type == b"quantize":             # <<<<<<<<<<<<<<
 *     mt = QUANTIZE_MAPPER
 *   elif map_type == b"rmweight":
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_map_type, __pyx_n_b_quantize, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":1210
 *     mt = PLUS_MAPPER
 *   elif map_type == b"quantize":
 *     mt = QUANTIZE_MAPPER             # <<<<<<<<<<<<<<
 *   elif map_type == b"rmweight":
 *     mt = RMWEIGHT_MAPPER
 */
    __pyx_v_mt = fst::script::QUANTIZE_MAPPER;
    goto __pyx_L3;
  }

  /* "fst.pyx":1211
 *   elif map_type == b"quantize":
 *     mt = QUANTIZE_MAPPER
 *   elif map_type == b"rmweight":             # <<<<<<<<<<<<<<
 *     mt = RMWEIGHT_MAPPER
 *   elif map_type == b"superfinal":
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_map_type, __pyx_n_b_rmweight, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":1212
 *     mt = QUANTIZE_MAPPER
 *   elif map_type == b"rmweight":
 *     mt = RMWEIGHT_MAPPER             # <<<<<<<<<<<<<<
 *   elif map_type == b"superfinal":
 *     mt = SUPERFINAL_MAPPER
 */
    __pyx_v_mt = fst::script::RMWEIGHT_MAPPER;
    goto __pyx_L3;
  }

  /* "fst.pyx":1213
 *   elif map_type == b"rmweight":
 *     mt = RMWEIGHT_MAPPER
 *   elif map_type == b"superfinal":             # <<<<<<<<<<<<<<
 *     mt = SUPERFINAL_MAPPER
 *   elif map_type == b"times":
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_map_type, __pyx_n_b_superfinal, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":1214
 *     mt = RMWEIGHT_MAPPER
 *   elif map_type == b"superfinal":
 *     mt = SUPERFINAL_MAPPER             # <<<<<<<<<<<<<<
 *   elif map_type == b"times":
 *     mt = TIMES_MAPPER
 */
    __pyx_v_mt = fst::script::SUPERFINAL_MAPPER;
    goto __pyx_L3;
  }

  /* "fst.pyx":1215
 *   elif map_type == b"superfinal":
 *     mt = SUPERFINAL_MAPPER
 *   elif map_type == b"times":             # <<<<<<<<<<<<<<
 *     mt = TIMES_MAPPER
 *   elif map_type == b"to_log":
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_map_type, __pyx_n_b_times, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":1216
 *     mt = SUPERFINAL_MAPPER
 *   elif map_type == b"times":
 *     mt = TIMES_MAPPER             # <<<<<<<<<<<<<<
 *   elif map_type == b"to_log":
 *     mt = TO_LOG_MAPPER
 */
    __pyx_v_mt = fst::script::TIMES_MAPPER;
    goto __pyx_L3;
  }

  /* "fst.pyx":1217
 *   elif map_type == b"times":
 *     mt = TIMES_MAPPER
 *   elif map_type == b"to_log":             # <<<<<<<<<<<<<<
 *     mt = TO_LOG_MAPPER
 *   elif map_type == b"to_log64":
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_map_type, __pyx_n_b_to_log, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1217; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":1218
 *     mt = TIMES_MAPPER
 *   elif map_type == b"to_log":
 *     mt = TO_LOG_MAPPER             # <<<<<<<<<<<<<<
 *   elif map_type == b"to_log64":
 *     mt = TO_LOG64_MAPPER
 */
    __pyx_v_mt = fst::script::TO_LOG_MAPPER;
    goto __pyx_L3;
  }

  /* "fst.pyx":1219
 *   elif map_type == b"to_log":
 *     mt = TO_LOG_MAPPER
 *   elif map_type == b"to_log64":             # <<<<<<<<<<<<<<
 *     mt = TO_LOG64_MAPPER
 *   elif map_type == b"to_standard":
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_map_type, __pyx_n_b_to_log64, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":1220
 *     mt = TO_LOG_MAPPER
 *   elif map_type == b"to_log64":
 *     mt = TO_LOG64_MAPPER             # <<<<<<<<<<<<<<
 *   elif map_type == b"to_standard":
 *     mt = TO_STD_MAPPER
 */
    __pyx_v_mt = fst::script::TO_LOG64_MAPPER;
    goto __pyx_L3;
  }

  /* "fst.pyx":1221
 *   elif map_type == b"to_log64":
 *     mt = TO_LOG64_MAPPER
 *   elif map_type == b"to_standard":             # <<<<<<<<<<<<<<
 *     mt = TO_STD_MAPPER
 *   else:
 */
  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_map_type, __pyx_n_b_to_standard, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "fst.pyx":1222
 *     mt = TO_LOG64_MAPPER
 *   elif map_type == b"to_standard":
 *     mt = TO_STD_MAPPER             # <<<<<<<<<<<<<<
 *   else:
 *     raise FstError("Unknown map type: {!r}".format(map_type))
 */
    __pyx_v_mt = fst::script::TO_STD_MAPPER;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "fst.pyx":1224
 *     mt = TO_STD_MAPPER
 *   else:
 *     raise FstError("Unknown map type: {!r}".format(map_type))             # <<<<<<<<<<<<<<
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 *   return _init_XFst(Map(deref(ifst.fst), mt, delta, wc))
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Unknown_map_type_r, __pyx_n_s_format); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    if (!__pyx_t_6) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_map_type); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_7);
      PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6); __Pyx_GIVEREF(__pyx_t_6); __pyx_t_6 = NULL;
      __Pyx_INCREF(__pyx_v_map_type);
      PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_v_map_type);
      __Pyx_GIVEREF(__pyx_v_map_type);
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_7, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_7);
      PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __Pyx_GIVEREF(__pyx_t_5); __pyx_t_5 = NULL;
      PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L3:;

  /* "fst.pyx":1225
 *   else:
 *     raise FstError("Unknown map type: {!r}".format(map_type))
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))             # <<<<<<<<<<<<<<
 *   return _init_XFst(Map(deref(ifst.fst), mt, delta, wc))
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_weight_type_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __pyx_f_3fst_tobytes(__pyx_v_weight); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_v_wc = __pyx_f_3fst__get_weight_class(__pyx_t_1, __pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "fst.pyx":1226
 *     raise FstError("Unknown map type: {!r}".format(map_type))
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 *   return _init_XFst(Map(deref(ifst.fst), mt, delta, wc))             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __pyx_f_3fst__init_XFst(fst::script::Map((*__pyx_v_ifst->fst), __pyx_v_mt, __pyx_v_delta, __pyx_v_wc)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1169
 * 
 * 
 * def arcmap(_Fst ifst, float delta=kDelta, map_type=b"identity", weight=b""):             # <<<<<<<<<<<<<<
 *   """Constructively applies a transform to all arcs and final states.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("fst.arcmap", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_map_type);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1229
 * 
 * 
 * def compose(_Fst ifst1, _Fst ifst2, cf=b"auto", bool connect=True):             # <<<<<<<<<<<<<<
 *   """Constructively composes two FSTs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_13compose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_12compose[] = "Constructively composes two FSTs.\n\n  This operation computes the composition of two FSTs. If A transduces string\n  x to y with weight a and B transduces y to z with weight b, then their\n  composition transduces string x to z with weight a \\otimes b. The output\n  labels of the first transducer or the input labels of the second transducer\n  must be sorted (or otherwise support appropriate matchers).\n\n  Args:\n    ifst1: The first input Fst.\n    ifst2: The second input Fst.\n    cf: A string matching a known composition filter.\n    connect: Should output be trimmed?\n\n  Returns:\n    A composed MutableFst.\n\n  Raises:\n    FstError.\n\n  See also: `arcsort`.\n  ";
static PyMethodDef __pyx_mdef_3fst_13compose = {"compose", (PyCFunction)__pyx_pw_3fst_13compose, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_12compose};
static PyObject *__pyx_pw_3fst_13compose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst1 = 0;
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst2 = 0;
  PyObject *__pyx_v_cf = 0;
  bool __pyx_v_connect;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("compose (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst1,&__pyx_n_s_ifst2,&__pyx_n_s_cf,&__pyx_n_s_connect,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)__pyx_n_b_auto);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("compose", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1229; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cf);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_connect);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compose") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1229; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst1 = ((struct __pyx_obj_3fst__Fst *)values[0]);
    __pyx_v_ifst2 = ((struct __pyx_obj_3fst__Fst *)values[1]);
    __pyx_v_cf = values[2];
    if (values[3]) {
      __pyx_v_connect = __Pyx_PyObject_IsTrue(values[3]); if (unlikely((__pyx_v_connect == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1229; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_connect = ((bool)1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("compose", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1229; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.compose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst1), __pyx_ptype_3fst__Fst, 1, "ifst1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst2), __pyx_ptype_3fst__Fst, 1, "ifst2", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_12compose(__pyx_self, __pyx_v_ifst1, __pyx_v_ifst2, __pyx_v_cf, __pyx_v_connect);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_12compose(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, PyObject *__pyx_v_cf, bool __pyx_v_connect) {
  fst::script::VectorFstClass *__pyx_v_tfst;
  fst::script::ComposeOptions const *__pyx_v_opts;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  std::string __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  enum fst::ComposeFilter __pyx_t_8;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("compose", 0);

  /* "fst.pyx":1252
 *   See also: `arcsort`.
 *   """
 *   if ifst1._arc_type != ifst2._arc_type:             # <<<<<<<<<<<<<<
 *     raise FstError("Input FSTs must have the same arc type")
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst1._arc_type)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst1), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst2), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyObject_RichCompare(__pyx_t_1, __pyx_t_2, Py_NE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_4) {

    /* "fst.pyx":1253
 *   """
 *   if ifst1._arc_type != ifst2._arc_type:
 *     raise FstError("Input FSTs must have the same arc type")             # <<<<<<<<<<<<<<
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst1._arc_type)
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "fst.pyx":1254
 *   if ifst1._arc_type != ifst2._arc_type:
 *     raise FstError("Input FSTs must have the same arc type")
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst1._arc_type)             # <<<<<<<<<<<<<<
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,
 *       _get_compose_filter(tobytes(cf)))
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst1), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1254; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_5 = __pyx_convert_string_from_py_(__pyx_t_2); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1254; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_5);

  /* "fst.pyx":1256
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst1._arc_type)
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,
 *       _get_compose_filter(tobytes(cf)))             # <<<<<<<<<<<<<<
 *   Compose(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))
 *   del opts
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_compose_filter); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = __pyx_f_3fst_tobytes(__pyx_v_cf); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_6 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_6) {
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_GOTREF(__pyx_t_2);
  } else {
    __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6); __Pyx_GIVEREF(__pyx_t_6); __pyx_t_6 = NULL;
    PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_1);
    __pyx_t_1 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_8 = ((enum fst::ComposeFilter)PyInt_AsLong(__pyx_t_2)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "fst.pyx":1255
 *     raise FstError("Input FSTs must have the same arc type")
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst1._arc_type)
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,             # <<<<<<<<<<<<<<
 *       _get_compose_filter(tobytes(cf)))
 *   Compose(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))
 */
  __pyx_v_opts = new fst::script::ComposeOptions(__pyx_v_connect, __pyx_t_8);

  /* "fst.pyx":1257
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,
 *       _get_compose_filter(tobytes(cf)))
 *   Compose(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))             # <<<<<<<<<<<<<<
 *   del opts
 *   return _init_MutableFst(tfst)
 */
  fst::script::Compose((*__pyx_v_ifst1->fst), (*__pyx_v_ifst2->fst), __pyx_v_tfst, (*__pyx_v_opts));

  /* "fst.pyx":1258
 *       _get_compose_filter(tobytes(cf)))
 *   Compose(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))
 *   del opts             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  delete __pyx_v_opts;

  /* "fst.pyx":1259
 *   Compose(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))
 *   del opts
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1229
 * 
 * 
 * def compose(_Fst ifst1, _Fst ifst2, cf=b"auto", bool connect=True):             # <<<<<<<<<<<<<<
 *   """Constructively composes two FSTs.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("fst.compose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1262
 * 
 * 
 * def convert(_Fst ifst, fst_type=b""):             # <<<<<<<<<<<<<<
 *   """Constructively converts an FST to a new internal representation.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_15convert(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_14convert[] = "Constructively converts an FST to a new internal representation.\n\n  Args:\n    ifst: The input Fst.\n    fst_type: A string representing the FST type the FST to convert to.\n\n  Returns:\n    An equivalent Fst converted to the desired FST type.\n  ";
static PyMethodDef __pyx_mdef_3fst_15convert = {"convert", (PyCFunction)__pyx_pw_3fst_15convert, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_14convert};
static PyObject *__pyx_pw_3fst_15convert(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  PyObject *__pyx_v_fst_type = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("convert (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst,&__pyx_n_s_fst_type_2,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_kp_b__5);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_fst_type_2);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "convert") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1262; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)values[0]);
    __pyx_v_fst_type = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("convert", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1262; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.convert", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_14convert(__pyx_self, __pyx_v_ifst, __pyx_v_fst_type);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_14convert(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, PyObject *__pyx_v_fst_type) {
  fst::script::FstClass *__pyx_v_tfst;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("convert", 0);

  /* "fst.pyx":1272
 *     An equivalent Fst converted to the desired FST type.
 *   """
 *   cdef FstClass *tfst = new FstClass(deref(ifst.fst))             # <<<<<<<<<<<<<<
 *   tfst = Convert(deref(ifst.fst), tobytes(fst_type))
 *   # Script-land Convert returns the null pointer to signal failure.
 */
  __pyx_v_tfst = new fst::script::FstClass((*__pyx_v_ifst->fst));

  /* "fst.pyx":1273
 *   """
 *   cdef FstClass *tfst = new FstClass(deref(ifst.fst))
 *   tfst = Convert(deref(ifst.fst), tobytes(fst_type))             # <<<<<<<<<<<<<<
 *   # Script-land Convert returns the null pointer to signal failure.
 *   if tfst == NULL:
 */
  __pyx_t_1 = __pyx_f_3fst_tobytes(__pyx_v_fst_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1273; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1273; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = fst::script::Convert((*__pyx_v_ifst->fst), __pyx_t_2);

  /* "fst.pyx":1275
 *   tfst = Convert(deref(ifst.fst), tobytes(fst_type))
 *   # Script-land Convert returns the null pointer to signal failure.
 *   if tfst == NULL:             # <<<<<<<<<<<<<<
 *     raise FstError("Read-time conversion to {!r} failed.".format(fst_type))
 *   return _init_XFst(tfst)
 */
  __pyx_t_3 = ((__pyx_v_tfst == NULL) != 0);
  if (__pyx_t_3) {

    /* "fst.pyx":1276
 *   # Script-land Convert returns the null pointer to signal failure.
 *   if tfst == NULL:
 *     raise FstError("Read-time conversion to {!r} failed.".format(fst_type))             # <<<<<<<<<<<<<<
 *   return _init_XFst(tfst)
 * 
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Read_time_conversion_to_r_failed, __pyx_n_s_format); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    if (!__pyx_t_7) {
      __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_fst_type); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
    } else {
      __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __Pyx_GIVEREF(__pyx_t_7); __pyx_t_7 = NULL;
      __Pyx_INCREF(__pyx_v_fst_type);
      PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_v_fst_type);
      __Pyx_GIVEREF(__pyx_v_fst_type);
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    }
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_6) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __Pyx_GIVEREF(__pyx_t_6); __pyx_t_6 = NULL;
      PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_5);
      __pyx_t_5 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "fst.pyx":1277
 *   if tfst == NULL:
 *     raise FstError("Read-time conversion to {!r} failed.".format(fst_type))
 *   return _init_XFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_3fst__init_XFst(__pyx_v_tfst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1262
 * 
 * 
 * def convert(_Fst ifst, fst_type=b""):             # <<<<<<<<<<<<<<
 *   """Constructively converts an FST to a new internal representation.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("fst.convert", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1280
 * 
 * 
 * def determinize(_Fst ifst, float delta=kDelta, det_type=b"functional",             # <<<<<<<<<<<<<<
 *                 int64 nstate=kNoStateId, int64 subsequential_label=0,
 *                 weight=b"", bool increment_subsequential_label=False):
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_17determinize(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_16determinize[] = "Constructively determinizes a weighted FST.\n\n  This operations creates an equivalent FST that has the property that no\n  state has two transitions with the same input label. For this algorithm,\n  epsilon transitions are treated as regular symbols (cf. `rmepsilon`).\n\n  Args:\n    ifst: The input Fst.\n    delta: Comparison/quantization delta.\n    det_type: Type of determinization: \"functional\" (input transducer is\n        functional), \"nonfunctional\" (input transducer is not functional) and\n        \"disambiguate\" (input transducer is not functional but only keep the\n        min of ambiguous outputs).\n    nstate: State number threshold.\n    subsequential_label: Input label of arc corresponding to residual final\n        output when producing a subsequential transducer.\n    weight: A string representing a desired weight threshold; paths with weights\n        below this threshold will be pruned.\n    increment_subsequential_label: Increment subsequential when creating\n        several arcs for the residual final output at a given state.\n\n  Returns:\n    An equivalent deterministic MutableFst.\n\n  See also: `disambiguate`, `rmepsilon`.\n  ";
static PyMethodDef __pyx_mdef_3fst_17determinize = {"determinize", (PyCFunction)__pyx_pw_3fst_17determinize, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_16determinize};
static PyObject *__pyx_pw_3fst_17determinize(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  float __pyx_v_delta;
  PyObject *__pyx_v_det_type = 0;
  int64 __pyx_v_nstate;
  int64 __pyx_v_subsequential_label;
  PyObject *__pyx_v_weight = 0;
  bool __pyx_v_increment_subsequential_label;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("determinize (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst,&__pyx_n_s_delta,&__pyx_n_s_det_type,&__pyx_n_s_nstate,&__pyx_n_s_subsequential_label,&__pyx_n_s_weight,&__pyx_n_s_increment_subsequential_label,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};
    values[2] = ((PyObject *)__pyx_n_b_functional);
    values[5] = ((PyObject *)__pyx_kp_b__5);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_det_type);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nstate);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_subsequential_label);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_weight);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_increment_subsequential_label);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "determinize") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)values[0]);
    if (values[1]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[1]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__18;
    }
    __pyx_v_det_type = values[2];
    if (values[3]) {
      __pyx_v_nstate = __Pyx_PyInt_As_int64_t(values[3]); if (unlikely((__pyx_v_nstate == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1281; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_nstate = __pyx_k__19;
    }
    if (values[4]) {
      __pyx_v_subsequential_label = __Pyx_PyInt_As_int64_t(values[4]); if (unlikely((__pyx_v_subsequential_label == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1281; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_subsequential_label = ((int64)0);
    }
    __pyx_v_weight = values[5];
    if (values[6]) {
      __pyx_v_increment_subsequential_label = __Pyx_PyObject_IsTrue(values[6]); if (unlikely((__pyx_v_increment_subsequential_label == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1282; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "fst.pyx":1282
 * def determinize(_Fst ifst, float delta=kDelta, det_type=b"functional",
 *                 int64 nstate=kNoStateId, int64 subsequential_label=0,
 *                 weight=b"", bool increment_subsequential_label=False):             # <<<<<<<<<<<<<<
 *   """Constructively determinizes a weighted FST.
 * 
 */
      __pyx_v_increment_subsequential_label = ((bool)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("determinize", 0, 1, 7, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.determinize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_16determinize(__pyx_self, __pyx_v_ifst, __pyx_v_delta, __pyx_v_det_type, __pyx_v_nstate, __pyx_v_subsequential_label, __pyx_v_weight, __pyx_v_increment_subsequential_label);

  /* "fst.pyx":1280
 * 
 * 
 * def determinize(_Fst ifst, float delta=kDelta, det_type=b"functional",             # <<<<<<<<<<<<<<
 *                 int64 nstate=kNoStateId, int64 subsequential_label=0,
 *                 weight=b"", bool increment_subsequential_label=False):
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_16determinize(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, PyObject *__pyx_v_det_type, int64 __pyx_v_nstate, int64 __pyx_v_subsequential_label, PyObject *__pyx_v_weight, bool __pyx_v_increment_subsequential_label) {
  fst::script::VectorFstClass *__pyx_v_tfst;
  fst::script::WeightClass __pyx_v_wc;
  enum fst::DeterminizeType __pyx_v_dt;
  fst::script::DeterminizeOptions const *__pyx_v_opts;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("determinize", 0);
  __Pyx_INCREF(__pyx_v_det_type);

  /* "fst.pyx":1309
 *   See also: `disambiguate`, `rmepsilon`.
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)             # <<<<<<<<<<<<<<
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 *   det_type = tobytes(det_type)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1309; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1309; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_2);

  /* "fst.pyx":1310
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))             # <<<<<<<<<<<<<<
 *   det_type = tobytes(det_type)
 *   cdef DeterminizeType dt = DETERMINIZE_FUNCTIONAL
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_weight_type_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1310; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __pyx_f_3fst_tobytes(__pyx_v_weight); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1310; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_v_wc = __pyx_f_3fst__get_weight_class(__pyx_t_1, __pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "fst.pyx":1311
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 *   det_type = tobytes(det_type)             # <<<<<<<<<<<<<<
 *   cdef DeterminizeType dt = DETERMINIZE_FUNCTIONAL
 *   if det_type == b"functional":
 */
  __pyx_t_3 = __pyx_f_3fst_tobytes(__pyx_v_det_type); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF_SET(__pyx_v_det_type, __pyx_t_3);
  __pyx_t_3 = 0;

  /* "fst.pyx":1312
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 *   det_type = tobytes(det_type)
 *   cdef DeterminizeType dt = DETERMINIZE_FUNCTIONAL             # <<<<<<<<<<<<<<
 *   if det_type == b"functional":
 *     dt = DETERMINIZE_FUNCTIONAL
 */
  __pyx_v_dt = fst::DETERMINIZE_FUNCTIONAL;

  /* "fst.pyx":1313
 *   det_type = tobytes(det_type)
 *   cdef DeterminizeType dt = DETERMINIZE_FUNCTIONAL
 *   if det_type == b"functional":             # <<<<<<<<<<<<<<
 *     dt = DETERMINIZE_FUNCTIONAL
 *   elif det_type == b"nonfunctional":
 */
  __pyx_t_4 = (__Pyx_PyBytes_Equals(__pyx_v_det_type, __pyx_n_b_functional, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1313; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_4) {

    /* "fst.pyx":1314
 *   cdef DeterminizeType dt = DETERMINIZE_FUNCTIONAL
 *   if det_type == b"functional":
 *     dt = DETERMINIZE_FUNCTIONAL             # <<<<<<<<<<<<<<
 *   elif det_type == b"nonfunctional":
 *     dt = DETERMINIZE_NONFUNCTIONAL
 */
    __pyx_v_dt = fst::DETERMINIZE_FUNCTIONAL;
    goto __pyx_L3;
  }

  /* "fst.pyx":1315
 *   if det_type == b"functional":
 *     dt = DETERMINIZE_FUNCTIONAL
 *   elif det_type == b"nonfunctional":             # <<<<<<<<<<<<<<
 *     dt = DETERMINIZE_NONFUNCTIONAL
 *   elif det_type == b"disambiguate":
 */
  __pyx_t_4 = (__Pyx_PyBytes_Equals(__pyx_v_det_type, __pyx_n_b_nonfunctional, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_4) {

    /* "fst.pyx":1316
 *     dt = DETERMINIZE_FUNCTIONAL
 *   elif det_type == b"nonfunctional":
 *     dt = DETERMINIZE_NONFUNCTIONAL             # <<<<<<<<<<<<<<
 *   elif det_type == b"disambiguate":
 *     dt = DETERMINIZE_DISAMBIGUATE
 */
    __pyx_v_dt = fst::DETERMINIZE_NONFUNCTIONAL;
    goto __pyx_L3;
  }

  /* "fst.pyx":1317
 *   elif det_type == b"nonfunctional":
 *     dt = DETERMINIZE_NONFUNCTIONAL
 *   elif det_type == b"disambiguate":             # <<<<<<<<<<<<<<
 *     dt = DETERMINIZE_DISAMBIGUATE
 *   else:
 */
  __pyx_t_4 = (__Pyx_PyBytes_Equals(__pyx_v_det_type, __pyx_n_b_disambiguate, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1317; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_4) {

    /* "fst.pyx":1318
 *     dt = DETERMINIZE_NONFUNCTIONAL
 *   elif det_type == b"disambiguate":
 *     dt = DETERMINIZE_DISAMBIGUATE             # <<<<<<<<<<<<<<
 *   else:
 *     raise FstError("Unknown determinize type: {!r}".format(type))
 */
    __pyx_v_dt = fst::DETERMINIZE_DISAMBIGUATE;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "fst.pyx":1320
 *     dt = DETERMINIZE_DISAMBIGUATE
 *   else:
 *     raise FstError("Unknown determinize type: {!r}".format(type))             # <<<<<<<<<<<<<<
 *   cdef const DeterminizeOptions *opts = new DeterminizeOptions(
 *       delta, wc, nstate, subsequential_label, dt, increment_subsequential_label)
 */
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Unknown_determinize_type_r, __pyx_n_s_format); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    if (!__pyx_t_7) {
      __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_6, ((PyObject *)((PyObject*)(&PyType_Type)))); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
    } else {
      __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __Pyx_GIVEREF(__pyx_t_7); __pyx_t_7 = NULL;
      __Pyx_INCREF(((PyObject *)((PyObject*)(&PyType_Type))));
      PyTuple_SET_ITEM(__pyx_t_8, 0+1, ((PyObject *)((PyObject*)(&PyType_Type))));
      __Pyx_GIVEREF(((PyObject *)((PyObject*)(&PyType_Type))));
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    }
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    if (!__pyx_t_6) {
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_3);
    } else {
      __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __Pyx_GIVEREF(__pyx_t_6); __pyx_t_6 = NULL;
      PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_5);
      __pyx_t_5 = 0;
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_8, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L3:;

  /* "fst.pyx":1321
 *   else:
 *     raise FstError("Unknown determinize type: {!r}".format(type))
 *   cdef const DeterminizeOptions *opts = new DeterminizeOptions(             # <<<<<<<<<<<<<<
 *       delta, wc, nstate, subsequential_label, dt, increment_subsequential_label)
 *   Determinize(deref(ifst.fst), tfst, deref(opts))
 */
  __pyx_v_opts = new fst::script::DeterminizeOptions(__pyx_v_delta, __pyx_v_wc, __pyx_v_nstate, __pyx_v_subsequential_label, __pyx_v_dt, __pyx_v_increment_subsequential_label);

  /* "fst.pyx":1323
 *   cdef const DeterminizeOptions *opts = new DeterminizeOptions(
 *       delta, wc, nstate, subsequential_label, dt, increment_subsequential_label)
 *   Determinize(deref(ifst.fst), tfst, deref(opts))             # <<<<<<<<<<<<<<
 *   del opts
 *   return _init_MutableFst(tfst)
 */
  fst::script::Determinize((*__pyx_v_ifst->fst), __pyx_v_tfst, (*__pyx_v_opts));

  /* "fst.pyx":1324
 *       delta, wc, nstate, subsequential_label, dt, increment_subsequential_label)
 *   Determinize(deref(ifst.fst), tfst, deref(opts))
 *   del opts             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  delete __pyx_v_opts;

  /* "fst.pyx":1325
 *   Determinize(deref(ifst.fst), tfst, deref(opts))
 *   del opts
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1280
 * 
 * 
 * def determinize(_Fst ifst, float delta=kDelta, det_type=b"functional",             # <<<<<<<<<<<<<<
 *                 int64 nstate=kNoStateId, int64 subsequential_label=0,
 *                 weight=b"", bool increment_subsequential_label=False):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("fst.determinize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_det_type);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1328
 * 
 * 
 * def difference(_Fst ifst1, _Fst ifst2, cf=b"auto", bool connect=True):             # <<<<<<<<<<<<<<
 *   """Constructively computes the difference of two FSTs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_19difference(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_18difference[] = "Constructively computes the difference of two FSTs.\n\n  This operation computes the difference between two FSAs. Only strings that are\n  in the first automaton but not in second are retained in the result. The first\n  argument must be an acceptor; the second argument must be an unweighted,\n  epsilon-free, deterministic acceptor. The output labels of the first\n  transducer or the input labels of the second transducer must be sorted (or\n  otherwise support appropriate matchers).\n\n  Args:\n    ifst1: The first input Fst.\n    ifst2: The second input Fst.\n    cf: A string matching a known composition filter.\n    connect: Should the output FST be trimmed?\n\n  Returns:\n    An MutableFst representing the difference of the two input FSTs.\n  ";
static PyMethodDef __pyx_mdef_3fst_19difference = {"difference", (PyCFunction)__pyx_pw_3fst_19difference, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_18difference};
static PyObject *__pyx_pw_3fst_19difference(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst1 = 0;
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst2 = 0;
  PyObject *__pyx_v_cf = 0;
  bool __pyx_v_connect;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("difference (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst1,&__pyx_n_s_ifst2,&__pyx_n_s_cf,&__pyx_n_s_connect,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)__pyx_n_b_auto);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("difference", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1328; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cf);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_connect);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "difference") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1328; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst1 = ((struct __pyx_obj_3fst__Fst *)values[0]);
    __pyx_v_ifst2 = ((struct __pyx_obj_3fst__Fst *)values[1]);
    __pyx_v_cf = values[2];
    if (values[3]) {
      __pyx_v_connect = __Pyx_PyObject_IsTrue(values[3]); if (unlikely((__pyx_v_connect == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1328; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_connect = ((bool)1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("difference", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1328; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.difference", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst1), __pyx_ptype_3fst__Fst, 1, "ifst1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst2), __pyx_ptype_3fst__Fst, 1, "ifst2", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_18difference(__pyx_self, __pyx_v_ifst1, __pyx_v_ifst2, __pyx_v_cf, __pyx_v_connect);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_18difference(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, PyObject *__pyx_v_cf, bool __pyx_v_connect) {
  fst::script::VectorFstClass *__pyx_v_tfst;
  fst::script::ComposeOptions const *__pyx_v_opts;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  enum fst::ComposeFilter __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("difference", 0);

  /* "fst.pyx":1347
 *     An MutableFst representing the difference of the two input FSTs.
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst1._arc_type)             # <<<<<<<<<<<<<<
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,
 *       _get_compose_filter(tobytes(cf)))
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst1), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_2);

  /* "fst.pyx":1349
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst1._arc_type)
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,
 *       _get_compose_filter(tobytes(cf)))             # <<<<<<<<<<<<<<
 *   Difference(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))
 *   del opts
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_compose_filter); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_3fst_tobytes(__pyx_v_cf); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_5) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __Pyx_GIVEREF(__pyx_t_5); __pyx_t_5 = NULL;
    PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_7 = ((enum fst::ComposeFilter)PyInt_AsLong(__pyx_t_1)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1348
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst1._arc_type)
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,             # <<<<<<<<<<<<<<
 *       _get_compose_filter(tobytes(cf)))
 *   Difference(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))
 */
  __pyx_v_opts = new fst::script::ComposeOptions(__pyx_v_connect, __pyx_t_7);

  /* "fst.pyx":1350
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,
 *       _get_compose_filter(tobytes(cf)))
 *   Difference(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))             # <<<<<<<<<<<<<<
 *   del opts
 *   return _init_MutableFst(tfst)
 */
  fst::script::Difference((*__pyx_v_ifst1->fst), (*__pyx_v_ifst2->fst), __pyx_v_tfst, (*__pyx_v_opts));

  /* "fst.pyx":1351
 *       _get_compose_filter(tobytes(cf)))
 *   Difference(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))
 *   del opts             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  delete __pyx_v_opts;

  /* "fst.pyx":1352
 *   Difference(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))
 *   del opts
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1352; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1328
 * 
 * 
 * def difference(_Fst ifst1, _Fst ifst2, cf=b"auto", bool connect=True):             # <<<<<<<<<<<<<<
 *   """Constructively computes the difference of two FSTs.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("fst.difference", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1355
 * 
 * 
 * def disambiguate(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId,             # <<<<<<<<<<<<<<
 *                  int64 subsequential_label=0, string weight=b""):
 *   """Constructively disambiguates a weighted transducer.
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_21disambiguate(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_20disambiguate[] = "Constructively disambiguates a weighted transducer.\n\n  This operation disambiguates a weighted transducer. The result will be an\n  equivalent FST that has the property that no two successful paths have the\n  same input labeling. For this algorithm, epsilon transitions are treated as\n  regular symbols (cf. `rmepsilon`).\n\n  Args:\n    ifst: The input Fst.\n    delta: Comparison/quantization delta.\n    nstate: State number threshold.\n    subsequential_label: Input label of arc corresponding to residual final\n        output when producing a subsequential transducer.\n    weight: A string representing a desired weight threshold; paths with weights\n        below this threshold will be pruned.\n\n  Returns:\n    An equivalent disambiguated MutableFst.\n\n  See also: `determinize`, `rmepsilon`.\n  ";
static PyMethodDef __pyx_mdef_3fst_21disambiguate = {"disambiguate", (PyCFunction)__pyx_pw_3fst_21disambiguate, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_20disambiguate};
static PyObject *__pyx_pw_3fst_21disambiguate(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  float __pyx_v_delta;
  int64 __pyx_v_nstate;
  int64 __pyx_v_subsequential_label;
  std::string __pyx_v_weight;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("disambiguate (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst,&__pyx_n_s_delta,&__pyx_n_s_nstate,&__pyx_n_s_subsequential_label,&__pyx_n_s_weight,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nstate);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_subsequential_label);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_weight);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "disambiguate") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1355; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)values[0]);
    if (values[1]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[1]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1355; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__20;
    }
    if (values[2]) {
      __pyx_v_nstate = __Pyx_PyInt_As_int64_t(values[2]); if (unlikely((__pyx_v_nstate == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1355; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_nstate = __pyx_k__21;
    }
    if (values[3]) {
      __pyx_v_subsequential_label = __Pyx_PyInt_As_int64_t(values[3]); if (unlikely((__pyx_v_subsequential_label == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1356; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_subsequential_label = ((int64)0);
    }
    if (values[4]) {
      __pyx_v_weight = __pyx_convert_string_from_py_(values[4]); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1356; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_weight = __pyx_k__22;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("disambiguate", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1355; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.disambiguate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_20disambiguate(__pyx_self, __pyx_v_ifst, __pyx_v_delta, __pyx_v_nstate, __pyx_v_subsequential_label, __pyx_v_weight);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_20disambiguate(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, int64 __pyx_v_nstate, int64 __pyx_v_subsequential_label, std::string __pyx_v_weight) {
  fst::script::VectorFstClass *__pyx_v_tfst;
  fst::script::WeightClass __pyx_v_wc;
  fst::script::DisambiguateOptions const *__pyx_v_opts;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("disambiguate", 0);

  /* "fst.pyx":1378
 *   See also: `determinize`, `rmepsilon`.
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)             # <<<<<<<<<<<<<<
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 *   cdef const DisambiguateOptions *opts = new DisambiguateOptions(delta, wc,
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_2);

  /* "fst.pyx":1379
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))             # <<<<<<<<<<<<<<
 *   cdef const DisambiguateOptions *opts = new DisambiguateOptions(delta, wc,
 *       nstate, subsequential_label)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_weight_type_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __pyx_convert_string_to_py_(__pyx_v_weight); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_3fst_tobytes(__pyx_t_3); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_wc = __pyx_f_3fst__get_weight_class(__pyx_t_1, __pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "fst.pyx":1380
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 *   cdef const DisambiguateOptions *opts = new DisambiguateOptions(delta, wc,             # <<<<<<<<<<<<<<
 *       nstate, subsequential_label)
 *   Disambiguate(deref(ifst.fst), tfst, deref(opts))
 */
  __pyx_v_opts = new fst::script::DisambiguateOptions(__pyx_v_delta, __pyx_v_wc, __pyx_v_nstate, __pyx_v_subsequential_label);

  /* "fst.pyx":1382
 *   cdef const DisambiguateOptions *opts = new DisambiguateOptions(delta, wc,
 *       nstate, subsequential_label)
 *   Disambiguate(deref(ifst.fst), tfst, deref(opts))             # <<<<<<<<<<<<<<
 *   del opts
 *   return _init_MutableFst(tfst)
 */
  fst::script::Disambiguate((*__pyx_v_ifst->fst), __pyx_v_tfst, (*__pyx_v_opts));

  /* "fst.pyx":1383
 *       nstate, subsequential_label)
 *   Disambiguate(deref(ifst.fst), tfst, deref(opts))
 *   del opts             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  delete __pyx_v_opts;

  /* "fst.pyx":1384
 *   Disambiguate(deref(ifst.fst), tfst, deref(opts))
 *   del opts
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_4 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1355
 * 
 * 
 * def disambiguate(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId,             # <<<<<<<<<<<<<<
 *                  int64 subsequential_label=0, string weight=b""):
 *   """Constructively disambiguates a weighted transducer.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("fst.disambiguate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1387
 * 
 * 
 * def epsnormalize(_Fst ifst, bool eps_norm_output=False):             # <<<<<<<<<<<<<<
 *   """Constructively epsilon-normalizes an FST.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_23epsnormalize(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_22epsnormalize[] = "Constructively epsilon-normalizes an FST.\n\n  This operation creates an equivalent FST that is epsilon-normalized. An\n  acceptor is epsilon-normalized if it it is epsilon-removed (cf. `rmepsilon`).\n  A transducer is input epsilon-normalized if, in addition, along any path, all\n  arcs with epsilon input labels follow all arcs with non-epsilon input labels.\n  Output epsilon-normalized is defined similarly. The input FST must be\n  functional.\n\n  Args:\n    ifst: The input Fst.\n    eps_norm_output: Should the FST be output epsilon-normalized?\n\n  Returns:\n    An equivalent epsilon-normalized MutableFst.\n\n  See also: `rmepsilon`.\n  ";
static PyMethodDef __pyx_mdef_3fst_23epsnormalize = {"epsnormalize", (PyCFunction)__pyx_pw_3fst_23epsnormalize, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_22epsnormalize};
static PyObject *__pyx_pw_3fst_23epsnormalize(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  bool __pyx_v_eps_norm_output;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("epsnormalize (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst,&__pyx_n_s_eps_norm_output,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_eps_norm_output);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "epsnormalize") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1387; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)values[0]);
    if (values[1]) {
      __pyx_v_eps_norm_output = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_eps_norm_output == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1387; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_eps_norm_output = ((bool)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("epsnormalize", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1387; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.epsnormalize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_22epsnormalize(__pyx_self, __pyx_v_ifst, __pyx_v_eps_norm_output);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_22epsnormalize(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, bool __pyx_v_eps_norm_output) {
  fst::script::VectorFstClass *__pyx_v_tfst;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  enum fst::EpsNormalizeType __pyx_t_3;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("epsnormalize", 0);

  /* "fst.pyx":1406
 *   See also: `rmepsilon`.
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)             # <<<<<<<<<<<<<<
 *   EpsNormalize(deref(ifst.fst), tfst, EPS_NORM_OUTPUT if eps_norm_output else
 *                                       EPS_NORM_INPUT)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_2);

  /* "fst.pyx":1407
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   EpsNormalize(deref(ifst.fst), tfst, EPS_NORM_OUTPUT if eps_norm_output else             # <<<<<<<<<<<<<<
 *                                       EPS_NORM_INPUT)
 *   return _init_MutableFst(tfst)
 */
  if ((__pyx_v_eps_norm_output != 0)) {
    __pyx_t_3 = fst::EPS_NORM_OUTPUT;
  } else {

    /* "fst.pyx":1408
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   EpsNormalize(deref(ifst.fst), tfst, EPS_NORM_OUTPUT if eps_norm_output else
 *                                       EPS_NORM_INPUT)             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
    __pyx_t_3 = fst::EPS_NORM_INPUT;
  }

  /* "fst.pyx":1407
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   EpsNormalize(deref(ifst.fst), tfst, EPS_NORM_OUTPUT if eps_norm_output else             # <<<<<<<<<<<<<<
 *                                       EPS_NORM_INPUT)
 *   return _init_MutableFst(tfst)
 */
  fst::script::EpsNormalize((*__pyx_v_ifst->fst), __pyx_v_tfst, __pyx_t_3);

  /* "fst.pyx":1409
 *   EpsNormalize(deref(ifst.fst), tfst, EPS_NORM_OUTPUT if eps_norm_output else
 *                                       EPS_NORM_INPUT)
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1387
 * 
 * 
 * def epsnormalize(_Fst ifst, bool eps_norm_output=False):             # <<<<<<<<<<<<<<
 *   """Constructively epsilon-normalizes an FST.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst.epsnormalize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1412
 * 
 * 
 * def equal(_Fst ifst1, _Fst ifst2, float delta=kDelta):             # <<<<<<<<<<<<<<
 *   """Are two FSTs equal?
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_25equal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_24equal[] = "Are two FSTs equal?\n\n  This function tests whether two FSTs have the same states with the same\n  numbering and the same transitions with the same labels and weights in the\n  same order.\n\n  Args:\n    ifst1: The first input Fst.\n    ifst2: The second input Fst.\n    delta: Comparison/quantization delta.\n\n  Returns:\n    True if the two transducers satisfy the above condition, else False.\n\n  See also: `equivalent`, `isomorphic`, `randequivalent`.\n  ";
static PyMethodDef __pyx_mdef_3fst_25equal = {"equal", (PyCFunction)__pyx_pw_3fst_25equal, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_24equal};
static PyObject *__pyx_pw_3fst_25equal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst1 = 0;
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst2 = 0;
  float __pyx_v_delta;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("equal (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst1,&__pyx_n_s_ifst2,&__pyx_n_s_delta,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("equal", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1412; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "equal") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1412; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst1 = ((struct __pyx_obj_3fst__Fst *)values[0]);
    __pyx_v_ifst2 = ((struct __pyx_obj_3fst__Fst *)values[1]);
    if (values[2]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[2]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1412; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__23;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("equal", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1412; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst1), __pyx_ptype_3fst__Fst, 1, "ifst1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst2), __pyx_ptype_3fst__Fst, 1, "ifst2", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_24equal(__pyx_self, __pyx_v_ifst1, __pyx_v_ifst2, __pyx_v_delta);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_24equal(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, float __pyx_v_delta) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("equal", 0);

  /* "fst.pyx":1429
 *   See also: `equivalent`, `isomorphic`, `randequivalent`.
 *   """
 *   return Equal(deref(ifst1.fst), deref(ifst2.fst), delta)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(fst::script::Equal((*__pyx_v_ifst1->fst), (*__pyx_v_ifst2->fst), __pyx_v_delta)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1412
 * 
 * 
 * def equal(_Fst ifst1, _Fst ifst2, float delta=kDelta):             # <<<<<<<<<<<<<<
 *   """Are two FSTs equal?
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst.equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1432
 * 
 * 
 * def equivalent(_Fst ifst1, _Fst ifst2, float delta=kDelta):             # <<<<<<<<<<<<<<
 *   """Are the two acceptors equivalent?
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_27equivalent(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_26equivalent[] = "Are the two acceptors equivalent?\n\n  This operation tests whether two epsilon-free deterministic weighted\n  acceptors are equivalent, that is if they accept the same strings with the\n  same weights.\n\n  Args:\n    ifst1: The first input Fst.\n    ifst2: The second input Fst.\n    delta: Comparison/quantization delta.\n\n  Returns:\n    True if the two transducers satisfy the above condition, else False.\n\n  Raises:\n    FstError.\n\n  See also: `equal`, `isomorphic`, `randequivalent`.\n  ";
static PyMethodDef __pyx_mdef_3fst_27equivalent = {"equivalent", (PyCFunction)__pyx_pw_3fst_27equivalent, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_26equivalent};
static PyObject *__pyx_pw_3fst_27equivalent(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst1 = 0;
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst2 = 0;
  float __pyx_v_delta;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("equivalent (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst1,&__pyx_n_s_ifst2,&__pyx_n_s_delta,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("equivalent", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "equivalent") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst1 = ((struct __pyx_obj_3fst__Fst *)values[0]);
    __pyx_v_ifst2 = ((struct __pyx_obj_3fst__Fst *)values[1]);
    if (values[2]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[2]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__24;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("equivalent", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.equivalent", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst1), __pyx_ptype_3fst__Fst, 1, "ifst1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst2), __pyx_ptype_3fst__Fst, 1, "ifst2", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_26equivalent(__pyx_self, __pyx_v_ifst1, __pyx_v_ifst2, __pyx_v_delta);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_26equivalent(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, float __pyx_v_delta) {
  bool __pyx_v_result;
  bool __pyx_v_error;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("equivalent", 0);

  /* "fst.pyx":1453
 *   """
 *   cdef bool result, error
 *   result = Equivalent(deref(ifst1.fst), deref(ifst2.fst), delta, &error)             # <<<<<<<<<<<<<<
 *   if error:
 *     raise FstError("Equivalence test encountered error")
 */
  __pyx_v_result = fst::script::Equivalent((*__pyx_v_ifst1->fst), (*__pyx_v_ifst2->fst), __pyx_v_delta, (&__pyx_v_error));

  /* "fst.pyx":1454
 *   cdef bool result, error
 *   result = Equivalent(deref(ifst1.fst), deref(ifst2.fst), delta, &error)
 *   if error:             # <<<<<<<<<<<<<<
 *     raise FstError("Equivalence test encountered error")
 *   return result
 */
  __pyx_t_1 = (__pyx_v_error != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":1455
 *   result = Equivalent(deref(ifst1.fst), deref(ifst2.fst), delta, &error)
 *   if error:
 *     raise FstError("Equivalence test encountered error")             # <<<<<<<<<<<<<<
 *   return result
 * 
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1455; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1455; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1455; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "fst.pyx":1456
 *   if error:
 *     raise FstError("Equivalence test encountered error")
 *   return result             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_result); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1432
 * 
 * 
 * def equivalent(_Fst ifst1, _Fst ifst2, float delta=kDelta):             # <<<<<<<<<<<<<<
 *   """Are the two acceptors equivalent?
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("fst.equivalent", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1459
 * 
 * 
 * def intersect(_Fst ifst1, _Fst ifst2, cf=b"auto", bool connect=True):             # <<<<<<<<<<<<<<
 *   """Constructively intersects two FSTs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_29intersect(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_28intersect[] = "Constructively intersects two FSTs.\n\n  This operation computes the intersection (Hadamard product) of two FSTs.\n  Only strings that are in both automata are retained in the result. The two\n  arguments must be acceptors. One of the arguments must be label-sorted (or\n  otherwise support appropriate matchers).\n\n  Args:\n    ifst1: The first input Fst.\n    ifst2: The second input Fst.\n    cf: A string matching a known composition filter.\n    connect: Should output be trimmed?\n\n  Returns:\n    An equivalent epsilon-normalized MutableFst.\n  ";
static PyMethodDef __pyx_mdef_3fst_29intersect = {"intersect", (PyCFunction)__pyx_pw_3fst_29intersect, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_28intersect};
static PyObject *__pyx_pw_3fst_29intersect(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst1 = 0;
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst2 = 0;
  PyObject *__pyx_v_cf = 0;
  bool __pyx_v_connect;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("intersect (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst1,&__pyx_n_s_ifst2,&__pyx_n_s_cf,&__pyx_n_s_connect,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)__pyx_n_b_auto);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("intersect", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1459; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cf);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_connect);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "intersect") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1459; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst1 = ((struct __pyx_obj_3fst__Fst *)values[0]);
    __pyx_v_ifst2 = ((struct __pyx_obj_3fst__Fst *)values[1]);
    __pyx_v_cf = values[2];
    if (values[3]) {
      __pyx_v_connect = __Pyx_PyObject_IsTrue(values[3]); if (unlikely((__pyx_v_connect == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1459; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_connect = ((bool)1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("intersect", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1459; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.intersect", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst1), __pyx_ptype_3fst__Fst, 1, "ifst1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst2), __pyx_ptype_3fst__Fst, 1, "ifst2", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_28intersect(__pyx_self, __pyx_v_ifst1, __pyx_v_ifst2, __pyx_v_cf, __pyx_v_connect);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_28intersect(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, PyObject *__pyx_v_cf, bool __pyx_v_connect) {
  fst::script::VectorFstClass *__pyx_v_tfst;
  fst::script::ComposeOptions const *__pyx_v_opts;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  enum fst::ComposeFilter __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("intersect", 0);

  /* "fst.pyx":1476
 *     An equivalent epsilon-normalized MutableFst.
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst1._arc_type)             # <<<<<<<<<<<<<<
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,
 *       _get_compose_filter(tobytes(cf)))
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst1), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1476; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1476; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_2);

  /* "fst.pyx":1478
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst1._arc_type)
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,
 *       _get_compose_filter(tobytes(cf)))             # <<<<<<<<<<<<<<
 *   Intersect(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))
 *   del opts
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_compose_filter); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_f_3fst_tobytes(__pyx_v_cf); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_5) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __Pyx_GIVEREF(__pyx_t_5); __pyx_t_5 = NULL;
    PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_7 = ((enum fst::ComposeFilter)PyInt_AsLong(__pyx_t_1)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1477
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst1._arc_type)
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,             # <<<<<<<<<<<<<<
 *       _get_compose_filter(tobytes(cf)))
 *   Intersect(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))
 */
  __pyx_v_opts = new fst::script::ComposeOptions(__pyx_v_connect, __pyx_t_7);

  /* "fst.pyx":1479
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,
 *       _get_compose_filter(tobytes(cf)))
 *   Intersect(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))             # <<<<<<<<<<<<<<
 *   del opts
 *   return _init_MutableFst(tfst)
 */
  fst::script::Intersect((*__pyx_v_ifst1->fst), (*__pyx_v_ifst2->fst), __pyx_v_tfst, (*__pyx_v_opts));

  /* "fst.pyx":1480
 *       _get_compose_filter(tobytes(cf)))
 *   Intersect(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))
 *   del opts             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  delete __pyx_v_opts;

  /* "fst.pyx":1481
 *   Intersect(deref(ifst1.fst), deref(ifst2.fst), tfst, deref(opts))
 *   del opts
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1481; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1459
 * 
 * 
 * def intersect(_Fst ifst1, _Fst ifst2, cf=b"auto", bool connect=True):             # <<<<<<<<<<<<<<
 *   """Constructively intersects two FSTs.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("fst.intersect", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1484
 * 
 * 
 * def isomorphic(_Fst ifst1, _Fst ifst2, float delta=kDelta):             # <<<<<<<<<<<<<<
 *   """Are the two acceptors isomorphic?
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_31isomorphic(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_30isomorphic[] = "Are the two acceptors isomorphic?\n\n  This operation determines if two transducers with a certain required\n  determinism have the same states, irrespective of numbering, and the same\n  transitions with the same labels and weights, irrespective of ordering. In\n  other words, FSTs A, B are isomorphic if and only if the states of A can be\n  renumbered and the transitions leaving each state reordered so the two are\n  equal (according to the definition given in `equal`).\n\n  Args:\n    ifst1: The first input Fst.\n    ifst2: The second input Fst.\n    delta: Comparison/quantization delta.\n\n  Returns:\n    True if the two transducers satisfy the above condition, else False.\n\n  Raises:\n    FstError.\n\n  See also: `equal`, `equivalent`, `randequivalent`.\n  ";
static PyMethodDef __pyx_mdef_3fst_31isomorphic = {"isomorphic", (PyCFunction)__pyx_pw_3fst_31isomorphic, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_30isomorphic};
static PyObject *__pyx_pw_3fst_31isomorphic(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst1 = 0;
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst2 = 0;
  float __pyx_v_delta;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isomorphic (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst1,&__pyx_n_s_ifst2,&__pyx_n_s_delta,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("isomorphic", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1484; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isomorphic") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1484; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst1 = ((struct __pyx_obj_3fst__Fst *)values[0]);
    __pyx_v_ifst2 = ((struct __pyx_obj_3fst__Fst *)values[1]);
    if (values[2]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[2]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1484; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__26;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isomorphic", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1484; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.isomorphic", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst1), __pyx_ptype_3fst__Fst, 1, "ifst1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst2), __pyx_ptype_3fst__Fst, 1, "ifst2", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_30isomorphic(__pyx_self, __pyx_v_ifst1, __pyx_v_ifst2, __pyx_v_delta);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_30isomorphic(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, float __pyx_v_delta) {
  bool __pyx_v_result;
  bool __pyx_v_error;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("isomorphic", 0);

  /* "fst.pyx":1508
 *   """
 *   cdef bool result, error
 *   result = Isomorphic(deref(ifst1.fst), deref(ifst2.fst), delta, &error)             # <<<<<<<<<<<<<<
 *   if error:
 *     raise FstError("Isomorphism test encountered error")
 */
  __pyx_v_result = fst::script::Isomorphic((*__pyx_v_ifst1->fst), (*__pyx_v_ifst2->fst), __pyx_v_delta, (&__pyx_v_error));

  /* "fst.pyx":1509
 *   cdef bool result, error
 *   result = Isomorphic(deref(ifst1.fst), deref(ifst2.fst), delta, &error)
 *   if error:             # <<<<<<<<<<<<<<
 *     raise FstError("Isomorphism test encountered error")
 *   return result
 */
  __pyx_t_1 = (__pyx_v_error != 0);
  if (__pyx_t_1) {

    /* "fst.pyx":1510
 *   result = Isomorphic(deref(ifst1.fst), deref(ifst2.fst), delta, &error)
 *   if error:
 *     raise FstError("Isomorphism test encountered error")             # <<<<<<<<<<<<<<
 *   return result
 * 
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1510; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1510; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1510; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "fst.pyx":1511
 *   if error:
 *     raise FstError("Isomorphism test encountered error")
 *   return result             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_result); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1511; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1484
 * 
 * 
 * def isomorphic(_Fst ifst1, _Fst ifst2, float delta=kDelta):             # <<<<<<<<<<<<<<
 *   """Are the two acceptors isomorphic?
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("fst.isomorphic", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1514
 * 
 * 
 * def prune(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId, weight=b""):             # <<<<<<<<<<<<<<
 *   """Constructively removes paths with weights below a certain threshold.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_33prune(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_32prune[] = "Constructively removes paths with weights below a certain threshold.\n\n  This operation deletes states and arcs in the input FST that do not belong\n  to a successful path whose weight is no more (w.r.t the natural semiring\n  order) than the threshold t \\otimes-times the weight of the shortest path in\n  the input FST. Weights must be commutative and have the path property.\n\n  Args:\n    ifst: The input Fst.\n    delta: Comparison/quantization delta.\n    nstate: State number threshold.\n    weight: A string representing a desired weight threshold; paths with weights\n        below this threshold will be pruned.\n\n  Returns:\n    A pruned MutableFst.\n\n  See also: The destructive variant (`pywrapfst.MutableFst.prune`).\n  ";
static PyMethodDef __pyx_mdef_3fst_33prune = {"prune", (PyCFunction)__pyx_pw_3fst_33prune, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_32prune};
static PyObject *__pyx_pw_3fst_33prune(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  float __pyx_v_delta;
  int64 __pyx_v_nstate;
  PyObject *__pyx_v_weight = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("prune (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst,&__pyx_n_s_delta,&__pyx_n_s_nstate,&__pyx_n_s_weight,0};
    PyObject* values[4] = {0,0,0,0};
    values[3] = ((PyObject *)__pyx_kp_b__5);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nstate);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_weight);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "prune") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1514; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)values[0]);
    if (values[1]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[1]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1514; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__28;
    }
    if (values[2]) {
      __pyx_v_nstate = __Pyx_PyInt_As_int64_t(values[2]); if (unlikely((__pyx_v_nstate == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1514; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_nstate = __pyx_k__29;
    }
    __pyx_v_weight = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("prune", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1514; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.prune", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_32prune(__pyx_self, __pyx_v_ifst, __pyx_v_delta, __pyx_v_nstate, __pyx_v_weight);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_32prune(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, int64 __pyx_v_nstate, PyObject *__pyx_v_weight) {
  fst::script::VectorFstClass *__pyx_v_tfst;
  fst::script::WeightClass __pyx_v_wc;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("prune", 0);

  /* "fst.pyx":1534
 *   See also: The destructive variant (`pywrapfst.MutableFst.prune`).
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)             # <<<<<<<<<<<<<<
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 *   Prune(deref(ifst.fst), tfst, wc, nstate, delta)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1534; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1534; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_2);

  /* "fst.pyx":1535
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))             # <<<<<<<<<<<<<<
 *   Prune(deref(ifst.fst), tfst, wc, nstate, delta)
 *   return _init_MutableFst(tfst)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_weight_type_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1535; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __pyx_f_3fst_tobytes(__pyx_v_weight); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1535; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_v_wc = __pyx_f_3fst__get_weight_class(__pyx_t_1, __pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "fst.pyx":1536
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 *   Prune(deref(ifst.fst), tfst, wc, nstate, delta)             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  fst::script::Prune((*__pyx_v_ifst->fst), __pyx_v_tfst, __pyx_v_wc, __pyx_v_nstate, __pyx_v_delta);

  /* "fst.pyx":1537
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 *   Prune(deref(ifst.fst), tfst, wc, nstate, delta)
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1537; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1514
 * 
 * 
 * def prune(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId, weight=b""):             # <<<<<<<<<<<<<<
 *   """Constructively removes paths with weights below a certain threshold.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("fst.prune", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1540
 * 
 * 
 * def push(_Fst ifst, float delta=kDelta, bool push_weights=False,             # <<<<<<<<<<<<<<
 *          bool push_labels=False, bool remove_common_affix=False,
 *          bool remove_total_weight=False, bool to_final=False):
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_35push(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_34push[] = "Constructively pushes weights/labels towards initial or final states.\n\n  This operation produces an equivalent transducer by pushing the weights\n  and/or the labels towards the initial state or toward the final states.\n\n  When pushing weights towards the initial state, the sum of the weight of the\n  outgoing transitions and final weight at any non-initial state is equal to 1\n  in the resulting machine. When pushing weights towards the final states, the\n  sum of the weight of the incoming transitions at any state is equal to 1.\n  Weights need to be left distributive when pushing towards the initial state\n  and right distributive when pushing towards the final states.\n\n  Pushing labels towards the initial state consists in minimizing at every\n  state the length of the longest common prefix of the output labels of the\n  outgoing paths. Pushing labels towards the final states consists in\n  minimizing at every state the length of the longest common suffix of the\n  output labels of the incoming paths.\n\n  Args:\n    ifst: The input Fst.\n    delta: Comparison/quantization delta.\n    push_weights: Should weights be pushed?\n    push_labels: Should labels be pushed?\n    remove_common_affix: If pushing labels, should common prefix/suffix be\n        removed?\n    remove_total_weight: If pushing weights, should total weight be removed?\n    to_final: Push towards final states?\n\n  Returns:\n    An equivalent pushed MutableFst.\n\n  See also: The destructive variant (`pywrapfst.MutableFst.push`).\n  ";
static PyMethodDef __pyx_mdef_3fst_35push = {"push", (PyCFunction)__pyx_pw_3fst_35push, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_34push};
static PyObject *__pyx_pw_3fst_35push(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  float __pyx_v_delta;
  bool __pyx_v_push_weights;
  bool __pyx_v_push_labels;
  bool __pyx_v_remove_common_affix;
  bool __pyx_v_remove_total_weight;
  bool __pyx_v_to_final;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("push (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst,&__pyx_n_s_delta,&__pyx_n_s_push_weights,&__pyx_n_s_push_labels,&__pyx_n_s_remove_common_affix,&__pyx_n_s_remove_total_weight,&__pyx_n_s_to_final,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_push_weights);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_push_labels);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_remove_common_affix);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_remove_total_weight);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_to_final);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "push") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1540; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)values[0]);
    if (values[1]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[1]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1540; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__30;
    }
    if (values[2]) {
      __pyx_v_push_weights = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_push_weights == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1540; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_push_weights = ((bool)0);
    }
    if (values[3]) {
      __pyx_v_push_labels = __Pyx_PyObject_IsTrue(values[3]); if (unlikely((__pyx_v_push_labels == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1541; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "fst.pyx":1541
 * 
 * def push(_Fst ifst, float delta=kDelta, bool push_weights=False,
 *          bool push_labels=False, bool remove_common_affix=False,             # <<<<<<<<<<<<<<
 *          bool remove_total_weight=False, bool to_final=False):
 *   """Constructively pushes weights/labels towards initial or final states.
 */
      __pyx_v_push_labels = ((bool)0);
    }
    if (values[4]) {
      __pyx_v_remove_common_affix = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_remove_common_affix == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1541; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_remove_common_affix = ((bool)0);
    }
    if (values[5]) {
      __pyx_v_remove_total_weight = __Pyx_PyObject_IsTrue(values[5]); if (unlikely((__pyx_v_remove_total_weight == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1542; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "fst.pyx":1542
 * def push(_Fst ifst, float delta=kDelta, bool push_weights=False,
 *          bool push_labels=False, bool remove_common_affix=False,
 *          bool remove_total_weight=False, bool to_final=False):             # <<<<<<<<<<<<<<
 *   """Constructively pushes weights/labels towards initial or final states.
 * 
 */
      __pyx_v_remove_total_weight = ((bool)0);
    }
    if (values[6]) {
      __pyx_v_to_final = __Pyx_PyObject_IsTrue(values[6]); if (unlikely((__pyx_v_to_final == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1542; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_to_final = ((bool)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("push", 0, 1, 7, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1540; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.push", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_34push(__pyx_self, __pyx_v_ifst, __pyx_v_delta, __pyx_v_push_weights, __pyx_v_push_labels, __pyx_v_remove_common_affix, __pyx_v_remove_total_weight, __pyx_v_to_final);

  /* "fst.pyx":1540
 * 
 * 
 * def push(_Fst ifst, float delta=kDelta, bool push_weights=False,             # <<<<<<<<<<<<<<
 *          bool push_labels=False, bool remove_common_affix=False,
 *          bool remove_total_weight=False, bool to_final=False):
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_34push(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, bool __pyx_v_push_weights, bool __pyx_v_push_labels, bool __pyx_v_remove_common_affix, bool __pyx_v_remove_total_weight, bool __pyx_v_to_final) {
  fst::script::VectorFstClass *__pyx_v_tfst;
  uint32 __pyx_v_flags;
  enum fst::ReweightType __pyx_v_rt;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  int __pyx_t_3;
  enum fst::ReweightType __pyx_t_4;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("push", 0);

  /* "fst.pyx":1577
 *   """
 *   # This is copied, almost verbatim, from ./fstpush.cc.
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)             # <<<<<<<<<<<<<<
 *   cdef uint32 flags = 0
 *   if push_weights:
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_2);

  /* "fst.pyx":1578
 *   # This is copied, almost verbatim, from ./fstpush.cc.
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   cdef uint32 flags = 0             # <<<<<<<<<<<<<<
 *   if push_weights:
 *     flags |= kPushWeights
 */
  __pyx_v_flags = 0;

  /* "fst.pyx":1579
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   cdef uint32 flags = 0
 *   if push_weights:             # <<<<<<<<<<<<<<
 *     flags |= kPushWeights
 *   if push_labels:
 */
  __pyx_t_3 = (__pyx_v_push_weights != 0);
  if (__pyx_t_3) {

    /* "fst.pyx":1580
 *   cdef uint32 flags = 0
 *   if push_weights:
 *     flags |= kPushWeights             # <<<<<<<<<<<<<<
 *   if push_labels:
 *     flags |= kPushLabels
 */
    __pyx_v_flags = (__pyx_v_flags | fst::kPushWeights);
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "fst.pyx":1581
 *   if push_weights:
 *     flags |= kPushWeights
 *   if push_labels:             # <<<<<<<<<<<<<<
 *     flags |= kPushLabels
 *   if remove_common_affix:
 */
  __pyx_t_3 = (__pyx_v_push_labels != 0);
  if (__pyx_t_3) {

    /* "fst.pyx":1582
 *     flags |= kPushWeights
 *   if push_labels:
 *     flags |= kPushLabels             # <<<<<<<<<<<<<<
 *   if remove_common_affix:
 *     flags |= kPushRemoveCommonAffix
 */
    __pyx_v_flags = (__pyx_v_flags | fst::kPushLabels);
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "fst.pyx":1583
 *   if push_labels:
 *     flags |= kPushLabels
 *   if remove_common_affix:             # <<<<<<<<<<<<<<
 *     flags |= kPushRemoveCommonAffix
 *   if remove_total_weight:
 */
  __pyx_t_3 = (__pyx_v_remove_common_affix != 0);
  if (__pyx_t_3) {

    /* "fst.pyx":1584
 *     flags |= kPushLabels
 *   if remove_common_affix:
 *     flags |= kPushRemoveCommonAffix             # <<<<<<<<<<<<<<
 *   if remove_total_weight:
 *     flags |= kPushRemoveTotalWeight
 */
    __pyx_v_flags = (__pyx_v_flags | fst::kPushRemoveCommonAffix);
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "fst.pyx":1585
 *   if remove_common_affix:
 *     flags |= kPushRemoveCommonAffix
 *   if remove_total_weight:             # <<<<<<<<<<<<<<
 *     flags |= kPushRemoveTotalWeight
 *   cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else
 */
  __pyx_t_3 = (__pyx_v_remove_total_weight != 0);
  if (__pyx_t_3) {

    /* "fst.pyx":1586
 *     flags |= kPushRemoveCommonAffix
 *   if remove_total_weight:
 *     flags |= kPushRemoveTotalWeight             # <<<<<<<<<<<<<<
 *   cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else
 *                           REWEIGHT_TO_INITIAL)
 */
    __pyx_v_flags = (__pyx_v_flags | fst::kPushRemoveTotalWeight);
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "fst.pyx":1587
 *   if remove_total_weight:
 *     flags |= kPushRemoveTotalWeight
 *   cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else             # <<<<<<<<<<<<<<
 *                           REWEIGHT_TO_INITIAL)
 *   Push(deref(ifst.fst), tfst, flags, rt, delta)
 */
  if ((__pyx_v_to_final != 0)) {
    __pyx_t_4 = fst::REWEIGHT_TO_FINAL;
  } else {

    /* "fst.pyx":1588
 *     flags |= kPushRemoveTotalWeight
 *   cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else
 *                           REWEIGHT_TO_INITIAL)             # <<<<<<<<<<<<<<
 *   Push(deref(ifst.fst), tfst, flags, rt, delta)
 *   return _init_MutableFst(tfst)
 */
    __pyx_t_4 = fst::REWEIGHT_TO_INITIAL;
  }
  __pyx_v_rt = __pyx_t_4;

  /* "fst.pyx":1589
 *   cdef ReweightType rt = (REWEIGHT_TO_FINAL if to_final else
 *                           REWEIGHT_TO_INITIAL)
 *   Push(deref(ifst.fst), tfst, flags, rt, delta)             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  fst::script::Push((*__pyx_v_ifst->fst), __pyx_v_tfst, __pyx_v_flags, __pyx_v_rt, __pyx_v_delta);

  /* "fst.pyx":1590
 *                           REWEIGHT_TO_INITIAL)
 *   Push(deref(ifst.fst), tfst, flags, rt, delta)
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1590; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1540
 * 
 * 
 * def push(_Fst ifst, float delta=kDelta, bool push_weights=False,             # <<<<<<<<<<<<<<
 *          bool push_labels=False, bool remove_common_affix=False,
 *          bool remove_total_weight=False, bool to_final=False):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst.push", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1593
 * 
 * 
 * def randequivalent(_Fst ifst1, _Fst ifst2, float delta=kDelta,             # <<<<<<<<<<<<<<
 *                    int32 max_length=INT_MAX, int32 npath=1,
 *                    int32 seed=time(NULL), select=b"uniform"):
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_37randequivalent(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_36randequivalent[] = "Are two acceptors stochastically equivalent?\n\n  This operation tests whether two FSTs are equivalent by randomly generating\n  paths alternatively in each of the two FSTs. For each randomly generated path,\n  the algorithm computes for each of the two FSTs the sum of the weights of all\n  the successful paths sharing the same input and output labels as the randomly\n  generated path and checks that these two values are within `delta`.\n\n  Args:\n    ifst1: The first input Fst.\n    ifst2: The second input Fst.\n    delta: Comparison/quantization delta.\n    max_length: The maximum length of each random path.\n    npath: The number of random paths to generate.\n    seed: An optional seed value for random path generation.\n    select: A string matching a known RandArcSelection method.\n\n  Returns:\n    True if the two transducers satisfy the above condition, else False.\n\n  See also: `equal`, `equivalent`, `isomorphic`, `randgen`.\n  ";
static PyMethodDef __pyx_mdef_3fst_37randequivalent = {"randequivalent", (PyCFunction)__pyx_pw_3fst_37randequivalent, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_36randequivalent};
static PyObject *__pyx_pw_3fst_37randequivalent(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst1 = 0;
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst2 = 0;
  float __pyx_v_delta;
  int32 __pyx_v_max_length;
  int32 __pyx_v_npath;
  int32 __pyx_v_seed;
  PyObject *__pyx_v_select = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("randequivalent (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst1,&__pyx_n_s_ifst2,&__pyx_n_s_delta,&__pyx_n_s_max_length,&__pyx_n_s_npath,&__pyx_n_s_seed,&__pyx_n_s_select,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};
    values[6] = ((PyObject *)__pyx_n_b_uniform);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("randequivalent", 0, 2, 7, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1593; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_max_length);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_npath);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_seed);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_select);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "randequivalent") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1593; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst1 = ((struct __pyx_obj_3fst__Fst *)values[0]);
    __pyx_v_ifst2 = ((struct __pyx_obj_3fst__Fst *)values[1]);
    if (values[2]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[2]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1593; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__31;
    }
    if (values[3]) {
      __pyx_v_max_length = __Pyx_PyInt_As_int32_t(values[3]); if (unlikely((__pyx_v_max_length == (int32)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1594; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_max_length = __pyx_k__32;
    }
    if (values[4]) {
      __pyx_v_npath = __Pyx_PyInt_As_int32_t(values[4]); if (unlikely((__pyx_v_npath == (int32)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1594; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_npath = ((int32)1);
    }
    if (values[5]) {
      __pyx_v_seed = __Pyx_PyInt_As_int32_t(values[5]); if (unlikely((__pyx_v_seed == (int32)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1595; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_seed = __pyx_k__33;
    }
    __pyx_v_select = values[6];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("randequivalent", 0, 2, 7, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1593; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.randequivalent", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst1), __pyx_ptype_3fst__Fst, 1, "ifst1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1593; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst2), __pyx_ptype_3fst__Fst, 1, "ifst2", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1593; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_36randequivalent(__pyx_self, __pyx_v_ifst1, __pyx_v_ifst2, __pyx_v_delta, __pyx_v_max_length, __pyx_v_npath, __pyx_v_seed, __pyx_v_select);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_36randequivalent(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst1, struct __pyx_obj_3fst__Fst *__pyx_v_ifst2, float __pyx_v_delta, int32 __pyx_v_max_length, int32 __pyx_v_npath, int32 __pyx_v_seed, PyObject *__pyx_v_select) {
  enum fst::script::RandArcSelection __pyx_v_ras;
  fst::RandGenOptions<enum fst::script::RandArcSelection>  const *__pyx_v_opts;
  bool __pyx_v_result;
  bool __pyx_v_error;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  enum fst::script::RandArcSelection __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  int __pyx_t_9;
  char const *__pyx_t_10;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  PyObject *__pyx_t_16 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("randequivalent", 0);

  /* "fst.pyx":1618
 *   See also: `equal`, `equivalent`, `isomorphic`, `randgen`.
 *   """
 *   cdef RandArcSelection ras = _get_rand_arc_selection(tobytes(select))             # <<<<<<<<<<<<<<
 *   cdef const RandGenOptions[RandArcSelection] *opts
 *   opts = new RandGenOptions[RandArcSelection](ras, max_length)
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_rand_arc_selection); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __pyx_f_3fst_tobytes(__pyx_v_select); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __Pyx_GIVEREF(__pyx_t_4); __pyx_t_4 = NULL;
    PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_6 = ((enum fst::script::RandArcSelection)PyInt_AsLong(__pyx_t_1)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_ras = __pyx_t_6;

  /* "fst.pyx":1620
 *   cdef RandArcSelection ras = _get_rand_arc_selection(tobytes(select))
 *   cdef const RandGenOptions[RandArcSelection] *opts
 *   opts = new RandGenOptions[RandArcSelection](ras, max_length)             # <<<<<<<<<<<<<<
 *   cdef bool result, error
 *   result = RandEquivalent(deref(ifst1.fst), deref(ifst2.fst), seed, npath,
 */
  __pyx_v_opts = new fst::RandGenOptions<enum fst::script::RandArcSelection> (__pyx_v_ras, __pyx_v_max_length);

  /* "fst.pyx":1622
 *   opts = new RandGenOptions[RandArcSelection](ras, max_length)
 *   cdef bool result, error
 *   result = RandEquivalent(deref(ifst1.fst), deref(ifst2.fst), seed, npath,             # <<<<<<<<<<<<<<
 *       delta, deref(opts), &error)
 *   try:
 */
  __pyx_v_result = fst::script::RandEquivalent((*__pyx_v_ifst1->fst), (*__pyx_v_ifst2->fst), __pyx_v_seed, __pyx_v_npath, __pyx_v_delta, (*__pyx_v_opts), (&__pyx_v_error));

  /* "fst.pyx":1624
 *   result = RandEquivalent(deref(ifst1.fst), deref(ifst2.fst), seed, npath,
 *       delta, deref(opts), &error)
 *   try:             # <<<<<<<<<<<<<<
 *     if error:
 *       raise FstError("Random equivalence test encountered error")
 */
  /*try:*/ {

    /* "fst.pyx":1625
 *       delta, deref(opts), &error)
 *   try:
 *     if error:             # <<<<<<<<<<<<<<
 *       raise FstError("Random equivalence test encountered error")
 *   finally:
 */
    __pyx_t_7 = (__pyx_v_error != 0);
    if (__pyx_t_7) {

      /* "fst.pyx":1626
 *   try:
 *     if error:
 *       raise FstError("Random equivalence test encountered error")             # <<<<<<<<<<<<<<
 *   finally:
 *     del opts
 */
      __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1626; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__34, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1626; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1626; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
    }
  }

  /* "fst.pyx":1628
 *       raise FstError("Random equivalence test encountered error")
 *   finally:
 *     del opts             # <<<<<<<<<<<<<<
 *   return result
 * 
 */
  /*finally:*/ {
    /*normal exit:*/{
      delete __pyx_v_opts;
      goto __pyx_L5;
    }
    /*exception exit:*/{
      __pyx_L4_error:;
      __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_14, &__pyx_t_15, &__pyx_t_16);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13) < 0)) __Pyx_ErrFetch(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13);
      __Pyx_XGOTREF(__pyx_t_11);
      __Pyx_XGOTREF(__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_13);
      __Pyx_XGOTREF(__pyx_t_14);
      __Pyx_XGOTREF(__pyx_t_15);
      __Pyx_XGOTREF(__pyx_t_16);
      __pyx_t_8 = __pyx_lineno; __pyx_t_9 = __pyx_clineno; __pyx_t_10 = __pyx_filename;
      {
        delete __pyx_v_opts;
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_14);
        __Pyx_XGIVEREF(__pyx_t_15);
        __Pyx_XGIVEREF(__pyx_t_16);
        __Pyx_ExceptionReset(__pyx_t_14, __pyx_t_15, __pyx_t_16);
      }
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_XGIVEREF(__pyx_t_12);
      __Pyx_XGIVEREF(__pyx_t_13);
      __Pyx_ErrRestore(__pyx_t_11, __pyx_t_12, __pyx_t_13);
      __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0;
      __pyx_lineno = __pyx_t_8; __pyx_clineno = __pyx_t_9; __pyx_filename = __pyx_t_10;
      goto __pyx_L1_error;
    }
    __pyx_L5:;
  }

  /* "fst.pyx":1629
 *   finally:
 *     del opts
 *   return result             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_result); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1629; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1593
 * 
 * 
 * def randequivalent(_Fst ifst1, _Fst ifst2, float delta=kDelta,             # <<<<<<<<<<<<<<
 *                    int32 max_length=INT_MAX, int32 npath=1,
 *                    int32 seed=time(NULL), select=b"uniform"):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("fst.randequivalent", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1632
 * 
 * 
 * def randgen(_Fst ifst, int32 max_length=INT_MAX, int32 npath=1,             # <<<<<<<<<<<<<<
 *             bool remove_total_weight=False, int32 seed=time(NULL),
 *             select=b"uniform", bool weighted=False):
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_39randgen(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_38randgen[] = "Randomly generate successful paths in an FST.\n\n  This operation randomly generates a set of successful paths in the input FST.\n  This relies on a mechanism for selecting arcs, specified using the `select`\n  argument. The default selector, \"uniform\", randomly selects a transition\n  using a uniform distribution. The \"log_prob\" selector randomly selects a\n  transition w.r.t. the weights treated as negative log probabilities after\n  normalizing for the total weight leaving the state. In all cases, finality is\n  treated as a transition to a super-final state.\n\n  Args:\n    ifst: The input Fst.\n    max_length: The maximum length of each random path.\n    npath: The number of random paths to generate.\n    remove_total_weight: Should the total weight be removed (ignored when\n        `weighted` is False)?\n    seed: An optional seed value for random path generation.\n    select: A string matching a known RandArcSelection method.\n    weighted: Should the output be weighted by path count?\n\n  Returns:\n    An Fst containing one or more random paths.\n\n  See also: `randequivalent`.\n  ";
static PyMethodDef __pyx_mdef_3fst_39randgen = {"randgen", (PyCFunction)__pyx_pw_3fst_39randgen, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_38randgen};
static PyObject *__pyx_pw_3fst_39randgen(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  int32 __pyx_v_max_length;
  CYTHON_UNUSED int32 __pyx_v_npath;
  CYTHON_UNUSED bool __pyx_v_remove_total_weight;
  int32 __pyx_v_seed;
  PyObject *__pyx_v_select = 0;
  CYTHON_UNUSED bool __pyx_v_weighted;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("randgen (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst,&__pyx_n_s_max_length,&__pyx_n_s_npath,&__pyx_n_s_remove_total_weight,&__pyx_n_s_seed,&__pyx_n_s_select,&__pyx_n_s_weighted,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};
    values[5] = ((PyObject *)__pyx_n_b_uniform);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_max_length);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_npath);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_remove_total_weight);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_seed);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_select);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_weighted);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "randgen") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1632; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)values[0]);
    if (values[1]) {
      __pyx_v_max_length = __Pyx_PyInt_As_int32_t(values[1]); if (unlikely((__pyx_v_max_length == (int32)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1632; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_max_length = __pyx_k__35;
    }
    if (values[2]) {
      __pyx_v_npath = __Pyx_PyInt_As_int32_t(values[2]); if (unlikely((__pyx_v_npath == (int32)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1632; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_npath = ((int32)1);
    }
    if (values[3]) {
      __pyx_v_remove_total_weight = __Pyx_PyObject_IsTrue(values[3]); if (unlikely((__pyx_v_remove_total_weight == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1633; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "fst.pyx":1633
 * 
 * def randgen(_Fst ifst, int32 max_length=INT_MAX, int32 npath=1,
 *             bool remove_total_weight=False, int32 seed=time(NULL),             # <<<<<<<<<<<<<<
 *             select=b"uniform", bool weighted=False):
 *   """Randomly generate successful paths in an FST.
 */
      __pyx_v_remove_total_weight = ((bool)0);
    }
    if (values[4]) {
      __pyx_v_seed = __Pyx_PyInt_As_int32_t(values[4]); if (unlikely((__pyx_v_seed == (int32)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1633; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_seed = __pyx_k__36;
    }
    __pyx_v_select = values[5];
    if (values[6]) {
      __pyx_v_weighted = __Pyx_PyObject_IsTrue(values[6]); if (unlikely((__pyx_v_weighted == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1634; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "fst.pyx":1634
 * def randgen(_Fst ifst, int32 max_length=INT_MAX, int32 npath=1,
 *             bool remove_total_weight=False, int32 seed=time(NULL),
 *             select=b"uniform", bool weighted=False):             # <<<<<<<<<<<<<<
 *   """Randomly generate successful paths in an FST.
 * 
 */
      __pyx_v_weighted = ((bool)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("randgen", 0, 1, 7, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1632; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.randgen", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_38randgen(__pyx_self, __pyx_v_ifst, __pyx_v_max_length, __pyx_v_npath, __pyx_v_remove_total_weight, __pyx_v_seed, __pyx_v_select, __pyx_v_weighted);

  /* "fst.pyx":1632
 * 
 * 
 * def randgen(_Fst ifst, int32 max_length=INT_MAX, int32 npath=1,             # <<<<<<<<<<<<<<
 *             bool remove_total_weight=False, int32 seed=time(NULL),
 *             select=b"uniform", bool weighted=False):
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_38randgen(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, int32 __pyx_v_max_length, CYTHON_UNUSED int32 __pyx_v_npath, CYTHON_UNUSED bool __pyx_v_remove_total_weight, int32 __pyx_v_seed, PyObject *__pyx_v_select, CYTHON_UNUSED bool __pyx_v_weighted) {
  enum fst::script::RandArcSelection __pyx_v_ras;
  fst::RandGenOptions<enum fst::script::RandArcSelection>  const *__pyx_v_opts;
  fst::script::VectorFstClass *__pyx_v_tfst;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  enum fst::script::RandArcSelection __pyx_t_6;
  std::string __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("randgen", 0);

  /* "fst.pyx":1660
 *   See also: `randequivalent`.
 *   """
 *   cdef RandArcSelection ras = _get_rand_arc_selection(tobytes(select))             # <<<<<<<<<<<<<<
 *   cdef const RandGenOptions[RandArcSelection] *opts
 *   opts = new RandGenOptions[RandArcSelection](ras, max_length)
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_rand_arc_selection); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __pyx_f_3fst_tobytes(__pyx_v_select); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __Pyx_GIVEREF(__pyx_t_4); __pyx_t_4 = NULL;
    PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_6 = ((enum fst::script::RandArcSelection)PyInt_AsLong(__pyx_t_1)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_ras = __pyx_t_6;

  /* "fst.pyx":1662
 *   cdef RandArcSelection ras = _get_rand_arc_selection(tobytes(select))
 *   cdef const RandGenOptions[RandArcSelection] *opts
 *   opts = new RandGenOptions[RandArcSelection](ras, max_length)             # <<<<<<<<<<<<<<
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   RandGen(deref(ifst.fst), tfst, seed, deref(opts))
 */
  __pyx_v_opts = new fst::RandGenOptions<enum fst::script::RandArcSelection> (__pyx_v_ras, __pyx_v_max_length);

  /* "fst.pyx":1663
 *   cdef const RandGenOptions[RandArcSelection] *opts
 *   opts = new RandGenOptions[RandArcSelection](ras, max_length)
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)             # <<<<<<<<<<<<<<
 *   RandGen(deref(ifst.fst), tfst, seed, deref(opts))
 *   del opts
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1663; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_7 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1663; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_7);

  /* "fst.pyx":1664
 *   opts = new RandGenOptions[RandArcSelection](ras, max_length)
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   RandGen(deref(ifst.fst), tfst, seed, deref(opts))             # <<<<<<<<<<<<<<
 *   del opts
 *   return _init_MutableFst(tfst)
 */
  fst::script::RandGen((*__pyx_v_ifst->fst), __pyx_v_tfst, __pyx_v_seed, (*__pyx_v_opts));

  /* "fst.pyx":1665
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   RandGen(deref(ifst.fst), tfst, seed, deref(opts))
 *   del opts             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  delete __pyx_v_opts;

  /* "fst.pyx":1666
 *   RandGen(deref(ifst.fst), tfst, seed, deref(opts))
 *   del opts
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1666; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1632
 * 
 * 
 * def randgen(_Fst ifst, int32 max_length=INT_MAX, int32 npath=1,             # <<<<<<<<<<<<<<
 *             bool remove_total_weight=False, int32 seed=time(NULL),
 *             select=b"uniform", bool weighted=False):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("fst.randgen", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1669
 * 
 * 
 * def replace(pairs, call_arc_labeling=b"input", return_arc_labeling=b"neither",             # <<<<<<<<<<<<<<
 *             bool epsilon_on_replace=False, int64 return_label=0):
 *   """Recursively replaces arcs in the FST with other FST(s).
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_41replace(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_40replace[] = "Recursively replaces arcs in the FST with other FST(s).\n\n  This operation performs the dynamic replacement of arcs in one FST with\n  another FST, allowing the definition of FSTs analogous to RTNs. It takes as\n  input a set of pairs of a set of pairs formed by a non-terminal label and\n  its corresponding FST, and a label identifying the root FST in that set.\n  The resulting FST is obtained by taking the root FST and recursively replacing\n  each arc having a nonterminal as output label by its corresponding FST. More\n  precisely, an arc from state s to state d with (nonterminal) output label n in\n  this FST is replaced by redirecting this \"call\" arc to the initial state of a\n  copy F of the FST for n, and adding \"return\" arcs from each final state of F\n  to d. Optional arguments control how the call and return arcs are labeled; by\n  default, the only non-epsilon label is placed on the call arc.\n\n  Args:\n\n    pairs: An iterable of (nonterminal label, FST) pairs, where the former is an\n        unsigned integer and the latter is an Fst instance.\n    call_arc_labeling: A string indicating which call arc labels should be\n        non-epsilon. One of: \"input\" (default), \"output\", \"both\", \"neither\".\n        This value is set to \"neither\" if epsilon_on_replace is True.\n    return_arc_labeling: A string indicating which return arc labels should be\n        non-epsilon. One of: \"input\", \"output\", \"both\", \"neither\" (default).\n        This value is set to \"neither\" if epsilon_on_replace is True.\n    epsilon_on_replace: Should call and return arcs be epsilon arcs? If True,\n        this effectively overrides call_arc_labeling and return_arc_labeling,\n        setting both to \"neither\".\n    return_label: The integer label for return arcs.\n  ";
static PyMethodDef __pyx_mdef_3fst_41replace = {"replace", (PyCFunction)__pyx_pw_3fst_41replace, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_40replace};
static PyObject *__pyx_pw_3fst_41replace(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_pairs = 0;
  PyObject *__pyx_v_call_arc_labeling = 0;
  PyObject *__pyx_v_return_arc_labeling = 0;
  bool __pyx_v_epsilon_on_replace;
  int64 __pyx_v_return_label;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("replace (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pairs,&__pyx_n_s_call_arc_labeling,&__pyx_n_s_return_arc_labeling,&__pyx_n_s_epsilon_on_replace,&__pyx_n_s_return_label,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[1] = ((PyObject *)__pyx_n_b_input);
    values[2] = ((PyObject *)__pyx_n_b_neither);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_pairs)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_call_arc_labeling);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_return_arc_labeling);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_epsilon_on_replace);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_return_label);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "replace") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_pairs = values[0];
    __pyx_v_call_arc_labeling = values[1];
    __pyx_v_return_arc_labeling = values[2];
    if (values[3]) {
      __pyx_v_epsilon_on_replace = __Pyx_PyObject_IsTrue(values[3]); if (unlikely((__pyx_v_epsilon_on_replace == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1670; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "fst.pyx":1670
 * 
 * def replace(pairs, call_arc_labeling=b"input", return_arc_labeling=b"neither",
 *             bool epsilon_on_replace=False, int64 return_label=0):             # <<<<<<<<<<<<<<
 *   """Recursively replaces arcs in the FST with other FST(s).
 * 
 */
      __pyx_v_epsilon_on_replace = ((bool)0);
    }
    if (values[4]) {
      __pyx_v_return_label = __Pyx_PyInt_As_int64_t(values[4]); if (unlikely((__pyx_v_return_label == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1670; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_return_label = ((int64)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("replace", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.replace", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_3fst_40replace(__pyx_self, __pyx_v_pairs, __pyx_v_call_arc_labeling, __pyx_v_return_arc_labeling, __pyx_v_epsilon_on_replace, __pyx_v_return_label);

  /* "fst.pyx":1669
 * 
 * 
 * def replace(pairs, call_arc_labeling=b"input", return_arc_labeling=b"neither",             # <<<<<<<<<<<<<<
 *             bool epsilon_on_replace=False, int64 return_label=0):
 *   """Recursively replaces arcs in the FST with other FST(s).
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_40replace(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_pairs, PyObject *__pyx_v_call_arc_labeling, PyObject *__pyx_v_return_arc_labeling, bool __pyx_v_epsilon_on_replace, int64 __pyx_v_return_label) {
  std::vector<__pyx_t_3fst_FstTuple>  __pyx_v__pairs;
  int64 __pyx_v_root_label;
  int64 __pyx_v_label;
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  PyObject *__pyx_v_it = NULL;
  fst::script::VectorFstClass *__pyx_v_tfst;
  enum fst::ReplaceLabelType __pyx_v_cal;
  enum fst::ReplaceLabelType __pyx_v_ral;
  fst::script::ReplaceOptions const *__pyx_v_opts;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *(*__pyx_t_5)(PyObject *);
  int64 __pyx_t_6;
  __pyx_t_3fst_FstTuple __pyx_t_7;
  std::string __pyx_t_8;
  Py_ssize_t __pyx_t_9;
  PyObject *(*__pyx_t_10)(PyObject *);
  PyObject *__pyx_t_11 = NULL;
  bool __pyx_t_12;
  enum fst::ReplaceLabelType __pyx_t_13;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("replace", 0);
  __Pyx_INCREF(__pyx_v_call_arc_labeling);
  __Pyx_INCREF(__pyx_v_return_arc_labeling);

  /* "fst.pyx":1704
 *   cdef int64 root_label, label
 *   cdef _Fst ifst
 *   it = iter(pairs)             # <<<<<<<<<<<<<<
 *   (root_label, ifst) = next(it)
 *   _pairs.push_back(FstTuple(root_label, ifst.fst))
 */
  __pyx_t_1 = PyObject_GetIter(__pyx_v_pairs); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_it = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "fst.pyx":1705
 *   cdef _Fst ifst
 *   it = iter(pairs)
 *   (root_label, ifst) = next(it)             # <<<<<<<<<<<<<<
 *   _pairs.push_back(FstTuple(root_label, ifst.fst))
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 */
  __pyx_t_1 = __Pyx_PyIter_Next(__pyx_v_it); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
    PyObject* sequence = __pyx_t_1;
    #if CYTHON_COMPILING_IN_CPYTHON
    Py_ssize_t size = Py_SIZE(sequence);
    #else
    Py_ssize_t size = PySequence_Size(sequence);
    #endif
    if (unlikely(size != 2)) {
      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    #if CYTHON_COMPILING_IN_CPYTHON
    if (likely(PyTuple_CheckExact(sequence))) {
      __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
    } else {
      __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
    }
    __Pyx_INCREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_t_3);
    #else
    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  } else {
    Py_ssize_t index = -1;
    __pyx_t_4 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_5 = Py_TYPE(__pyx_t_4)->tp_iternext;
    index = 0; __pyx_t_2 = __pyx_t_5(__pyx_t_4); if (unlikely(!__pyx_t_2)) goto __pyx_L3_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_2);
    index = 1; __pyx_t_3 = __pyx_t_5(__pyx_t_4); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_3);
    if (__Pyx_IternextUnpackEndCheck(__pyx_t_5(__pyx_t_4), 2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_5 = NULL;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L4_unpacking_done;
    __pyx_L3_unpacking_failed:;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_5 = NULL;
    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_L4_unpacking_done:;
  }
  __pyx_t_6 = __Pyx_PyInt_As_int64_t(__pyx_t_2); if (unlikely((__pyx_t_6 == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_3fst__Fst))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_root_label = __pyx_t_6;
  __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "fst.pyx":1706
 *   it = iter(pairs)
 *   (root_label, ifst) = next(it)
 *   _pairs.push_back(FstTuple(root_label, ifst.fst))             # <<<<<<<<<<<<<<
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   for (label, ifst) in it:
 */
  try {
    __pyx_t_7 = __pyx_t_3fst_FstTuple(__pyx_v_root_label, __pyx_v_ifst->fst);
  } catch(...) {
    __Pyx_CppExn2PyErr();
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1706; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_v__pairs.push_back(__pyx_t_7);

  /* "fst.pyx":1707
 *   (root_label, ifst) = next(it)
 *   _pairs.push_back(FstTuple(root_label, ifst.fst))
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)             # <<<<<<<<<<<<<<
 *   for (label, ifst) in it:
 *     _pairs.push_back(FstTuple(label, ifst.fst))
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1707; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_8 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1707; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_8);

  /* "fst.pyx":1708
 *   _pairs.push_back(FstTuple(root_label, ifst.fst))
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   for (label, ifst) in it:             # <<<<<<<<<<<<<<
 *     _pairs.push_back(FstTuple(label, ifst.fst))
 *   call_arc_labeling = tobytes(call_arc_labeling)
 */
  if (likely(PyList_CheckExact(__pyx_v_it)) || PyTuple_CheckExact(__pyx_v_it)) {
    __pyx_t_1 = __pyx_v_it; __Pyx_INCREF(__pyx_t_1); __pyx_t_9 = 0;
    __pyx_t_10 = NULL;
  } else {
    __pyx_t_9 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_it); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_10 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  for (;;) {
    if (likely(!__pyx_t_10)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_9); __Pyx_INCREF(__pyx_t_3); __pyx_t_9++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        #else
        __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        #endif
      } else {
        if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_9); __Pyx_INCREF(__pyx_t_3); __pyx_t_9++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        #else
        __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        #endif
      }
    } else {
      __pyx_t_3 = __pyx_t_10(__pyx_t_1);
      if (unlikely(!__pyx_t_3)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_3);
    }
    if ((likely(PyTuple_CheckExact(__pyx_t_3))) || (PyList_CheckExact(__pyx_t_3))) {
      PyObject* sequence = __pyx_t_3;
      #if CYTHON_COMPILING_IN_CPYTHON
      Py_ssize_t size = Py_SIZE(sequence);
      #else
      Py_ssize_t size = PySequence_Size(sequence);
      #endif
      if (unlikely(size != 2)) {
        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      }
      #if CYTHON_COMPILING_IN_CPYTHON
      if (likely(PyTuple_CheckExact(sequence))) {
        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
      } else {
        __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
        __pyx_t_4 = PyList_GET_ITEM(sequence, 1); 
      }
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      #else
      __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      #endif
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else {
      Py_ssize_t index = -1;
      __pyx_t_11 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_11);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_5 = Py_TYPE(__pyx_t_11)->tp_iternext;
      index = 0; __pyx_t_2 = __pyx_t_5(__pyx_t_11); if (unlikely(!__pyx_t_2)) goto __pyx_L7_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_2);
      index = 1; __pyx_t_4 = __pyx_t_5(__pyx_t_11); if (unlikely(!__pyx_t_4)) goto __pyx_L7_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_4);
      if (__Pyx_IternextUnpackEndCheck(__pyx_t_5(__pyx_t_11), 2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_t_5 = NULL;
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
      goto __pyx_L8_unpacking_done;
      __pyx_L7_unpacking_failed:;
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
      __pyx_t_5 = NULL;
      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_L8_unpacking_done:;
    }
    __pyx_t_6 = __Pyx_PyInt_As_int64_t(__pyx_t_2); if (unlikely((__pyx_t_6 == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_3fst__Fst))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_v_label = __pyx_t_6;
    __Pyx_DECREF_SET(__pyx_v_ifst, ((struct __pyx_obj_3fst__Fst *)__pyx_t_4));
    __pyx_t_4 = 0;

    /* "fst.pyx":1709
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   for (label, ifst) in it:
 *     _pairs.push_back(FstTuple(label, ifst.fst))             # <<<<<<<<<<<<<<
 *   call_arc_labeling = tobytes(call_arc_labeling)
 *   epsilon_on_replace = tobytes(epsilon_on_replace)
 */
    try {
      __pyx_t_7 = __pyx_t_3fst_FstTuple(__pyx_v_label, __pyx_v_ifst->fst);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1709; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __pyx_v__pairs.push_back(__pyx_t_7);

    /* "fst.pyx":1708
 *   _pairs.push_back(FstTuple(root_label, ifst.fst))
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   for (label, ifst) in it:             # <<<<<<<<<<<<<<
 *     _pairs.push_back(FstTuple(label, ifst.fst))
 *   call_arc_labeling = tobytes(call_arc_labeling)
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1710
 *   for (label, ifst) in it:
 *     _pairs.push_back(FstTuple(label, ifst.fst))
 *   call_arc_labeling = tobytes(call_arc_labeling)             # <<<<<<<<<<<<<<
 *   epsilon_on_replace = tobytes(epsilon_on_replace)
 *   return_arc_labeling = tobytes(return_arc_labeling)
 */
  __pyx_t_1 = __pyx_f_3fst_tobytes(__pyx_v_call_arc_labeling); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1710; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF_SET(__pyx_v_call_arc_labeling, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "fst.pyx":1711
 *     _pairs.push_back(FstTuple(label, ifst.fst))
 *   call_arc_labeling = tobytes(call_arc_labeling)
 *   epsilon_on_replace = tobytes(epsilon_on_replace)             # <<<<<<<<<<<<<<
 *   return_arc_labeling = tobytes(return_arc_labeling)
 *   cdef ReplaceLabelType cal = _get_replace_label_type(call_arc_labeling,
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_epsilon_on_replace); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1711; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __pyx_f_3fst_tobytes(__pyx_t_1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1711; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_12 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely((__pyx_t_12 == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1711; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_epsilon_on_replace = __pyx_t_12;

  /* "fst.pyx":1712
 *   call_arc_labeling = tobytes(call_arc_labeling)
 *   epsilon_on_replace = tobytes(epsilon_on_replace)
 *   return_arc_labeling = tobytes(return_arc_labeling)             # <<<<<<<<<<<<<<
 *   cdef ReplaceLabelType cal = _get_replace_label_type(call_arc_labeling,
 *                                                       epsilon_on_replace)
 */
  __pyx_t_3 = __pyx_f_3fst_tobytes(__pyx_v_return_arc_labeling); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1712; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF_SET(__pyx_v_return_arc_labeling, __pyx_t_3);
  __pyx_t_3 = 0;

  /* "fst.pyx":1713
 *   epsilon_on_replace = tobytes(epsilon_on_replace)
 *   return_arc_labeling = tobytes(return_arc_labeling)
 *   cdef ReplaceLabelType cal = _get_replace_label_type(call_arc_labeling,             # <<<<<<<<<<<<<<
 *                                                       epsilon_on_replace)
 *   cdef ReplaceLabelType ral = _get_replace_label_type(return_arc_labeling,
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_replace_label_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);

  /* "fst.pyx":1714
 *   return_arc_labeling = tobytes(return_arc_labeling)
 *   cdef ReplaceLabelType cal = _get_replace_label_type(call_arc_labeling,
 *                                                       epsilon_on_replace)             # <<<<<<<<<<<<<<
 *   cdef ReplaceLabelType ral = _get_replace_label_type(return_arc_labeling,
 *                                                       epsilon_on_replace)
 */
  __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_epsilon_on_replace); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1714; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = NULL;
  __pyx_t_9 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
      __pyx_t_9 = 1;
    }
  }
  __pyx_t_11 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_11);
  if (__pyx_t_2) {
    PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_2); __Pyx_GIVEREF(__pyx_t_2); __pyx_t_2 = NULL;
  }
  __Pyx_INCREF(__pyx_v_call_arc_labeling);
  PyTuple_SET_ITEM(__pyx_t_11, 0+__pyx_t_9, __pyx_v_call_arc_labeling);
  __Pyx_GIVEREF(__pyx_v_call_arc_labeling);
  PyTuple_SET_ITEM(__pyx_t_11, 1+__pyx_t_9, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_4);
  __pyx_t_4 = 0;
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_11, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1713
 *   epsilon_on_replace = tobytes(epsilon_on_replace)
 *   return_arc_labeling = tobytes(return_arc_labeling)
 *   cdef ReplaceLabelType cal = _get_replace_label_type(call_arc_labeling,             # <<<<<<<<<<<<<<
 *                                                       epsilon_on_replace)
 *   cdef ReplaceLabelType ral = _get_replace_label_type(return_arc_labeling,
 */
  __pyx_t_13 = ((enum fst::ReplaceLabelType)PyInt_AsLong(__pyx_t_3)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_cal = __pyx_t_13;

  /* "fst.pyx":1715
 *   cdef ReplaceLabelType cal = _get_replace_label_type(call_arc_labeling,
 *                                                       epsilon_on_replace)
 *   cdef ReplaceLabelType ral = _get_replace_label_type(return_arc_labeling,             # <<<<<<<<<<<<<<
 *                                                       epsilon_on_replace)
 *   cdef const ReplaceOptions *opts = new ReplaceOptions(root_label, cal, ral,
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_replace_label_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1715; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);

  /* "fst.pyx":1716
 *                                                       epsilon_on_replace)
 *   cdef ReplaceLabelType ral = _get_replace_label_type(return_arc_labeling,
 *                                                       epsilon_on_replace)             # <<<<<<<<<<<<<<
 *   cdef const ReplaceOptions *opts = new ReplaceOptions(root_label, cal, ral,
 *                                                        return_label)
 */
  __pyx_t_11 = __Pyx_PyBool_FromLong(__pyx_v_epsilon_on_replace); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1716; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_11);
  __pyx_t_4 = NULL;
  __pyx_t_9 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
      __pyx_t_9 = 1;
    }
  }
  __pyx_t_2 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1715; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (__pyx_t_4) {
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_4); __Pyx_GIVEREF(__pyx_t_4); __pyx_t_4 = NULL;
  }
  __Pyx_INCREF(__pyx_v_return_arc_labeling);
  PyTuple_SET_ITEM(__pyx_t_2, 0+__pyx_t_9, __pyx_v_return_arc_labeling);
  __Pyx_GIVEREF(__pyx_v_return_arc_labeling);
  PyTuple_SET_ITEM(__pyx_t_2, 1+__pyx_t_9, __pyx_t_11);
  __Pyx_GIVEREF(__pyx_t_11);
  __pyx_t_11 = 0;
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1715; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1715
 *   cdef ReplaceLabelType cal = _get_replace_label_type(call_arc_labeling,
 *                                                       epsilon_on_replace)
 *   cdef ReplaceLabelType ral = _get_replace_label_type(return_arc_labeling,             # <<<<<<<<<<<<<<
 *                                                       epsilon_on_replace)
 *   cdef const ReplaceOptions *opts = new ReplaceOptions(root_label, cal, ral,
 */
  __pyx_t_13 = ((enum fst::ReplaceLabelType)PyInt_AsLong(__pyx_t_3)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1715; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_ral = __pyx_t_13;

  /* "fst.pyx":1717
 *   cdef ReplaceLabelType ral = _get_replace_label_type(return_arc_labeling,
 *                                                       epsilon_on_replace)
 *   cdef const ReplaceOptions *opts = new ReplaceOptions(root_label, cal, ral,             # <<<<<<<<<<<<<<
 *                                                        return_label)
 *   Replace(_pairs, tfst, deref(opts))
 */
  __pyx_v_opts = new fst::script::ReplaceOptions(__pyx_v_root_label, __pyx_v_cal, __pyx_v_ral, __pyx_v_return_label);

  /* "fst.pyx":1719
 *   cdef const ReplaceOptions *opts = new ReplaceOptions(root_label, cal, ral,
 *                                                        return_label)
 *   Replace(_pairs, tfst, deref(opts))             # <<<<<<<<<<<<<<
 *   del opts
 *   return _init_MutableFst(tfst)
 */
  fst::script::Replace(__pyx_v__pairs, __pyx_v_tfst, (*__pyx_v_opts));

  /* "fst.pyx":1720
 *                                                        return_label)
 *   Replace(_pairs, tfst, deref(opts))
 *   del opts             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  delete __pyx_v_opts;

  /* "fst.pyx":1721
 *   Replace(_pairs, tfst, deref(opts))
 *   del opts
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1721; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1669
 * 
 * 
 * def replace(pairs, call_arc_labeling=b"input", return_arc_labeling=b"neither",             # <<<<<<<<<<<<<<
 *             bool epsilon_on_replace=False, int64 return_label=0):
 *   """Recursively replaces arcs in the FST with other FST(s).
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_AddTraceback("fst.replace", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_ifst);
  __Pyx_XDECREF(__pyx_v_it);
  __Pyx_XDECREF(__pyx_v_call_arc_labeling);
  __Pyx_XDECREF(__pyx_v_return_arc_labeling);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1724
 * 
 * 
 * def reverse(_Fst ifst, bool require_superinitial=True):             # <<<<<<<<<<<<<<
 *   """Constructively reverses an FST's transduction.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_43reverse(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_42reverse[] = "Constructively reverses an FST's transduction.\n\n  This operation reverses an FST. If A transduces string x to y with weight a,\n  then the reverse of A transduces the reverse of x to the reverse of y with\n  weight a.Reverse(). (Typically, a = a.Reverse() and Arc = RevArc, e.g.,\n  TropicalWeight and LogWeight.) In general, e.g., when the weights only form a\n  left or right semiring, the output arc type must match the input arc type.\n\n  Args:\n    ifst: The input Fst.\n    require_superinitial: Should a superinitial state be created?\n\n  Returns:\n    A reversed FST.\n  ";
static PyMethodDef __pyx_mdef_3fst_43reverse = {"reverse", (PyCFunction)__pyx_pw_3fst_43reverse, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_42reverse};
static PyObject *__pyx_pw_3fst_43reverse(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  bool __pyx_v_require_superinitial;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("reverse (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst,&__pyx_n_s_require_superinitial,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_require_superinitial);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "reverse") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1724; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)values[0]);
    if (values[1]) {
      __pyx_v_require_superinitial = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_require_superinitial == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1724; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_require_superinitial = ((bool)1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("reverse", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1724; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.reverse", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1724; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_42reverse(__pyx_self, __pyx_v_ifst, __pyx_v_require_superinitial);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_42reverse(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, bool __pyx_v_require_superinitial) {
  fst::script::VectorFstClass *__pyx_v_tfst;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("reverse", 0);

  /* "fst.pyx":1740
 *     A reversed FST.
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)             # <<<<<<<<<<<<<<
 *   Reverse(deref(ifst.fst), tfst, require_superinitial)
 *   return _init_MutableFst(tfst)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1740; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1740; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_2);

  /* "fst.pyx":1741
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   Reverse(deref(ifst.fst), tfst, require_superinitial)             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  fst::script::Reverse((*__pyx_v_ifst->fst), __pyx_v_tfst, __pyx_v_require_superinitial);

  /* "fst.pyx":1742
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   Reverse(deref(ifst.fst), tfst, require_superinitial)
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1742; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1724
 * 
 * 
 * def reverse(_Fst ifst, bool require_superinitial=True):             # <<<<<<<<<<<<<<
 *   """Constructively reverses an FST's transduction.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst.reverse", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1745
 * 
 * 
 * def rmepsilon(_Fst ifst, bool connect=True, float delta=kDelta,             # <<<<<<<<<<<<<<
 *               int64 nstate=kNoStateId, queue_type=b"auto", bool reverse=False,
 *               weight=b""):
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_45rmepsilon(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_44rmepsilon[] = "Constructively removes epsilon transitions from an FST.\n\n  This operation removes epsilon transitions (those where both input and output\n  labels are epsilon) from an FST.\n\n  Args:\n    ifst: The input Fst.\n    connect: Should output be trimmed?\n    delta: Comparison/quantization delta.\n    nstate: State number threshold.\n    queue_type: A string matching a known QueueType.\n    reverse: Should epsilon transitions be removed in reverse order?\n    weight: A string representing a desired weight threshold; paths with\n        weights below this threshold will be pruned.\n\n  Returns:\n    An equivalent FST with no epsilon transitions.\n  ";
static PyMethodDef __pyx_mdef_3fst_45rmepsilon = {"rmepsilon", (PyCFunction)__pyx_pw_3fst_45rmepsilon, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_44rmepsilon};
static PyObject *__pyx_pw_3fst_45rmepsilon(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  bool __pyx_v_connect;
  float __pyx_v_delta;
  int64 __pyx_v_nstate;
  PyObject *__pyx_v_queue_type = 0;
  bool __pyx_v_reverse;
  PyObject *__pyx_v_weight = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rmepsilon (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst,&__pyx_n_s_connect,&__pyx_n_s_delta,&__pyx_n_s_nstate,&__pyx_n_s_queue_type,&__pyx_n_s_reverse,&__pyx_n_s_weight,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};
    values[4] = ((PyObject *)__pyx_n_b_auto);
    values[6] = ((PyObject *)__pyx_kp_b__5);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_connect);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nstate);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_queue_type);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_reverse);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_weight);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "rmepsilon") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1745; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)values[0]);
    if (values[1]) {
      __pyx_v_connect = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_connect == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1745; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_connect = ((bool)1);
    }
    if (values[2]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[2]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1745; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__37;
    }
    if (values[3]) {
      __pyx_v_nstate = __Pyx_PyInt_As_int64_t(values[3]); if (unlikely((__pyx_v_nstate == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1746; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_nstate = __pyx_k__38;
    }
    __pyx_v_queue_type = values[4];
    if (values[5]) {
      __pyx_v_reverse = __Pyx_PyObject_IsTrue(values[5]); if (unlikely((__pyx_v_reverse == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1746; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "fst.pyx":1746
 * 
 * def rmepsilon(_Fst ifst, bool connect=True, float delta=kDelta,
 *               int64 nstate=kNoStateId, queue_type=b"auto", bool reverse=False,             # <<<<<<<<<<<<<<
 *               weight=b""):
 *   """Constructively removes epsilon transitions from an FST.
 */
      __pyx_v_reverse = ((bool)0);
    }
    __pyx_v_weight = values[6];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("rmepsilon", 0, 1, 7, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1745; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.rmepsilon", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1745; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_44rmepsilon(__pyx_self, __pyx_v_ifst, __pyx_v_connect, __pyx_v_delta, __pyx_v_nstate, __pyx_v_queue_type, __pyx_v_reverse, __pyx_v_weight);

  /* "fst.pyx":1745
 * 
 * 
 * def rmepsilon(_Fst ifst, bool connect=True, float delta=kDelta,             # <<<<<<<<<<<<<<
 *               int64 nstate=kNoStateId, queue_type=b"auto", bool reverse=False,
 *               weight=b""):
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_44rmepsilon(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, bool __pyx_v_connect, float __pyx_v_delta, int64 __pyx_v_nstate, PyObject *__pyx_v_queue_type, bool __pyx_v_reverse, PyObject *__pyx_v_weight) {
  enum fst::QueueType __pyx_v_qt;
  fst::script::WeightClass __pyx_v_wc;
  fst::script::RmEpsilonOptions const *__pyx_v_opts;
  fst::script::VectorFstClass *__pyx_v_tfst;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  enum fst::QueueType __pyx_t_6;
  std::string __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("rmepsilon", 0);

  /* "fst.pyx":1766
 *     An equivalent FST with no epsilon transitions.
 *   """
 *   cdef QueueType qt = _get_queue_type(tobytes(queue_type))             # <<<<<<<<<<<<<<
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, weight)
 *   cdef const RmEpsilonOptions *opts = new RmEpsilonOptions(qt, delta, connect,
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_queue_type); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1766; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __pyx_f_3fst_tobytes(__pyx_v_queue_type); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1766; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1766; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1766; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __Pyx_GIVEREF(__pyx_t_4); __pyx_t_4 = NULL;
    PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1766; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_6 = ((enum fst::QueueType)PyInt_AsLong(__pyx_t_1)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1766; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_qt = __pyx_t_6;

  /* "fst.pyx":1767
 *   """
 *   cdef QueueType qt = _get_queue_type(tobytes(queue_type))
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, weight)             # <<<<<<<<<<<<<<
 *   cdef const RmEpsilonOptions *opts = new RmEpsilonOptions(qt, delta, connect,
 *                                                            wc, nstate)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_weight_type_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1767; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_wc = __pyx_f_3fst__get_weight_class(__pyx_t_1, __pyx_v_weight);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1768
 *   cdef QueueType qt = _get_queue_type(tobytes(queue_type))
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, weight)
 *   cdef const RmEpsilonOptions *opts = new RmEpsilonOptions(qt, delta, connect,             # <<<<<<<<<<<<<<
 *                                                            wc, nstate)
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 */
  __pyx_v_opts = new fst::script::RmEpsilonOptions(__pyx_v_qt, __pyx_v_delta, __pyx_v_connect, __pyx_v_wc, __pyx_v_nstate);

  /* "fst.pyx":1770
 *   cdef const RmEpsilonOptions *opts = new RmEpsilonOptions(qt, delta, connect,
 *                                                            wc, nstate)
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)             # <<<<<<<<<<<<<<
 *   RmEpsilon(deref(ifst.fst), tfst, reverse, deref(opts))
 *   del opts
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1770; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_7 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1770; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_7);

  /* "fst.pyx":1771
 *                                                            wc, nstate)
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   RmEpsilon(deref(ifst.fst), tfst, reverse, deref(opts))             # <<<<<<<<<<<<<<
 *   del opts
 *   return _init_MutableFst(tfst)
 */
  fst::script::RmEpsilon((*__pyx_v_ifst->fst), __pyx_v_tfst, __pyx_v_reverse, (*__pyx_v_opts));

  /* "fst.pyx":1772
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   RmEpsilon(deref(ifst.fst), tfst, reverse, deref(opts))
 *   del opts             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  delete __pyx_v_opts;

  /* "fst.pyx":1773
 *   RmEpsilon(deref(ifst.fst), tfst, reverse, deref(opts))
 *   del opts
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1773; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1745
 * 
 * 
 * def rmepsilon(_Fst ifst, bool connect=True, float delta=kDelta,             # <<<<<<<<<<<<<<
 *               int64 nstate=kNoStateId, queue_type=b"auto", bool reverse=False,
 *               weight=b""):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("fst.rmepsilon", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1776
 * 
 * 
 * def shortestdistance(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId,             # <<<<<<<<<<<<<<
 *                      queue_type=b"auto", bool reverse=False):
 *   """Compute the shortest distance from the initial or final state.
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_47shortestdistance(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_46shortestdistance[] = "Compute the shortest distance from the initial or final state.\n\n  This operation computes the shortest distance from the initial state (when\n  `reverse` is False) or from every state to the final state (when `reverse` is\n  True). The shortest distance from p to q is the \\otimes-sum of the weights of\n  all the paths between p and q. The weights must be right (if `reverse` is\n  False) or left (if `reverse` is True) distributive, and k-closed (i.e., 1\n  \\otimes x \\otimes x^2 \\otimes ... \\otimes x^{k + 1} = 1 \\otimes x \\otimes x^2\n  \\otimes ... \\otimes x^k; e.g., TropicalWeight).\n\n  Args:\n    ifst: The input Fst.\n    delta: Comparison/quantization delta.\n    nstate: State number threshold (this is ignored if `reverse` is True).\n    queue_type: A string matching a known QueueType (this is ignored if\n        `reverse` is True).\n    reverse: Should the reverse distance (from each state to the final state)\n        be computed?\n\n  Returns:\n    A list of Weight objects representing the shortest distance for each state.\n  ";
static PyMethodDef __pyx_mdef_3fst_47shortestdistance = {"shortestdistance", (PyCFunction)__pyx_pw_3fst_47shortestdistance, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_46shortestdistance};
static PyObject *__pyx_pw_3fst_47shortestdistance(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  float __pyx_v_delta;
  int64 __pyx_v_nstate;
  PyObject *__pyx_v_queue_type = 0;
  bool __pyx_v_reverse;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("shortestdistance (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst,&__pyx_n_s_delta,&__pyx_n_s_nstate,&__pyx_n_s_queue_type,&__pyx_n_s_reverse,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[3] = ((PyObject *)__pyx_n_b_auto);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nstate);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_queue_type);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_reverse);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "shortestdistance") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1776; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)values[0]);
    if (values[1]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[1]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1776; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__39;
    }
    if (values[2]) {
      __pyx_v_nstate = __Pyx_PyInt_As_int64_t(values[2]); if (unlikely((__pyx_v_nstate == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1776; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_nstate = __pyx_k__40;
    }
    __pyx_v_queue_type = values[3];
    if (values[4]) {
      __pyx_v_reverse = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_reverse == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1777; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "fst.pyx":1777
 * 
 * def shortestdistance(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId,
 *                      queue_type=b"auto", bool reverse=False):             # <<<<<<<<<<<<<<
 *   """Compute the shortest distance from the initial or final state.
 * 
 */
      __pyx_v_reverse = ((bool)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("shortestdistance", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1776; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.shortestdistance", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1776; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_46shortestdistance(__pyx_self, __pyx_v_ifst, __pyx_v_delta, __pyx_v_nstate, __pyx_v_queue_type, __pyx_v_reverse);

  /* "fst.pyx":1776
 * 
 * 
 * def shortestdistance(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId,             # <<<<<<<<<<<<<<
 *                      queue_type=b"auto", bool reverse=False):
 *   """Compute the shortest distance from the initial or final state.
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_46shortestdistance(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, int64 __pyx_v_nstate, PyObject *__pyx_v_queue_type, bool __pyx_v_reverse) {
  std::vector<fst::script::WeightClass>  *__pyx_v_distance;
  enum fst::QueueType __pyx_v_qt;
  fst::script::ShortestDistanceOptions *__pyx_v_opts;
  std::string __pyx_v_weight_type;
  PyObject *__pyx_v_result = NULL;
  std::vector<fst::script::WeightClass> ::iterator __pyx_v_it;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  std::vector<fst::script::WeightClass>  *__pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  enum fst::QueueType __pyx_t_8;
  std::string __pyx_t_9;
  int __pyx_t_10;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("shortestdistance", 0);

  /* "fst.pyx":1800
 *     A list of Weight objects representing the shortest distance for each state.
 *   """
 *   cdef vector[WeightClass] *distance = new vector[WeightClass]()             # <<<<<<<<<<<<<<
 *   # For scoping reasons, these have to be declared here even though they may
 *   # not be used in all cases.
 */
  try {
    __pyx_t_1 = new std::vector<fst::script::WeightClass> ();
  } catch(...) {
    __Pyx_CppExn2PyErr();
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_v_distance = __pyx_t_1;

  /* "fst.pyx":1805
 *   cdef QueueType qt
 *   cdef ShortestDistanceOptions *opts
 *   if reverse:             # <<<<<<<<<<<<<<
 *     # Only the simpler signature supports shortest distance to final states;
 *     # `nstate` and `queue_type` arguments are ignored.
 */
  __pyx_t_2 = (__pyx_v_reverse != 0);
  if (__pyx_t_2) {

    /* "fst.pyx":1808
 *     # Only the simpler signature supports shortest distance to final states;
 *     # `nstate` and `queue_type` arguments are ignored.
 *     ShortestDistance(deref(ifst.fst), distance, True, delta)             # <<<<<<<<<<<<<<
 *   else:
 *     qt = _get_queue_type(tobytes(queue_type))
 */
    fst::script::ShortestDistance((*__pyx_v_ifst->fst), __pyx_v_distance, 1, __pyx_v_delta);
    goto __pyx_L3;
  }
  /*else*/ {

    /* "fst.pyx":1810
 *     ShortestDistance(deref(ifst.fst), distance, True, delta)
 *   else:
 *     qt = _get_queue_type(tobytes(queue_type))             # <<<<<<<<<<<<<<
 *     opts = new ShortestDistanceOptions(qt, ANY_ARC_FILTER, nstate, delta)
 *     ShortestDistance(deref(ifst.fst), distance, deref(opts))
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_queue_type); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __pyx_f_3fst_tobytes(__pyx_v_queue_type); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_6) {
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_3);
    } else {
      __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_7);
      PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6); __Pyx_GIVEREF(__pyx_t_6); __pyx_t_6 = NULL;
      PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_5);
      __pyx_t_5 = 0;
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_8 = ((enum fst::QueueType)PyInt_AsLong(__pyx_t_3)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_qt = __pyx_t_8;

    /* "fst.pyx":1811
 *   else:
 *     qt = _get_queue_type(tobytes(queue_type))
 *     opts = new ShortestDistanceOptions(qt, ANY_ARC_FILTER, nstate, delta)             # <<<<<<<<<<<<<<
 *     ShortestDistance(deref(ifst.fst), distance, deref(opts))
 *     del opts
 */
    __pyx_v_opts = new fst::script::ShortestDistanceOptions(__pyx_v_qt, fst::script::ANY_ARC_FILTER, __pyx_v_nstate, __pyx_v_delta);

    /* "fst.pyx":1812
 *     qt = _get_queue_type(tobytes(queue_type))
 *     opts = new ShortestDistanceOptions(qt, ANY_ARC_FILTER, nstate, delta)
 *     ShortestDistance(deref(ifst.fst), distance, deref(opts))             # <<<<<<<<<<<<<<
 *     del opts
 *   # Pack the distances, as strings, into a Python list.
 */
    fst::script::ShortestDistance((*__pyx_v_ifst->fst), __pyx_v_distance, (*__pyx_v_opts));

    /* "fst.pyx":1813
 *     opts = new ShortestDistanceOptions(qt, ANY_ARC_FILTER, nstate, delta)
 *     ShortestDistance(deref(ifst.fst), distance, deref(opts))
 *     del opts             # <<<<<<<<<<<<<<
 *   # Pack the distances, as strings, into a Python list.
 *   cdef string weight_type = ifst._weight_type
 */
    delete __pyx_v_opts;
  }
  __pyx_L3:;

  /* "fst.pyx":1815
 *     del opts
 *   # Pack the distances, as strings, into a Python list.
 *   cdef string weight_type = ifst._weight_type             # <<<<<<<<<<<<<<
 *   result = []
 *   # This is just the Cython version of the normal vector iteration idiom.
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_weight_type_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_9 = __pyx_convert_string_from_py_(__pyx_t_3); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_weight_type = __pyx_t_9;

  /* "fst.pyx":1816
 *   # Pack the distances, as strings, into a Python list.
 *   cdef string weight_type = ifst._weight_type
 *   result = []             # <<<<<<<<<<<<<<
 *   # This is just the Cython version of the normal vector iteration idiom.
 *   cdef vector[WeightClass].iterator it = distance.begin()
 */
  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1816; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_v_result = ((PyObject*)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "fst.pyx":1818
 *   result = []
 *   # This is just the Cython version of the normal vector iteration idiom.
 *   cdef vector[WeightClass].iterator it = distance.begin()             # <<<<<<<<<<<<<<
 *   while it != distance.end():
 *     result.append(Weight(weight_type, deref(it).to_string()))
 */
  __pyx_v_it = __pyx_v_distance->begin();

  /* "fst.pyx":1819
 *   # This is just the Cython version of the normal vector iteration idiom.
 *   cdef vector[WeightClass].iterator it = distance.begin()
 *   while it != distance.end():             # <<<<<<<<<<<<<<
 *     result.append(Weight(weight_type, deref(it).to_string()))
 *     inc(it)
 */
  while (1) {
    __pyx_t_2 = ((__pyx_v_it != __pyx_v_distance->end()) != 0);
    if (!__pyx_t_2) break;

    /* "fst.pyx":1820
 *   cdef vector[WeightClass].iterator it = distance.begin()
 *   while it != distance.end():
 *     result.append(Weight(weight_type, deref(it).to_string()))             # <<<<<<<<<<<<<<
 *     inc(it)
 *   del distance
 */
    __pyx_t_3 = __pyx_convert_string_to_py_(__pyx_v_weight_type); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __pyx_convert_string_to_py_((*__pyx_v_it).to_string()); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_3 = 0;
    __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_3fst_Weight)), __pyx_t_7, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_10 = __Pyx_PyList_Append(__pyx_v_result, __pyx_t_4); if (unlikely(__pyx_t_10 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "fst.pyx":1821
 *   while it != distance.end():
 *     result.append(Weight(weight_type, deref(it).to_string()))
 *     inc(it)             # <<<<<<<<<<<<<<
 *   del distance
 *   return result
 */
    (++__pyx_v_it);
  }

  /* "fst.pyx":1822
 *     result.append(Weight(weight_type, deref(it).to_string()))
 *     inc(it)
 *   del distance             # <<<<<<<<<<<<<<
 *   return result
 * 
 */
  delete __pyx_v_distance;

  /* "fst.pyx":1823
 *     inc(it)
 *   del distance
 *   return result             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_result);
  __pyx_r = __pyx_v_result;
  goto __pyx_L0;

  /* "fst.pyx":1776
 * 
 * 
 * def shortestdistance(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId,             # <<<<<<<<<<<<<<
 *                      queue_type=b"auto", bool reverse=False):
 *   """Compute the shortest distance from the initial or final state.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("fst.shortestdistance", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_result);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1826
 * 
 * 
 * def shortestpath(_Fst ifst, float delta=kDelta, int64 nshortest=1,             # <<<<<<<<<<<<<<
 *                  int64 nstate=kNoStateId, queue_type=b"auto",
 *                  bool unique=False, weight=b""):
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_49shortestpath(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3fst_48shortestpath[] = "Construct an FST containing the shortest path(s) in the input FST.\n\n  This operation produces an FST containing the n-shortest paths in the input\n  FST. The n-shortest paths are the n-lowest weight paths w.r.t. the natural\n  semiring order. The single path that can be read from the ith of at most n\n  transitions leaving the initial state of the resulting FST is the ith\n  shortest path. The weights need to be right distributive and have the path\n  property. They also need to be left distributive as well for n-shortest with\n  n > 1 (e.g., TropicalWeight).\n\n  Args:\n    ifst: The input FST.\n    delta: Comparison/quantization delta.\n    nshortest: The number of paths to return.\n    nstate: State number threshold.\n    queue_type: A string matching a known QueueType.\n    unique: Should the resulting FST only contain distinct paths? (Requires\n        the input FST to be an acceptor; epsilons are treated as if they are\n        regular symbols.)\n    weight: A string representing a desired weight threshold; paths with\n        weights below this threshold will be pruned.\n\n  Returns:\n    An FST containing the n-shortest paths.\n  ";
static PyMethodDef __pyx_mdef_3fst_49shortestpath = {"shortestpath", (PyCFunction)__pyx_pw_3fst_49shortestpath, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_48shortestpath};
static PyObject *__pyx_pw_3fst_49shortestpath(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3fst__Fst *__pyx_v_ifst = 0;
  float __pyx_v_delta;
  int64 __pyx_v_nshortest;
  int64 __pyx_v_nstate;
  PyObject *__pyx_v_queue_type = 0;
  bool __pyx_v_unique;
  PyObject *__pyx_v_weight = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("shortestpath (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ifst,&__pyx_n_s_delta,&__pyx_n_s_nshortest,&__pyx_n_s_nstate,&__pyx_n_s_queue_type,&__pyx_n_s_unique,&__pyx_n_s_weight,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};
    values[4] = ((PyObject *)__pyx_n_b_auto);
    values[6] = ((PyObject *)__pyx_kp_b__5);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delta);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nshortest);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nstate);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_queue_type);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_unique);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_weight);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "shortestpath") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1826; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ifst = ((struct __pyx_obj_3fst__Fst *)values[0]);
    if (values[1]) {
      __pyx_v_delta = __pyx_PyFloat_AsFloat(values[1]); if (unlikely((__pyx_v_delta == (float)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1826; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delta = __pyx_k__41;
    }
    if (values[2]) {
      __pyx_v_nshortest = __Pyx_PyInt_As_int64_t(values[2]); if (unlikely((__pyx_v_nshortest == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1826; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_nshortest = ((int64)1);
    }
    if (values[3]) {
      __pyx_v_nstate = __Pyx_PyInt_As_int64_t(values[3]); if (unlikely((__pyx_v_nstate == (int64)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1827; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_nstate = __pyx_k__42;
    }
    __pyx_v_queue_type = values[4];
    if (values[5]) {
      __pyx_v_unique = __Pyx_PyObject_IsTrue(values[5]); if (unlikely((__pyx_v_unique == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1828; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "fst.pyx":1828
 * def shortestpath(_Fst ifst, float delta=kDelta, int64 nshortest=1,
 *                  int64 nstate=kNoStateId, queue_type=b"auto",
 *                  bool unique=False, weight=b""):             # <<<<<<<<<<<<<<
 *   """Construct an FST containing the shortest path(s) in the input FST.
 * 
 */
      __pyx_v_unique = ((bool)0);
    }
    __pyx_v_weight = values[6];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("shortestpath", 0, 1, 7, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1826; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("fst.shortestpath", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_48shortestpath(__pyx_self, __pyx_v_ifst, __pyx_v_delta, __pyx_v_nshortest, __pyx_v_nstate, __pyx_v_queue_type, __pyx_v_unique, __pyx_v_weight);

  /* "fst.pyx":1826
 * 
 * 
 * def shortestpath(_Fst ifst, float delta=kDelta, int64 nshortest=1,             # <<<<<<<<<<<<<<
 *                  int64 nstate=kNoStateId, queue_type=b"auto",
 *                  bool unique=False, weight=b""):
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_48shortestpath(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst, float __pyx_v_delta, int64 __pyx_v_nshortest, int64 __pyx_v_nstate, PyObject *__pyx_v_queue_type, bool __pyx_v_unique, PyObject *__pyx_v_weight) {
  fst::script::VectorFstClass *__pyx_v_tfst;
  std::vector<fst::script::WeightClass>  *__pyx_v_distance;
  enum fst::QueueType __pyx_v_qt;
  fst::script::WeightClass __pyx_v_wc;
  fst::script::ShortestPathOptions const *__pyx_v_opts;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  std::vector<fst::script::WeightClass>  *__pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  enum fst::QueueType __pyx_t_8;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("shortestpath", 0);

  /* "fst.pyx":1854
 *     An FST containing the n-shortest paths.
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)             # <<<<<<<<<<<<<<
 *   cdef vector[WeightClass] *distance = new vector[WeightClass]()
 *   cdef QueueType qt = _get_queue_type(tobytes(queue_type))
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1854; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1854; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_2);

  /* "fst.pyx":1855
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   cdef vector[WeightClass] *distance = new vector[WeightClass]()             # <<<<<<<<<<<<<<
 *   cdef QueueType qt = _get_queue_type(tobytes(queue_type))
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 */
  try {
    __pyx_t_3 = new std::vector<fst::script::WeightClass> ();
  } catch(...) {
    __Pyx_CppExn2PyErr();
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1855; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_v_distance = __pyx_t_3;

  /* "fst.pyx":1856
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   cdef vector[WeightClass] *distance = new vector[WeightClass]()
 *   cdef QueueType qt = _get_queue_type(tobytes(queue_type))             # <<<<<<<<<<<<<<
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 *   cdef const ShortestPathOptions *opts = new ShortestPathOptions(qt, nshortest,
 */
  __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_get_queue_type); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1856; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = __pyx_f_3fst_tobytes(__pyx_v_queue_type); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1856; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  if (!__pyx_t_6) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1856; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1856; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6); __Pyx_GIVEREF(__pyx_t_6); __pyx_t_6 = NULL;
    PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_5);
    __pyx_t_5 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1856; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_8 = ((enum fst::QueueType)PyInt_AsLong(__pyx_t_1)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1856; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_qt = __pyx_t_8;

  /* "fst.pyx":1857
 *   cdef vector[WeightClass] *distance = new vector[WeightClass]()
 *   cdef QueueType qt = _get_queue_type(tobytes(queue_type))
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))             # <<<<<<<<<<<<<<
 *   cdef const ShortestPathOptions *opts = new ShortestPathOptions(qt, nshortest,
 *       unique, False, delta, False, wc, nstate)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_weight_type_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __pyx_f_3fst_tobytes(__pyx_v_weight); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_v_wc = __pyx_f_3fst__get_weight_class(__pyx_t_1, __pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "fst.pyx":1858
 *   cdef QueueType qt = _get_queue_type(tobytes(queue_type))
 *   cdef WeightClass wc = _get_weight_class(ifst._weight_type, tobytes(weight))
 *   cdef const ShortestPathOptions *opts = new ShortestPathOptions(qt, nshortest,             # <<<<<<<<<<<<<<
 *       unique, False, delta, False, wc, nstate)
 *   ShortestPath(deref(ifst.fst), tfst, distance, deref(opts))
 */
  __pyx_v_opts = new fst::script::ShortestPathOptions(__pyx_v_qt, __pyx_v_nshortest, __pyx_v_unique, 0, __pyx_v_delta, 0, __pyx_v_wc, __pyx_v_nstate);

  /* "fst.pyx":1860
 *   cdef const ShortestPathOptions *opts = new ShortestPathOptions(qt, nshortest,
 *       unique, False, delta, False, wc, nstate)
 *   ShortestPath(deref(ifst.fst), tfst, distance, deref(opts))             # <<<<<<<<<<<<<<
 *   del distance, opts
 *   return _init_MutableFst(tfst)
 */
  fst::script::ShortestPath((*__pyx_v_ifst->fst), __pyx_v_tfst, __pyx_v_distance, (*__pyx_v_opts));

  /* "fst.pyx":1861
 *       unique, False, delta, False, wc, nstate)
 *   ShortestPath(deref(ifst.fst), tfst, distance, deref(opts))
 *   del distance, opts             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  delete __pyx_v_distance;
  delete __pyx_v_opts;

  /* "fst.pyx":1862
 *   ShortestPath(deref(ifst.fst), tfst, distance, deref(opts))
 *   del distance, opts
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_4 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1862; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1826
 * 
 * 
 * def shortestpath(_Fst ifst, float delta=kDelta, int64 nshortest=1,             # <<<<<<<<<<<<<<
 *                  int64 nstate=kNoStateId, queue_type=b"auto",
 *                  bool unique=False, weight=b""):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("fst.shortestpath", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "fst.pyx":1865
 * 
 * 
 * def synchronize(_Fst ifst):             # <<<<<<<<<<<<<<
 *   """Constructively synchronizes an FST.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_3fst_51synchronize(PyObject *__pyx_self, PyObject *__pyx_v_ifst); /*proto*/
static char __pyx_doc_3fst_50synchronize[] = "Constructively synchronizes an FST.\n\n  This operation synchronizes a transducer. The result will be an equivalent\n  FST that has the property that during the traversal of a path, the delay is\n  either zero or strictly increasing, where the delay is the difference between\n  the number of non-epsilon output labels and input labels along the path. For\n  the algorithm to terminate, the input transducer must have bounded delay,\n  i.e., the delay of every cycle must be zero.\n\n  Args:\n    ifst: The input Fst.\n\n  Returns:\n    An equivalent synchronized FST.\n  ";
static PyMethodDef __pyx_mdef_3fst_51synchronize = {"synchronize", (PyCFunction)__pyx_pw_3fst_51synchronize, METH_O, __pyx_doc_3fst_50synchronize};
static PyObject *__pyx_pw_3fst_51synchronize(PyObject *__pyx_self, PyObject *__pyx_v_ifst) {
  CYTHON_UNUSED int __pyx_lineno = 0;
  CYTHON_UNUSED const char *__pyx_filename = NULL;
  CYTHON_UNUSED int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("synchronize (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_3fst__Fst, 1, "ifst", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_3fst_50synchronize(__pyx_self, ((struct __pyx_obj_3fst__Fst *)__pyx_v_ifst));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_3fst_50synchronize(CYTHON_UNUSED PyObject *__pyx_self, struct __pyx_obj_3fst__Fst *__pyx_v_ifst) {
  fst::script::VectorFstClass *__pyx_v_tfst;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::string __pyx_t_2;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("synchronize", 0);

  /* "fst.pyx":1881
 *     An equivalent synchronized FST.
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)             # <<<<<<<<<<<<<<
 *   Synchronize(deref(ifst.fst), tfst)
 *   return _init_MutableFst(tfst)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_ifst), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1881; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_convert_string_from_py_(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1881; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_tfst = new fst::script::VectorFstClass(__pyx_t_2);

  /* "fst.pyx":1882
 *   """
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   Synchronize(deref(ifst.fst), tfst)             # <<<<<<<<<<<<<<
 *   return _init_MutableFst(tfst)
 * 
 */
  fst::script::Synchronize((*__pyx_v_ifst->fst), __pyx_v_tfst);

  /* "fst.pyx":1883
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst._arc_type)
 *   Synchronize(deref(ifst.fst), tfst)
 *   return _init_MutableFst(tfst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_3fst__init_MutableFst(__pyx_v_tfst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "fst.pyx":1865
 * 
 * 
 * def synchronize(_Fst ifst):             # <<<<<<<<<<<<<<
 *   """Constructively synchronizes an FST.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("fst.synchronize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.from_py":13
 * 
 * @cname("__pyx_convert_string_from_py_")
 * cdef string __pyx_convert_string_from_py_(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t length
 *     cdef char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 */

static std::string __pyx_convert_string_from_py_(PyObject *__pyx_v_o) {
  Py_ssize_t __pyx_v_length;
  char *__pyx_v_data;
  std::string __pyx_r;
  __Pyx_RefNannyDeclarations
  char *__pyx_t_1;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__pyx_convert_string_from_py_", 0);

  /* "string.from_py":15
 * cdef string __pyx_convert_string_from_py_(object o) except *:
 *     cdef Py_ssize_t length
 *     cdef char* data = __Pyx_PyObject_AsStringAndSize(o, &length)             # <<<<<<<<<<<<<<
 *     return string(data, length)
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_data = __pyx_t_1;

  /* "string.from_py":16
 *     cdef Py_ssize_t length
 *     cdef char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 *     return string(data, length)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = std::string(__pyx_v_data, __pyx_v_length);
  goto __pyx_L0;

  /* "string.from_py":13
 * 
 * @cname("__pyx_convert_string_from_py_")
 * cdef string __pyx_convert_string_from_py_(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t length
 *     cdef char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("string.from_py.__pyx_convert_string_from_py_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":30
 * 
 * @cname("__pyx_convert_string_to_py_")
 * cdef object __pyx_convert_string_to_py_(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * 
 */

static PyObject *__pyx_convert_string_to_py_(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__pyx_convert_string_to_py_", 0);

  /* "string.to_py":31
 * @cname("__pyx_convert_string_to_py_")
 * cdef object __pyx_convert_string_to_py_(const string& s):
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 31; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":30
 * 
 * @cname("__pyx_convert_string_to_py_")
 * cdef object __pyx_convert_string_to_py_(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_string_to_py_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_tp_new_3fst_Weight(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  return o;
}

static void __pyx_tp_dealloc_3fst_Weight(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_3fst_6Weight_5__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_3fst_Weight[] = {
  {"type", (PyCFunction)__pyx_pw_3fst_6Weight_9type, METH_NOARGS, 0},
  {"string", (PyCFunction)__pyx_pw_3fst_6Weight_11string, METH_NOARGS, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_3fst_Weight = {
  PyVarObject_HEAD_INIT(0, 0)
  "fst.Weight", /*tp_name*/
  sizeof(struct __pyx_obj_3fst_Weight), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_3fst_Weight, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  __pyx_pw_3fst_6Weight_1__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  0, /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  __pyx_pw_3fst_6Weight_7__richcmp__, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_3fst_Weight, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_3fst_6Weight_3__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_3fst_Weight, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_3fst__Fst(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  return o;
}

static void __pyx_tp_dealloc_3fst__Fst(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_3fst__Fst[] = {
  {"write", (PyCFunction)__pyx_pw_3fst_4_Fst_3write, METH_O, __pyx_doc_3fst_4_Fst_2write},
  {"properties", (PyCFunction)__pyx_pw_3fst_4_Fst_5properties, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_4_Fst_4properties},
  {"_arc_type", (PyCFunction)__pyx_pw_3fst_4_Fst_7_arc_type, METH_NOARGS, __pyx_doc_3fst_4_Fst_6_arc_type},
  {"_fst_type", (PyCFunction)__pyx_pw_3fst_4_Fst_9_fst_type, METH_NOARGS, __pyx_doc_3fst_4_Fst_8_fst_type},
  {"_weight_type", (PyCFunction)__pyx_pw_3fst_4_Fst_11_weight_type, METH_NOARGS, __pyx_doc_3fst_4_Fst_10_weight_type},
  {"verify", (PyCFunction)__pyx_pw_3fst_4_Fst_13verify, METH_NOARGS, __pyx_doc_3fst_4_Fst_12verify},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_3fst__Fst = {
  PyVarObject_HEAD_INIT(0, 0)
  "fst._Fst", /*tp_name*/
  sizeof(struct __pyx_obj_3fst__Fst), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_3fst__Fst, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  __pyx_pw_3fst_4_Fst_1__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "Base Python FST class, wrapping FstClass.\n\n  This class is the basic user-facing FST object. It does not support any\n  destructive operations.", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_3fst__Fst, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_3fst__Fst, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_3fst__MutableFst(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = __pyx_tp_new_3fst__Fst(t, a, k);
  if (unlikely(!o)) return 0;
  return o;
}

static void __pyx_tp_dealloc_3fst__MutableFst(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_3fst_11_MutableFst_1__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  __pyx_tp_dealloc_3fst__Fst(o);
}

static PyMethodDef __pyx_methods_3fst__MutableFst[] = {
  {"_check_mutating_imethod", (PyCFunction)__pyx_pw_3fst_11_MutableFst_3_check_mutating_imethod, METH_NOARGS, __pyx_doc_3fst_11_MutableFst_2_check_mutating_imethod},
  {"arcsort", (PyCFunction)__pyx_pw_3fst_11_MutableFst_5arcsort, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_11_MutableFst_4arcsort},
  {"closure", (PyCFunction)__pyx_pw_3fst_11_MutableFst_7closure, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_11_MutableFst_6closure},
  {"concat", (PyCFunction)__pyx_pw_3fst_11_MutableFst_9concat, METH_O, __pyx_doc_3fst_11_MutableFst_8concat},
  {"connect", (PyCFunction)__pyx_pw_3fst_11_MutableFst_11connect, METH_NOARGS, __pyx_doc_3fst_11_MutableFst_10connect},
  {"decode", (PyCFunction)__pyx_pw_3fst_11_MutableFst_13decode, METH_O, __pyx_doc_3fst_11_MutableFst_12decode},
  {"encode", (PyCFunction)__pyx_pw_3fst_11_MutableFst_15encode, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_11_MutableFst_14encode},
  {"invert", (PyCFunction)__pyx_pw_3fst_11_MutableFst_17invert, METH_NOARGS, __pyx_doc_3fst_11_MutableFst_16invert},
  {"minimize", (PyCFunction)__pyx_pw_3fst_11_MutableFst_19minimize, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_11_MutableFst_18minimize},
  {"project", (PyCFunction)__pyx_pw_3fst_11_MutableFst_21project, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_11_MutableFst_20project},
  {"prune", (PyCFunction)__pyx_pw_3fst_11_MutableFst_23prune, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_11_MutableFst_22prune},
  {"push", (PyCFunction)__pyx_pw_3fst_11_MutableFst_25push, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_11_MutableFst_24push},
  {"relabel", (PyCFunction)__pyx_pw_3fst_11_MutableFst_27relabel, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_11_MutableFst_26relabel},
  {"reweight", (PyCFunction)__pyx_pw_3fst_11_MutableFst_29reweight, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_11_MutableFst_28reweight},
  {"rmepsilon", (PyCFunction)__pyx_pw_3fst_11_MutableFst_31rmepsilon, METH_VARARGS|METH_KEYWORDS, __pyx_doc_3fst_11_MutableFst_30rmepsilon},
  {"topsort", (PyCFunction)__pyx_pw_3fst_11_MutableFst_33topsort, METH_NOARGS, __pyx_doc_3fst_11_MutableFst_32topsort},
  {"union", (PyCFunction)__pyx_pw_3fst_11_MutableFst_35union, METH_O, __pyx_doc_3fst_11_MutableFst_34union},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_3fst__MutableFst = {
  PyVarObject_HEAD_INIT(0, 0)
  "fst._MutableFst", /*tp_name*/
  sizeof(struct __pyx_obj_3fst__MutableFst), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_3fst__MutableFst, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_3fst_4_Fst_1__repr__, /*tp_repr*/
  #else
  0, /*tp_repr*/
  #endif
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "Python FST class with destructive operations, wrapping MutableFstClass.", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_3fst__MutableFst, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_3fst__MutableFst, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
  #if PY_VERSION_HEX < 0x03020000
    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
  #else
    PyModuleDef_HEAD_INIT,
  #endif
    "fst",
    __pyx_k_Python_interface_to_nlp_fst_scri, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_n_s_ACCEPTOR, __pyx_k_ACCEPTOR, sizeof(__pyx_k_ACCEPTOR), 0, 0, 1, 1},
  {&__pyx_n_s_ACCESSIBLE, __pyx_k_ACCESSIBLE, sizeof(__pyx_k_ACCESSIBLE), 0, 0, 1, 1},
  {&__pyx_n_s_ACYCLIC, __pyx_k_ACYCLIC, sizeof(__pyx_k_ACYCLIC), 0, 0, 1, 1},
  {&__pyx_n_s_ADD_ARC_PROPERTIES, __pyx_k_ADD_ARC_PROPERTIES, sizeof(__pyx_k_ADD_ARC_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_ADD_STATE_PROPERTIES, __pyx_k_ADD_STATE_PROPERTIES, sizeof(__pyx_k_ADD_STATE_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_ADD_SUPERFINAL_PROPERTIES, __pyx_k_ADD_SUPERFINAL_PROPERTIES, sizeof(__pyx_k_ADD_SUPERFINAL_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_ARC_SORT_PROPERTIES, __pyx_k_ARC_SORT_PROPERTIES, sizeof(__pyx_k_ARC_SORT_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_BINARY_PROPERTIES, __pyx_k_BINARY_PROPERTIES, sizeof(__pyx_k_BINARY_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_COACCESSIBLE, __pyx_k_COACCESSIBLE, sizeof(__pyx_k_COACCESSIBLE), 0, 0, 1, 1},
  {&__pyx_n_s_COPY_PROPERTIES, __pyx_k_COPY_PROPERTIES, sizeof(__pyx_k_COPY_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_CYCLIC, __pyx_k_CYCLIC, sizeof(__pyx_k_CYCLIC), 0, 0, 1, 1},
  {&__pyx_kp_s_Cannot_encode_r_as_bytestring, __pyx_k_Cannot_encode_r_as_bytestring, sizeof(__pyx_k_Cannot_encode_r_as_bytestring), 0, 0, 1, 0},
  {&__pyx_n_s_DELETE_ARC_PROPERTIES, __pyx_k_DELETE_ARC_PROPERTIES, sizeof(__pyx_k_DELETE_ARC_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_DELETE_STATE_PROPERTIES, __pyx_k_DELETE_STATE_PROPERTIES, sizeof(__pyx_k_DELETE_STATE_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_EPSILONS, __pyx_k_EPSILONS, sizeof(__pyx_k_EPSILONS), 0, 0, 1, 1},
  {&__pyx_n_s_ERROR, __pyx_k_ERROR, sizeof(__pyx_k_ERROR), 0, 0, 1, 1},
  {&__pyx_n_s_EXPANDED, __pyx_k_EXPANDED, sizeof(__pyx_k_EXPANDED), 0, 0, 1, 1},
  {&__pyx_n_s_EXTRINSIC_PROPERTIES, __pyx_k_EXTRINSIC_PROPERTIES, sizeof(__pyx_k_EXTRINSIC_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_kp_s_Equivalence_test_encountered_err, __pyx_k_Equivalence_test_encountered_err, sizeof(__pyx_k_Equivalence_test_encountered_err), 0, 0, 1, 0},
  {&__pyx_n_s_Exception, __pyx_k_Exception, sizeof(__pyx_k_Exception), 0, 0, 1, 1},
  {&__pyx_kp_s_Exception_thrown_when_FST_operat, __pyx_k_Exception_thrown_when_FST_operat, sizeof(__pyx_k_Exception_thrown_when_FST_operat), 0, 0, 1, 0},
  {&__pyx_n_s_FST_PROPERTIES, __pyx_k_FST_PROPERTIES, sizeof(__pyx_k_FST_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_Fst, __pyx_k_Fst, sizeof(__pyx_k_Fst), 0, 0, 1, 1},
  {&__pyx_n_s_FstError, __pyx_k_FstError, sizeof(__pyx_k_FstError), 0, 0, 1, 1},
  {&__pyx_n_s_FstWarning, __pyx_k_FstWarning, sizeof(__pyx_k_FstWarning), 0, 0, 1, 1},
  {&__pyx_kp_s_Fst_at, __pyx_k_Fst_at, sizeof(__pyx_k_Fst_at), 0, 0, 1, 0},
  {&__pyx_n_s_INITIAL_ACYCLIC, __pyx_k_INITIAL_ACYCLIC, sizeof(__pyx_k_INITIAL_ACYCLIC), 0, 0, 1, 1},
  {&__pyx_n_s_INITIAL_CYCLIC, __pyx_k_INITIAL_CYCLIC, sizeof(__pyx_k_INITIAL_CYCLIC), 0, 0, 1, 1},
  {&__pyx_n_s_INTRINSIC_PROPERTIES, __pyx_k_INTRINSIC_PROPERTIES, sizeof(__pyx_k_INTRINSIC_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_I_DETERMINISTIC, __pyx_k_I_DETERMINISTIC, sizeof(__pyx_k_I_DETERMINISTIC), 0, 0, 1, 1},
  {&__pyx_n_s_I_EPSILONS, __pyx_k_I_EPSILONS, sizeof(__pyx_k_I_EPSILONS), 0, 0, 1, 1},
  {&__pyx_n_s_I_LABEL_INVARIANT_PROPERTIES, __pyx_k_I_LABEL_INVARIANT_PROPERTIES, sizeof(__pyx_k_I_LABEL_INVARIANT_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_I_LABEL_SORTED, __pyx_k_I_LABEL_SORTED, sizeof(__pyx_k_I_LABEL_SORTED), 0, 0, 1, 1},
  {&__pyx_kp_s_Input_FST_is_cyclic, __pyx_k_Input_FST_is_cyclic, sizeof(__pyx_k_Input_FST_is_cyclic), 0, 0, 1, 0},
  {&__pyx_kp_s_Input_FSTs_must_have_the_same_ar, __pyx_k_Input_FSTs_must_have_the_same_ar, sizeof(__pyx_k_Input_FSTs_must_have_the_same_ar), 0, 0, 1, 0},
  {&__pyx_kp_s_Invalid_operator_r, __pyx_k_Invalid_operator_r, sizeof(__pyx_k_Invalid_operator_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Isomorphism_test_encountered_err, __pyx_k_Isomorphism_test_encountered_err, sizeof(__pyx_k_Isomorphism_test_encountered_err), 0, 0, 1, 0},
  {&__pyx_n_s_MUTABLE, __pyx_k_MUTABLE, sizeof(__pyx_k_MUTABLE), 0, 0, 1, 1},
  {&__pyx_n_s_NEG_TRINARY_PROPERTIES, __pyx_k_NEG_TRINARY_PROPERTIES, sizeof(__pyx_k_NEG_TRINARY_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_NON_I_DETERMINISTIC, __pyx_k_NON_I_DETERMINISTIC, sizeof(__pyx_k_NON_I_DETERMINISTIC), 0, 0, 1, 1},
  {&__pyx_n_s_NON_O_DETERMINISTIC, __pyx_k_NON_O_DETERMINISTIC, sizeof(__pyx_k_NON_O_DETERMINISTIC), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_ACCEPTOR, __pyx_k_NOT_ACCEPTOR, sizeof(__pyx_k_NOT_ACCEPTOR), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_ACCESSIBLE, __pyx_k_NOT_ACCESSIBLE, sizeof(__pyx_k_NOT_ACCESSIBLE), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_COACCESSIBLE, __pyx_k_NOT_COACCESSIBLE, sizeof(__pyx_k_NOT_COACCESSIBLE), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_I_LABEL_SORTED, __pyx_k_NOT_I_LABEL_SORTED, sizeof(__pyx_k_NOT_I_LABEL_SORTED), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_O_LABEL_SORTED, __pyx_k_NOT_O_LABEL_SORTED, sizeof(__pyx_k_NOT_O_LABEL_SORTED), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_STRING, __pyx_k_NOT_STRING, sizeof(__pyx_k_NOT_STRING), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_TOP_SORTED, __pyx_k_NOT_TOP_SORTED, sizeof(__pyx_k_NOT_TOP_SORTED), 0, 0, 1, 1},
  {&__pyx_n_s_NO_EPSILONS, __pyx_k_NO_EPSILONS, sizeof(__pyx_k_NO_EPSILONS), 0, 0, 1, 1},
  {&__pyx_n_s_NO_I_EPSILONS, __pyx_k_NO_I_EPSILONS, sizeof(__pyx_k_NO_I_EPSILONS), 0, 0, 1, 1},
  {&__pyx_n_s_NO_O_EPSILSONS, __pyx_k_NO_O_EPSILSONS, sizeof(__pyx_k_NO_O_EPSILSONS), 0, 0, 1, 1},
  {&__pyx_n_s_NULL_PROPERTIES, __pyx_k_NULL_PROPERTIES, sizeof(__pyx_k_NULL_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_kp_s_No_relabeling_pairs_specified, __pyx_k_No_relabeling_pairs_specified, sizeof(__pyx_k_No_relabeling_pairs_specified), 0, 0, 1, 0},
  {&__pyx_n_s_NotImplementedError, __pyx_k_NotImplementedError, sizeof(__pyx_k_NotImplementedError), 0, 0, 1, 1},
  {&__pyx_n_s_O_DETERMINISTIC, __pyx_k_O_DETERMINISTIC, sizeof(__pyx_k_O_DETERMINISTIC), 0, 0, 1, 1},
  {&__pyx_n_s_O_EPSILONS, __pyx_k_O_EPSILONS, sizeof(__pyx_k_O_EPSILONS), 0, 0, 1, 1},
  {&__pyx_n_s_O_LABEL_INVARIANT_PROPERTIES, __pyx_k_O_LABEL_INVARIANT_PROPERTIES, sizeof(__pyx_k_O_LABEL_INVARIANT_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_O_LABEL_SORTED, __pyx_k_O_LABEL_SORTED, sizeof(__pyx_k_O_LABEL_SORTED), 0, 0, 1, 1},
  {&__pyx_kp_s_Operation_failed, __pyx_k_Operation_failed, sizeof(__pyx_k_Operation_failed), 0, 0, 1, 0},
  {&__pyx_n_s_POS_TRINARY_PROPERTIES, __pyx_k_POS_TRINARY_PROPERTIES, sizeof(__pyx_k_POS_TRINARY_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_RM_SUPERFINAL_PROPERTIES, __pyx_k_RM_SUPERFINAL_PROPERTIES, sizeof(__pyx_k_RM_SUPERFINAL_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_kp_s_Random_equivalence_test_encounte, __pyx_k_Random_equivalence_test_encounte, sizeof(__pyx_k_Random_equivalence_test_encounte), 0, 0, 1, 0},
  {&__pyx_kp_s_Read_failed, __pyx_k_Read_failed, sizeof(__pyx_k_Read_failed), 0, 0, 1, 0},
  {&__pyx_kp_s_Read_time_conversion_to_r_failed, __pyx_k_Read_time_conversion_to_r_failed, sizeof(__pyx_k_Read_time_conversion_to_r_failed), 0, 0, 1, 0},
  {&__pyx_n_s_SET_ARC_PROPERTIES, __pyx_k_SET_ARC_PROPERTIES, sizeof(__pyx_k_SET_ARC_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_SET_FINAL_PROPERTIES, __pyx_k_SET_FINAL_PROPERTIES, sizeof(__pyx_k_SET_FINAL_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_SET_START_PROPERTIES, __pyx_k_SET_START_PROPERTIES, sizeof(__pyx_k_SET_START_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_STATE_SORT_PROPERTIES, __pyx_k_STATE_SORT_PROPERTIES, sizeof(__pyx_k_STATE_SORT_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_STRING, __pyx_k_STRING, sizeof(__pyx_k_STRING), 0, 0, 1, 1},
  {&__pyx_n_s_TOP_SORTED, __pyx_k_TOP_SORTED, sizeof(__pyx_k_TOP_SORTED), 0, 0, 1, 1},
  {&__pyx_n_s_TRINARY_PROPERTIES, __pyx_k_TRINARY_PROPERTIES, sizeof(__pyx_k_TRINARY_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_UNWEIGHTED, __pyx_k_UNWEIGHTED, sizeof(__pyx_k_UNWEIGHTED), 0, 0, 1, 1},
  {&__pyx_kp_s_UTF_8, __pyx_k_UTF_8, sizeof(__pyx_k_UTF_8), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_compose_filter_type_r, __pyx_k_Unknown_compose_filter_type_r, sizeof(__pyx_k_Unknown_compose_filter_type_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_determinize_type_r, __pyx_k_Unknown_determinize_type_r, sizeof(__pyx_k_Unknown_determinize_type_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_map_type_r, __pyx_k_Unknown_map_type_r, sizeof(__pyx_k_Unknown_map_type_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_queue_type_r, __pyx_k_Unknown_queue_type_r, sizeof(__pyx_k_Unknown_queue_type_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_random_arc_selection_typ, __pyx_k_Unknown_random_arc_selection_typ, sizeof(__pyx_k_Unknown_random_arc_selection_typ), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_replace_label_type_r, __pyx_k_Unknown_replace_label_type_r, sizeof(__pyx_k_Unknown_replace_label_type_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_sort_type_r, __pyx_k_Unknown_sort_type_r, sizeof(__pyx_k_Unknown_sort_type_r), 0, 0, 1, 0},
  {&__pyx_n_s_UserWarning, __pyx_k_UserWarning, sizeof(__pyx_k_UserWarning), 0, 0, 1, 1},
  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
  {&__pyx_n_s_WEIGHTED, __pyx_k_WEIGHTED, sizeof(__pyx_k_WEIGHTED), 0, 0, 1, 1},
  {&__pyx_n_s_WEIGHT_INVARIANT_PROPERTIES, __pyx_k_WEIGHT_INVARIANT_PROPERTIES, sizeof(__pyx_k_WEIGHT_INVARIANT_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_kp_s_Warning_for_FST_operations, __pyx_k_Warning_for_FST_operations, sizeof(__pyx_k_Warning_for_FST_operations), 0, 0, 1, 0},
  {&__pyx_kp_s_Write_failed, __pyx_k_Write_failed, sizeof(__pyx_k_Write_failed), 0, 0, 1, 0},
  {&__pyx_kp_b__5, __pyx_k__5, sizeof(__pyx_k__5), 0, 0, 0, 0},
  {&__pyx_n_b_arc_sum, __pyx_k_arc_sum, sizeof(__pyx_k_arc_sum), 0, 0, 0, 1},
  {&__pyx_n_s_arc_type, __pyx_k_arc_type, sizeof(__pyx_k_arc_type), 0, 0, 1, 1},
  {&__pyx_n_s_arcmap, __pyx_k_arcmap, sizeof(__pyx_k_arcmap), 0, 0, 1, 1},
  {&__pyx_n_b_auto, __pyx_k_auto, sizeof(__pyx_k_auto), 0, 0, 0, 1},
  {&__pyx_n_s_cal, __pyx_k_cal, sizeof(__pyx_k_cal), 0, 0, 1, 1},
  {&__pyx_n_s_call_arc_labeling, __pyx_k_call_arc_labeling, sizeof(__pyx_k_call_arc_labeling), 0, 0, 1, 1},
  {&__pyx_n_s_cf, __pyx_k_cf, sizeof(__pyx_k_cf), 0, 0, 1, 1},
  {&__pyx_n_s_check_mutating_imethod, __pyx_k_check_mutating_imethod, sizeof(__pyx_k_check_mutating_imethod), 0, 0, 1, 1},
  {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
  {&__pyx_n_s_closure_plus, __pyx_k_closure_plus, sizeof(__pyx_k_closure_plus), 0, 0, 1, 1},
  {&__pyx_n_s_codex_filename, __pyx_k_codex_filename, sizeof(__pyx_k_codex_filename), 0, 0, 1, 1},
  {&__pyx_n_s_compose, __pyx_k_compose, sizeof(__pyx_k_compose), 0, 0, 1, 1},
  {&__pyx_n_s_connect, __pyx_k_connect, sizeof(__pyx_k_connect), 0, 0, 1, 1},
  {&__pyx_n_s_convert, __pyx_k_convert, sizeof(__pyx_k_convert), 0, 0, 1, 1},
  {&__pyx_n_s_delta, __pyx_k_delta, sizeof(__pyx_k_delta), 0, 0, 1, 1},
  {&__pyx_n_s_det_type, __pyx_k_det_type, sizeof(__pyx_k_det_type), 0, 0, 1, 1},
  {&__pyx_n_s_determinize, __pyx_k_determinize, sizeof(__pyx_k_determinize), 0, 0, 1, 1},
  {&__pyx_n_s_difference, __pyx_k_difference, sizeof(__pyx_k_difference), 0, 0, 1, 1},
  {&__pyx_n_b_disambiguate, __pyx_k_disambiguate, sizeof(__pyx_k_disambiguate), 0, 0, 0, 1},
  {&__pyx_n_s_disambiguate, __pyx_k_disambiguate, sizeof(__pyx_k_disambiguate), 0, 0, 1, 1},
  {&__pyx_n_s_distance, __pyx_k_distance, sizeof(__pyx_k_distance), 0, 0, 1, 1},
  {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
  {&__pyx_n_s_dt, __pyx_k_dt, sizeof(__pyx_k_dt), 0, 0, 1, 1},
  {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
  {&__pyx_n_s_encode_labels, __pyx_k_encode_labels, sizeof(__pyx_k_encode_labels), 0, 0, 1, 1},
  {&__pyx_n_s_encode_reuse, __pyx_k_encode_reuse, sizeof(__pyx_k_encode_reuse), 0, 0, 1, 1},
  {&__pyx_n_s_encode_weights, __pyx_k_encode_weights, sizeof(__pyx_k_encode_weights), 0, 0, 1, 1},
  {&__pyx_n_s_eps_norm_output, __pyx_k_eps_norm_output, sizeof(__pyx_k_eps_norm_output), 0, 0, 1, 1},
  {&__pyx_n_s_epsilon_on_replace, __pyx_k_epsilon_on_replace, sizeof(__pyx_k_epsilon_on_replace), 0, 0, 1, 1},
  {&__pyx_n_s_epsnormalize, __pyx_k_epsnormalize, sizeof(__pyx_k_epsnormalize), 0, 0, 1, 1},
  {&__pyx_n_s_equal, __pyx_k_equal, sizeof(__pyx_k_equal), 0, 0, 1, 1},
  {&__pyx_n_s_equivalent, __pyx_k_equivalent, sizeof(__pyx_k_equivalent), 0, 0, 1, 1},
  {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
  {&__pyx_n_s_filename, __pyx_k_filename, sizeof(__pyx_k_filename), 0, 0, 1, 1},
  {&__pyx_n_s_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 0, 0, 1, 1},
  {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
  {&__pyx_n_s_fst, __pyx_k_fst, sizeof(__pyx_k_fst), 0, 0, 1, 1},
  {&__pyx_n_s_fst_error_fatal_old, __pyx_k_fst_error_fatal_old, sizeof(__pyx_k_fst_error_fatal_old), 0, 0, 1, 1},
  {&__pyx_n_s_fst_type, __pyx_k_fst_type, sizeof(__pyx_k_fst_type), 0, 0, 1, 1},
  {&__pyx_n_s_fst_type_2, __pyx_k_fst_type_2, sizeof(__pyx_k_fst_type_2), 0, 0, 1, 1},
  {&__pyx_n_b_functional, __pyx_k_functional, sizeof(__pyx_k_functional), 0, 0, 0, 1},
  {&__pyx_n_s_get_compose_filter, __pyx_k_get_compose_filter, sizeof(__pyx_k_get_compose_filter), 0, 0, 1, 1},
  {&__pyx_n_s_get_queue_type, __pyx_k_get_queue_type, sizeof(__pyx_k_get_queue_type), 0, 0, 1, 1},
  {&__pyx_n_s_get_rand_arc_selection, __pyx_k_get_rand_arc_selection, sizeof(__pyx_k_get_rand_arc_selection), 0, 0, 1, 1},
  {&__pyx_n_s_get_replace_label_type, __pyx_k_get_replace_label_type, sizeof(__pyx_k_get_replace_label_type), 0, 0, 1, 1},
  {&__pyx_n_s_hex, __pyx_k_hex, sizeof(__pyx_k_hex), 0, 0, 1, 1},
  {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
  {&__pyx_n_b_identity, __pyx_k_identity, sizeof(__pyx_k_identity), 0, 0, 0, 1},
  {&__pyx_n_s_ifst, __pyx_k_ifst, sizeof(__pyx_k_ifst), 0, 0, 1, 1},
  {&__pyx_n_s_ifst1, __pyx_k_ifst1, sizeof(__pyx_k_ifst1), 0, 0, 1, 1},
  {&__pyx_n_s_ifst2, __pyx_k_ifst2, sizeof(__pyx_k_ifst2), 0, 0, 1, 1},
  {&__pyx_n_b_ilabel, __pyx_k_ilabel, sizeof(__pyx_k_ilabel), 0, 0, 0, 1},
  {&__pyx_n_s_increment_subsequential_label, __pyx_k_increment_subsequential_label, sizeof(__pyx_k_increment_subsequential_label), 0, 0, 1, 1},
  {&__pyx_n_b_input, __pyx_k_input, sizeof(__pyx_k_input), 0, 0, 0, 1},
  {&__pyx_n_s_intersect, __pyx_k_intersect, sizeof(__pyx_k_intersect), 0, 0, 1, 1},
  {&__pyx_n_b_invert, __pyx_k_invert, sizeof(__pyx_k_invert), 0, 0, 0, 1},
  {&__pyx_n_s_ipairs, __pyx_k_ipairs, sizeof(__pyx_k_ipairs), 0, 0, 1, 1},
  {&__pyx_n_s_isomorphic, __pyx_k_isomorphic, sizeof(__pyx_k_isomorphic), 0, 0, 1, 1},
  {&__pyx_n_s_it, __pyx_k_it, sizeof(__pyx_k_it), 0, 0, 1, 1},
  {&__pyx_n_s_label, __pyx_k_label, sizeof(__pyx_k_label), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_map_type, __pyx_k_map_type, sizeof(__pyx_k_map_type), 0, 0, 1, 1},
  {&__pyx_n_s_mask, __pyx_k_mask, sizeof(__pyx_k_mask), 0, 0, 1, 1},
  {&__pyx_n_s_max_length, __pyx_k_max_length, sizeof(__pyx_k_max_length), 0, 0, 1, 1},
  {&__pyx_n_s_metaclass, __pyx_k_metaclass, sizeof(__pyx_k_metaclass), 0, 0, 1, 1},
  {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
  {&__pyx_n_s_mt, __pyx_k_mt, sizeof(__pyx_k_mt), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_b_neither, __pyx_k_neither, sizeof(__pyx_k_neither), 0, 0, 0, 1},
  {&__pyx_n_b_nonfunctional, __pyx_k_nonfunctional, sizeof(__pyx_k_nonfunctional), 0, 0, 0, 1},
  {&__pyx_n_s_npath, __pyx_k_npath, sizeof(__pyx_k_npath), 0, 0, 1, 1},
  {&__pyx_n_s_nshortest, __pyx_k_nshortest, sizeof(__pyx_k_nshortest), 0, 0, 1, 1},
  {&__pyx_n_s_nstate, __pyx_k_nstate, sizeof(__pyx_k_nstate), 0, 0, 1, 1},
  {&__pyx_n_b_olabel, __pyx_k_olabel, sizeof(__pyx_k_olabel), 0, 0, 0, 1},
  {&__pyx_n_s_opairs, __pyx_k_opairs, sizeof(__pyx_k_opairs), 0, 0, 1, 1},
  {&__pyx_n_s_opts, __pyx_k_opts, sizeof(__pyx_k_opts), 0, 0, 1, 1},
  {&__pyx_n_s_pairs, __pyx_k_pairs, sizeof(__pyx_k_pairs), 0, 0, 1, 1},
  {&__pyx_n_s_pairs_2, __pyx_k_pairs_2, sizeof(__pyx_k_pairs_2), 0, 0, 1, 1},
  {&__pyx_n_b_plus, __pyx_k_plus, sizeof(__pyx_k_plus), 0, 0, 0, 1},
  {&__pyx_n_s_potentials, __pyx_k_potentials, sizeof(__pyx_k_potentials), 0, 0, 1, 1},
  {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
  {&__pyx_n_s_project_output, __pyx_k_project_output, sizeof(__pyx_k_project_output), 0, 0, 1, 1},
  {&__pyx_n_s_properties, __pyx_k_properties, sizeof(__pyx_k_properties), 0, 0, 1, 1},
  {&__pyx_n_s_property, __pyx_k_property, sizeof(__pyx_k_property), 0, 0, 1, 1},
  {&__pyx_n_s_prune, __pyx_k_prune, sizeof(__pyx_k_prune), 0, 0, 1, 1},
  {&__pyx_n_s_push, __pyx_k_push, sizeof(__pyx_k_push), 0, 0, 1, 1},
  {&__pyx_n_s_push_labels, __pyx_k_push_labels, sizeof(__pyx_k_push_labels), 0, 0, 1, 1},
  {&__pyx_n_s_push_weights, __pyx_k_push_weights, sizeof(__pyx_k_push_weights), 0, 0, 1, 1},
  {&__pyx_n_s_qt, __pyx_k_qt, sizeof(__pyx_k_qt), 0, 0, 1, 1},
  {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
  {&__pyx_n_b_quantize, __pyx_k_quantize, sizeof(__pyx_k_quantize), 0, 0, 0, 1},
  {&__pyx_n_s_queue_type, __pyx_k_queue_type, sizeof(__pyx_k_queue_type), 0, 0, 1, 1},
  {&__pyx_n_s_ral, __pyx_k_ral, sizeof(__pyx_k_ral), 0, 0, 1, 1},
  {&__pyx_n_s_randequivalent, __pyx_k_randequivalent, sizeof(__pyx_k_randequivalent), 0, 0, 1, 1},
  {&__pyx_n_s_randgen, __pyx_k_randgen, sizeof(__pyx_k_randgen), 0, 0, 1, 1},
  {&__pyx_n_s_ras, __pyx_k_ras, sizeof(__pyx_k_ras), 0, 0, 1, 1},
  {&__pyx_n_s_remove_common_affix, __pyx_k_remove_common_affix, sizeof(__pyx_k_remove_common_affix), 0, 0, 1, 1},
  {&__pyx_n_s_remove_total_weight, __pyx_k_remove_total_weight, sizeof(__pyx_k_remove_total_weight), 0, 0, 1, 1},
  {&__pyx_n_s_replace, __pyx_k_replace, sizeof(__pyx_k_replace), 0, 0, 1, 1},
  {&__pyx_n_s_require_superinitial, __pyx_k_require_superinitial, sizeof(__pyx_k_require_superinitial), 0, 0, 1, 1},
  {&__pyx_n_s_result, __pyx_k_result, sizeof(__pyx_k_result), 0, 0, 1, 1},
  {&__pyx_n_s_return_arc_labeling, __pyx_k_return_arc_labeling, sizeof(__pyx_k_return_arc_labeling), 0, 0, 1, 1},
  {&__pyx_n_s_return_label, __pyx_k_return_label, sizeof(__pyx_k_return_label), 0, 0, 1, 1},
  {&__pyx_n_s_reverse, __pyx_k_reverse, sizeof(__pyx_k_reverse), 0, 0, 1, 1},
  {&__pyx_n_s_rlt, __pyx_k_rlt, sizeof(__pyx_k_rlt), 0, 0, 1, 1},
  {&__pyx_n_s_rmepsilon, __pyx_k_rmepsilon, sizeof(__pyx_k_rmepsilon), 0, 0, 1, 1},
  {&__pyx_n_b_rmweight, __pyx_k_rmweight, sizeof(__pyx_k_rmweight), 0, 0, 0, 1},
  {&__pyx_n_s_root_label, __pyx_k_root_label, sizeof(__pyx_k_root_label), 0, 0, 1, 1},
  {&__pyx_n_s_rt, __pyx_k_rt, sizeof(__pyx_k_rt), 0, 0, 1, 1},
  {&__pyx_n_s_seed, __pyx_k_seed, sizeof(__pyx_k_seed), 0, 0, 1, 1},
  {&__pyx_n_s_select, __pyx_k_select, sizeof(__pyx_k_select), 0, 0, 1, 1},
  {&__pyx_n_s_shortestdistance, __pyx_k_shortestdistance, sizeof(__pyx_k_shortestdistance), 0, 0, 1, 1},
  {&__pyx_n_s_shortestpath, __pyx_k_shortestpath, sizeof(__pyx_k_shortestpath), 0, 0, 1, 1},
  {&__pyx_n_s_sort_type, __pyx_k_sort_type, sizeof(__pyx_k_sort_type), 0, 0, 1, 1},
  {&__pyx_n_s_string, __pyx_k_string, sizeof(__pyx_k_string), 0, 0, 1, 1},
  {&__pyx_n_s_subsequential_label, __pyx_k_subsequential_label, sizeof(__pyx_k_subsequential_label), 0, 0, 1, 1},
  {&__pyx_n_b_superfinal, __pyx_k_superfinal, sizeof(__pyx_k_superfinal), 0, 0, 0, 1},
  {&__pyx_n_s_synchronize, __pyx_k_synchronize, sizeof(__pyx_k_synchronize), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_test_2, __pyx_k_test_2, sizeof(__pyx_k_test_2), 0, 0, 1, 1},
  {&__pyx_n_s_tfst, __pyx_k_tfst, sizeof(__pyx_k_tfst), 0, 0, 1, 1},
  {&__pyx_n_b_times, __pyx_k_times, sizeof(__pyx_k_times), 0, 0, 0, 1},
  {&__pyx_n_s_to_final, __pyx_k_to_final, sizeof(__pyx_k_to_final), 0, 0, 1, 1},
  {&__pyx_n_b_to_log, __pyx_k_to_log, sizeof(__pyx_k_to_log), 0, 0, 0, 1},
  {&__pyx_n_b_to_log64, __pyx_k_to_log64, sizeof(__pyx_k_to_log64), 0, 0, 0, 1},
  {&__pyx_n_b_to_standard, __pyx_k_to_standard, sizeof(__pyx_k_to_standard), 0, 0, 0, 1},
  {&__pyx_n_s_type, __pyx_k_type, sizeof(__pyx_k_type), 0, 0, 1, 1},
  {&__pyx_kp_s_type_r_string_r, __pyx_k_type_r_string_r, sizeof(__pyx_k_type_r_string_r), 0, 0, 1, 0},
  {&__pyx_n_b_uniform, __pyx_k_uniform, sizeof(__pyx_k_uniform), 0, 0, 0, 1},
  {&__pyx_n_s_unique, __pyx_k_unique, sizeof(__pyx_k_unique), 0, 0, 1, 1},
  {&__pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_k_usr_local_google_home_kbg_tmp_O, sizeof(__pyx_k_usr_local_google_home_kbg_tmp_O), 0, 0, 1, 0},
  {&__pyx_n_s_wc, __pyx_k_wc, sizeof(__pyx_k_wc), 0, 0, 1, 1},
  {&__pyx_n_s_weight, __pyx_k_weight, sizeof(__pyx_k_weight), 0, 0, 1, 1},
  {&__pyx_n_s_weight_string, __pyx_k_weight_string, sizeof(__pyx_k_weight_string), 0, 0, 1, 1},
  {&__pyx_n_s_weight_type, __pyx_k_weight_type, sizeof(__pyx_k_weight_type), 0, 0, 1, 1},
  {&__pyx_n_s_weight_type_2, __pyx_k_weight_type_2, sizeof(__pyx_k_weight_type_2), 0, 0, 1, 1},
  {&__pyx_n_s_weighted, __pyx_k_weighted, sizeof(__pyx_k_weighted), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_UserWarning = __Pyx_GetBuiltinName(__pyx_n_s_UserWarning); if (!__pyx_builtin_UserWarning) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_property = __Pyx_GetBuiltinName(__pyx_n_s_property); if (!__pyx_builtin_property) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 706; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_Exception = __Pyx_GetBuiltinName(__pyx_n_s_Exception); if (!__pyx_builtin_Exception) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 546; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s_NotImplementedError); if (!__pyx_builtin_NotImplementedError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_hex = __Pyx_GetBuiltinName(__pyx_n_s_hex); if (!__pyx_builtin_hex) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "fst.pyx":545
 *   try:
 *     # Tries to cast to string if necessary
 *     return (data if hasattr(data, "encode") else str(data)).encode("UTF-8")             # <<<<<<<<<<<<<<
 *   except Exception:
 *     raise ValueError("Cannot encode {!r} as bytestring".format(data))
 */
  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_UTF_8); if (unlikely(!__pyx_tuple_)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);

  /* "fst.pyx":736
 *     """
 *     if not self.fst.Write(tobytes(filename)):
 *       raise FstError("Write failed")             # <<<<<<<<<<<<<<
 * 
 *   def properties(self, uint64 mask, bool test=True):
 */
  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_Write_failed); if (unlikely(!__pyx_tuple__2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 736; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__2);
  __Pyx_GIVEREF(__pyx_tuple__2);

  /* "fst.pyx":808
 *     """
 *     if self.properties(ERROR):
 *       raise FstError("Operation failed")             # <<<<<<<<<<<<<<
 * 
 *   def arcsort(self, sort_type=b"ilabel"):
 */
  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_Operation_failed); if (unlikely(!__pyx_tuple__3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__3);
  __Pyx_GIVEREF(__pyx_tuple__3);

  /* "fst.pyx":1028
 *         _opairs.push_back(pair[int64, int64](before, after))
 *     if _ipairs.empty() and _opairs.empty():
 *       raise FstError("No relabeling pairs specified")             # <<<<<<<<<<<<<<
 *     Relabel(self.mfst, _ipairs, _opairs)
 *     self._check_mutating_imethod()
 */
  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_No_relabeling_pairs_specified); if (unlikely(!__pyx_tuple__9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1028; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__9);
  __Pyx_GIVEREF(__pyx_tuple__9);

  /* "fst.pyx":1091
 *     # TopSort returns False if the FST is cyclic, and thus can't be TopSorted.
 *     if not TopSort(self.mfst):
 *       FstWarning("Input FST is cyclic.")             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_Input_FST_is_cyclic); if (unlikely(!__pyx_tuple__12)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__12);
  __Pyx_GIVEREF(__pyx_tuple__12);

  /* "fst.pyx":1120
 * cdef _init_Fst(FstClass *tfst):
 *   if tfst.Properties(kError, True):
 *     raise FstError("Operation failed")             # <<<<<<<<<<<<<<
 *   cdef _Fst ofst = _Fst.__new__(_Fst)
 *   ofst.fst = tfst
 */
  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_Operation_failed); if (unlikely(!__pyx_tuple__13)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__13);
  __Pyx_GIVEREF(__pyx_tuple__13);

  /* "fst.pyx":1128
 * cdef _init_MutableFst(MutableFstClass *tfst):
 *   if tfst.Properties(kError, True):
 *     raise FstError("Operation failed")             # <<<<<<<<<<<<<<
 *   cdef _MutableFst ofst = _MutableFst.__new__(_MutableFst)
 *   ofst.mfst = ofst.fst = tfst
 */
  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_Operation_failed); if (unlikely(!__pyx_tuple__14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__14);
  __Pyx_GIVEREF(__pyx_tuple__14);

  /* "fst.pyx":1155
 *   cdef FstClass *tfst = Read(tobytes(filename))
 *   if tfst == NULL:
 *    raise FstError("Read failed")             # <<<<<<<<<<<<<<
 *   # Convert if requested.
 *   cdef string _fst_type = tobytes(fst_type)
 */
  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_Read_failed); if (unlikely(!__pyx_tuple__15)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__15);
  __Pyx_GIVEREF(__pyx_tuple__15);

  /* "fst.pyx":1253
 *   """
 *   if ifst1._arc_type != ifst2._arc_type:
 *     raise FstError("Input FSTs must have the same arc type")             # <<<<<<<<<<<<<<
 *   cdef VectorFstClass *tfst = new VectorFstClass(ifst1._arc_type)
 *   cdef const ComposeOptions *opts = new ComposeOptions(connect,
 */
  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_Input_FSTs_must_have_the_same_ar); if (unlikely(!__pyx_tuple__17)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__17);
  __Pyx_GIVEREF(__pyx_tuple__17);

  /* "fst.pyx":1455
 *   result = Equivalent(deref(ifst1.fst), deref(ifst2.fst), delta, &error)
 *   if error:
 *     raise FstError("Equivalence test encountered error")             # <<<<<<<<<<<<<<
 *   return result
 * 
 */
  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_Equivalence_test_encountered_err); if (unlikely(!__pyx_tuple__25)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1455; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__25);
  __Pyx_GIVEREF(__pyx_tuple__25);

  /* "fst.pyx":1510
 *   result = Isomorphic(deref(ifst1.fst), deref(ifst2.fst), delta, &error)
 *   if error:
 *     raise FstError("Isomorphism test encountered error")             # <<<<<<<<<<<<<<
 *   return result
 * 
 */
  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_Isomorphism_test_encountered_err); if (unlikely(!__pyx_tuple__27)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1510; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__27);
  __Pyx_GIVEREF(__pyx_tuple__27);

  /* "fst.pyx":1626
 *   try:
 *     if error:
 *       raise FstError("Random equivalence test encountered error")             # <<<<<<<<<<<<<<
 *   finally:
 *     del opts
 */
  __pyx_tuple__34 = PyTuple_Pack(1, __pyx_kp_s_Random_equivalence_test_encounte); if (unlikely(!__pyx_tuple__34)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1626; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__34);
  __Pyx_GIVEREF(__pyx_tuple__34);

  /* "fst.pyx":550
 * 
 * 
 * def _get_compose_filter(string cf):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate ComposeFilter enum value.
 * 
 */
  __pyx_tuple__43 = PyTuple_Pack(2, __pyx_n_s_cf, __pyx_n_s_cf); if (unlikely(!__pyx_tuple__43)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 550; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__43);
  __Pyx_GIVEREF(__pyx_tuple__43);
  __pyx_codeobj__44 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__43, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_get_compose_filter, 550, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__44)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 550; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":579
 * 
 * 
 * def _get_queue_type(string qt):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate QueueType enum value.
 * 
 */
  __pyx_tuple__45 = PyTuple_Pack(2, __pyx_n_s_qt, __pyx_n_s_qt); if (unlikely(!__pyx_tuple__45)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__45);
  __Pyx_GIVEREF(__pyx_tuple__45);
  __pyx_codeobj__46 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__45, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_get_queue_type, 579, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__46)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":609
 * 
 * 
 * def _get_rand_arc_selection(string ras):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate RandArcSelection enum value.
 * 
 */
  __pyx_tuple__47 = PyTuple_Pack(2, __pyx_n_s_ras, __pyx_n_s_ras); if (unlikely(!__pyx_tuple__47)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__47);
  __Pyx_GIVEREF(__pyx_tuple__47);
  __pyx_codeobj__48 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__47, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_get_rand_arc_selection, 609, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__48)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":633
 * 
 * 
 * def _get_replace_label_type(string rlt, bool epsilon_on_replace):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate ReplaceLabelType enum value.
 * 
 */
  __pyx_tuple__49 = PyTuple_Pack(2, __pyx_n_s_rlt, __pyx_n_s_epsilon_on_replace); if (unlikely(!__pyx_tuple__49)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__49);
  __Pyx_GIVEREF(__pyx_tuple__49);
  __pyx_codeobj__50 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__49, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_get_replace_label_type, 633, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__50)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1141
 * 
 * 
 * def Fst(filename, fst_type=b""):             # <<<<<<<<<<<<<<
 *   """Constructs an FST from a file.
 * 
 */
  __pyx_tuple__51 = PyTuple_Pack(4, __pyx_n_s_filename, __pyx_n_s_fst_type_2, __pyx_n_s_tfst, __pyx_n_s_fst_type); if (unlikely(!__pyx_tuple__51)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__51);
  __Pyx_GIVEREF(__pyx_tuple__51);
  __pyx_codeobj__52 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__51, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_Fst, 1141, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__52)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1169
 * 
 * 
 * def arcmap(_Fst ifst, float delta=kDelta, map_type=b"identity", weight=b""):             # <<<<<<<<<<<<<<
 *   """Constructively applies a transform to all arcs and final states.
 * 
 */
  __pyx_tuple__53 = PyTuple_Pack(6, __pyx_n_s_ifst, __pyx_n_s_delta, __pyx_n_s_map_type, __pyx_n_s_weight, __pyx_n_s_mt, __pyx_n_s_wc); if (unlikely(!__pyx_tuple__53)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__53);
  __Pyx_GIVEREF(__pyx_tuple__53);
  __pyx_codeobj__54 = (PyObject*)__Pyx_PyCode_New(4, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__53, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_arcmap, 1169, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__54)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1229
 * 
 * 
 * def compose(_Fst ifst1, _Fst ifst2, cf=b"auto", bool connect=True):             # <<<<<<<<<<<<<<
 *   """Constructively composes two FSTs.
 * 
 */
  __pyx_tuple__55 = PyTuple_Pack(6, __pyx_n_s_ifst1, __pyx_n_s_ifst2, __pyx_n_s_cf, __pyx_n_s_connect, __pyx_n_s_tfst, __pyx_n_s_opts); if (unlikely(!__pyx_tuple__55)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__55);
  __Pyx_GIVEREF(__pyx_tuple__55);
  __pyx_codeobj__56 = (PyObject*)__Pyx_PyCode_New(4, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__55, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_compose, 1229, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__56)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1262
 * 
 * 
 * def convert(_Fst ifst, fst_type=b""):             # <<<<<<<<<<<<<<
 *   """Constructively converts an FST to a new internal representation.
 * 
 */
  __pyx_tuple__57 = PyTuple_Pack(3, __pyx_n_s_ifst, __pyx_n_s_fst_type_2, __pyx_n_s_tfst); if (unlikely(!__pyx_tuple__57)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__57);
  __Pyx_GIVEREF(__pyx_tuple__57);
  __pyx_codeobj__58 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__57, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_convert, 1262, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__58)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1280
 * 
 * 
 * def determinize(_Fst ifst, float delta=kDelta, det_type=b"functional",             # <<<<<<<<<<<<<<
 *                 int64 nstate=kNoStateId, int64 subsequential_label=0,
 *                 weight=b"", bool increment_subsequential_label=False):
 */
  __pyx_tuple__59 = PyTuple_Pack(11, __pyx_n_s_ifst, __pyx_n_s_delta, __pyx_n_s_det_type, __pyx_n_s_nstate, __pyx_n_s_subsequential_label, __pyx_n_s_weight, __pyx_n_s_increment_subsequential_label, __pyx_n_s_tfst, __pyx_n_s_wc, __pyx_n_s_dt, __pyx_n_s_opts); if (unlikely(!__pyx_tuple__59)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__59);
  __Pyx_GIVEREF(__pyx_tuple__59);
  __pyx_codeobj__60 = (PyObject*)__Pyx_PyCode_New(7, 0, 11, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__59, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_determinize, 1280, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__60)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1328
 * 
 * 
 * def difference(_Fst ifst1, _Fst ifst2, cf=b"auto", bool connect=True):             # <<<<<<<<<<<<<<
 *   """Constructively computes the difference of two FSTs.
 * 
 */
  __pyx_tuple__61 = PyTuple_Pack(6, __pyx_n_s_ifst1, __pyx_n_s_ifst2, __pyx_n_s_cf, __pyx_n_s_connect, __pyx_n_s_tfst, __pyx_n_s_opts); if (unlikely(!__pyx_tuple__61)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__61);
  __Pyx_GIVEREF(__pyx_tuple__61);
  __pyx_codeobj__62 = (PyObject*)__Pyx_PyCode_New(4, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__61, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_difference, 1328, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__62)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1355
 * 
 * 
 * def disambiguate(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId,             # <<<<<<<<<<<<<<
 *                  int64 subsequential_label=0, string weight=b""):
 *   """Constructively disambiguates a weighted transducer.
 */
  __pyx_tuple__63 = PyTuple_Pack(8, __pyx_n_s_ifst, __pyx_n_s_delta, __pyx_n_s_nstate, __pyx_n_s_subsequential_label, __pyx_n_s_weight, __pyx_n_s_tfst, __pyx_n_s_wc, __pyx_n_s_opts); if (unlikely(!__pyx_tuple__63)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__63);
  __Pyx_GIVEREF(__pyx_tuple__63);
  __pyx_codeobj__64 = (PyObject*)__Pyx_PyCode_New(5, 0, 8, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__63, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_disambiguate, 1355, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__64)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1387
 * 
 * 
 * def epsnormalize(_Fst ifst, bool eps_norm_output=False):             # <<<<<<<<<<<<<<
 *   """Constructively epsilon-normalizes an FST.
 * 
 */
  __pyx_tuple__65 = PyTuple_Pack(3, __pyx_n_s_ifst, __pyx_n_s_eps_norm_output, __pyx_n_s_tfst); if (unlikely(!__pyx_tuple__65)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__65);
  __Pyx_GIVEREF(__pyx_tuple__65);
  __pyx_codeobj__66 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__65, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_epsnormalize, 1387, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__66)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1412
 * 
 * 
 * def equal(_Fst ifst1, _Fst ifst2, float delta=kDelta):             # <<<<<<<<<<<<<<
 *   """Are two FSTs equal?
 * 
 */
  __pyx_tuple__67 = PyTuple_Pack(3, __pyx_n_s_ifst1, __pyx_n_s_ifst2, __pyx_n_s_delta); if (unlikely(!__pyx_tuple__67)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__67);
  __Pyx_GIVEREF(__pyx_tuple__67);
  __pyx_codeobj__68 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__67, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_equal, 1412, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__68)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1432
 * 
 * 
 * def equivalent(_Fst ifst1, _Fst ifst2, float delta=kDelta):             # <<<<<<<<<<<<<<
 *   """Are the two acceptors equivalent?
 * 
 */
  __pyx_tuple__69 = PyTuple_Pack(5, __pyx_n_s_ifst1, __pyx_n_s_ifst2, __pyx_n_s_delta, __pyx_n_s_result, __pyx_n_s_error); if (unlikely(!__pyx_tuple__69)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__69);
  __Pyx_GIVEREF(__pyx_tuple__69);
  __pyx_codeobj__70 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__69, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_equivalent, 1432, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__70)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1459
 * 
 * 
 * def intersect(_Fst ifst1, _Fst ifst2, cf=b"auto", bool connect=True):             # <<<<<<<<<<<<<<
 *   """Constructively intersects two FSTs.
 * 
 */
  __pyx_tuple__71 = PyTuple_Pack(6, __pyx_n_s_ifst1, __pyx_n_s_ifst2, __pyx_n_s_cf, __pyx_n_s_connect, __pyx_n_s_tfst, __pyx_n_s_opts); if (unlikely(!__pyx_tuple__71)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__71);
  __Pyx_GIVEREF(__pyx_tuple__71);
  __pyx_codeobj__72 = (PyObject*)__Pyx_PyCode_New(4, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__71, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_intersect, 1459, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__72)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1484
 * 
 * 
 * def isomorphic(_Fst ifst1, _Fst ifst2, float delta=kDelta):             # <<<<<<<<<<<<<<
 *   """Are the two acceptors isomorphic?
 * 
 */
  __pyx_tuple__73 = PyTuple_Pack(5, __pyx_n_s_ifst1, __pyx_n_s_ifst2, __pyx_n_s_delta, __pyx_n_s_result, __pyx_n_s_error); if (unlikely(!__pyx_tuple__73)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__73);
  __Pyx_GIVEREF(__pyx_tuple__73);
  __pyx_codeobj__74 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__73, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_isomorphic, 1484, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__74)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1514
 * 
 * 
 * def prune(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId, weight=b""):             # <<<<<<<<<<<<<<
 *   """Constructively removes paths with weights below a certain threshold.
 * 
 */
  __pyx_tuple__75 = PyTuple_Pack(6, __pyx_n_s_ifst, __pyx_n_s_delta, __pyx_n_s_nstate, __pyx_n_s_weight, __pyx_n_s_tfst, __pyx_n_s_wc); if (unlikely(!__pyx_tuple__75)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__75);
  __Pyx_GIVEREF(__pyx_tuple__75);
  __pyx_codeobj__76 = (PyObject*)__Pyx_PyCode_New(4, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__75, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_prune, 1514, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__76)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1540
 * 
 * 
 * def push(_Fst ifst, float delta=kDelta, bool push_weights=False,             # <<<<<<<<<<<<<<
 *          bool push_labels=False, bool remove_common_affix=False,
 *          bool remove_total_weight=False, bool to_final=False):
 */
  __pyx_tuple__77 = PyTuple_Pack(10, __pyx_n_s_ifst, __pyx_n_s_delta, __pyx_n_s_push_weights, __pyx_n_s_push_labels, __pyx_n_s_remove_common_affix, __pyx_n_s_remove_total_weight, __pyx_n_s_to_final, __pyx_n_s_tfst, __pyx_n_s_flags, __pyx_n_s_rt); if (unlikely(!__pyx_tuple__77)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__77);
  __Pyx_GIVEREF(__pyx_tuple__77);
  __pyx_codeobj__78 = (PyObject*)__Pyx_PyCode_New(7, 0, 10, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__77, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_push, 1540, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__78)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1593
 * 
 * 
 * def randequivalent(_Fst ifst1, _Fst ifst2, float delta=kDelta,             # <<<<<<<<<<<<<<
 *                    int32 max_length=INT_MAX, int32 npath=1,
 *                    int32 seed=time(NULL), select=b"uniform"):
 */
  __pyx_tuple__79 = PyTuple_Pack(11, __pyx_n_s_ifst1, __pyx_n_s_ifst2, __pyx_n_s_delta, __pyx_n_s_max_length, __pyx_n_s_npath, __pyx_n_s_seed, __pyx_n_s_select, __pyx_n_s_ras, __pyx_n_s_opts, __pyx_n_s_result, __pyx_n_s_error); if (unlikely(!__pyx_tuple__79)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1593; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__79);
  __Pyx_GIVEREF(__pyx_tuple__79);
  __pyx_codeobj__80 = (PyObject*)__Pyx_PyCode_New(7, 0, 11, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__79, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_randequivalent, 1593, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__80)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1593; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1632
 * 
 * 
 * def randgen(_Fst ifst, int32 max_length=INT_MAX, int32 npath=1,             # <<<<<<<<<<<<<<
 *             bool remove_total_weight=False, int32 seed=time(NULL),
 *             select=b"uniform", bool weighted=False):
 */
  __pyx_tuple__81 = PyTuple_Pack(10, __pyx_n_s_ifst, __pyx_n_s_max_length, __pyx_n_s_npath, __pyx_n_s_remove_total_weight, __pyx_n_s_seed, __pyx_n_s_select, __pyx_n_s_weighted, __pyx_n_s_ras, __pyx_n_s_opts, __pyx_n_s_tfst); if (unlikely(!__pyx_tuple__81)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__81);
  __Pyx_GIVEREF(__pyx_tuple__81);
  __pyx_codeobj__82 = (PyObject*)__Pyx_PyCode_New(7, 0, 10, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__81, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_randgen, 1632, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__82)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1669
 * 
 * 
 * def replace(pairs, call_arc_labeling=b"input", return_arc_labeling=b"neither",             # <<<<<<<<<<<<<<
 *             bool epsilon_on_replace=False, int64 return_label=0):
 *   """Recursively replaces arcs in the FST with other FST(s).
 */
  __pyx_tuple__83 = PyTuple_Pack(14, __pyx_n_s_pairs, __pyx_n_s_call_arc_labeling, __pyx_n_s_return_arc_labeling, __pyx_n_s_epsilon_on_replace, __pyx_n_s_return_label, __pyx_n_s_pairs_2, __pyx_n_s_root_label, __pyx_n_s_label, __pyx_n_s_ifst, __pyx_n_s_it, __pyx_n_s_tfst, __pyx_n_s_cal, __pyx_n_s_ral, __pyx_n_s_opts); if (unlikely(!__pyx_tuple__83)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__83);
  __Pyx_GIVEREF(__pyx_tuple__83);
  __pyx_codeobj__84 = (PyObject*)__Pyx_PyCode_New(5, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__83, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_replace, 1669, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__84)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1724
 * 
 * 
 * def reverse(_Fst ifst, bool require_superinitial=True):             # <<<<<<<<<<<<<<
 *   """Constructively reverses an FST's transduction.
 * 
 */
  __pyx_tuple__85 = PyTuple_Pack(3, __pyx_n_s_ifst, __pyx_n_s_require_superinitial, __pyx_n_s_tfst); if (unlikely(!__pyx_tuple__85)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1724; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__85);
  __Pyx_GIVEREF(__pyx_tuple__85);
  __pyx_codeobj__86 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__85, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_reverse, 1724, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__86)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1724; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1745
 * 
 * 
 * def rmepsilon(_Fst ifst, bool connect=True, float delta=kDelta,             # <<<<<<<<<<<<<<
 *               int64 nstate=kNoStateId, queue_type=b"auto", bool reverse=False,
 *               weight=b""):
 */
  __pyx_tuple__87 = PyTuple_Pack(11, __pyx_n_s_ifst, __pyx_n_s_connect, __pyx_n_s_delta, __pyx_n_s_nstate, __pyx_n_s_queue_type, __pyx_n_s_reverse, __pyx_n_s_weight, __pyx_n_s_qt, __pyx_n_s_wc, __pyx_n_s_opts, __pyx_n_s_tfst); if (unlikely(!__pyx_tuple__87)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1745; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__87);
  __Pyx_GIVEREF(__pyx_tuple__87);
  __pyx_codeobj__88 = (PyObject*)__Pyx_PyCode_New(7, 0, 11, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__87, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_rmepsilon, 1745, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__88)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1745; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1776
 * 
 * 
 * def shortestdistance(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId,             # <<<<<<<<<<<<<<
 *                      queue_type=b"auto", bool reverse=False):
 *   """Compute the shortest distance from the initial or final state.
 */
  __pyx_tuple__89 = PyTuple_Pack(11, __pyx_n_s_ifst, __pyx_n_s_delta, __pyx_n_s_nstate, __pyx_n_s_queue_type, __pyx_n_s_reverse, __pyx_n_s_distance, __pyx_n_s_qt, __pyx_n_s_opts, __pyx_n_s_weight_type, __pyx_n_s_result, __pyx_n_s_it); if (unlikely(!__pyx_tuple__89)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1776; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__89);
  __Pyx_GIVEREF(__pyx_tuple__89);
  __pyx_codeobj__90 = (PyObject*)__Pyx_PyCode_New(5, 0, 11, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__89, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_shortestdistance, 1776, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__90)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1776; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1826
 * 
 * 
 * def shortestpath(_Fst ifst, float delta=kDelta, int64 nshortest=1,             # <<<<<<<<<<<<<<
 *                  int64 nstate=kNoStateId, queue_type=b"auto",
 *                  bool unique=False, weight=b""):
 */
  __pyx_tuple__91 = PyTuple_Pack(12, __pyx_n_s_ifst, __pyx_n_s_delta, __pyx_n_s_nshortest, __pyx_n_s_nstate, __pyx_n_s_queue_type, __pyx_n_s_unique, __pyx_n_s_weight, __pyx_n_s_tfst, __pyx_n_s_distance, __pyx_n_s_qt, __pyx_n_s_wc, __pyx_n_s_opts); if (unlikely(!__pyx_tuple__91)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__91);
  __Pyx_GIVEREF(__pyx_tuple__91);
  __pyx_codeobj__92 = (PyObject*)__Pyx_PyCode_New(7, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__91, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_shortestpath, 1826, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__92)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "fst.pyx":1865
 * 
 * 
 * def synchronize(_Fst ifst):             # <<<<<<<<<<<<<<
 *   """Constructively synchronizes an FST.
 * 
 */
  __pyx_tuple__93 = PyTuple_Pack(2, __pyx_n_s_ifst, __pyx_n_s_tfst); if (unlikely(!__pyx_tuple__93)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__93);
  __Pyx_GIVEREF(__pyx_tuple__93);
  __pyx_codeobj__94 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__93, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_usr_local_google_home_kbg_tmp_O, __pyx_n_s_synchronize, 1865, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__94)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initfst(void); /*proto*/
PyMODINIT_FUNC initfst(void)
#else
PyMODINIT_FUNC PyInit_fst(void); /*proto*/
PyMODINIT_FUNC PyInit_fst(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  std::string __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_fst(void)", 0);
  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #ifdef __Pyx_CyFunction_USED
  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("fst", __pyx_methods, __pyx_k_Python_interface_to_nlp_fst_scri, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  /*--- Initialize various global constants etc. ---*/
  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  if (__pyx_module_is_main_fst) {
    if (PyObject_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (!PyDict_GetItemString(modules, "fst")) {
      if (unlikely(PyDict_SetItemString(modules, "fst", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Constants init code ---*/
  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Global init code ---*/
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  if (__Pyx_ExportFunction("tobytes", (void (*)(void))__pyx_f_3fst_tobytes, "PyObject *(PyObject *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("_get_weight_class", (void (*)(void))__pyx_f_3fst__get_weight_class, "fst::script::WeightClass (PyObject *, PyObject *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("_init_Fst", (void (*)(void))__pyx_f_3fst__init_Fst, "PyObject *(fst::script::FstClass *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("_init_MutableFst", (void (*)(void))__pyx_f_3fst__init_MutableFst, "PyObject *(fst::script::MutableFstClass *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("_init_XFst", (void (*)(void))__pyx_f_3fst__init_XFst, "PyObject *(fst::script::FstClass *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("__pyx_convert_string_from_py_", (void (*)(void))__pyx_convert_string_from_py_, "std::string (PyObject *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("__pyx_convert_string_to_py_", (void (*)(void))__pyx_convert_string_to_py_, "PyObject *(std::string const &)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Type init code ---*/
  if (PyType_Ready(&__pyx_type_3fst_Weight) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_3fst_Weight.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "Weight", (PyObject *)&__pyx_type_3fst_Weight) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_3fst_Weight = &__pyx_type_3fst_Weight;
  if (PyType_Ready(&__pyx_type_3fst__Fst) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 715; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_3fst__Fst.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "_Fst", (PyObject *)&__pyx_type_3fst__Fst) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 715; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_3fst__Fst = &__pyx_type_3fst__Fst;
  __pyx_type_3fst__MutableFst.tp_base = __pyx_ptype_3fst__Fst;
  if (PyType_Ready(&__pyx_type_3fst__MutableFst) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_3fst__MutableFst.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "_MutableFst", (PyObject *)&__pyx_type_3fst__MutableFst) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_3fst__MutableFst = &__pyx_type_3fst__MutableFst;
  /*--- Type import code ---*/
  /*--- Variable import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/

  /* "fst.pyx":442
 * # Declares constants (casing is as per style guide).
 * 
 * EXPANDED = kExpanded             # <<<<<<<<<<<<<<
 * MUTABLE = kMutable
 * ERROR = kError
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kExpanded); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 442; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_EXPANDED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 442; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":443
 * 
 * EXPANDED = kExpanded
 * MUTABLE = kMutable             # <<<<<<<<<<<<<<
 * ERROR = kError
 * ACCEPTOR = kAcceptor
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kMutable); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 443; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_MUTABLE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 443; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":444
 * EXPANDED = kExpanded
 * MUTABLE = kMutable
 * ERROR = kError             # <<<<<<<<<<<<<<
 * ACCEPTOR = kAcceptor
 * NOT_ACCEPTOR = kNotAcceptor
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 444; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ERROR, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 444; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":445
 * MUTABLE = kMutable
 * ERROR = kError
 * ACCEPTOR = kAcceptor             # <<<<<<<<<<<<<<
 * NOT_ACCEPTOR = kNotAcceptor
 * I_DETERMINISTIC = kIDeterministic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kAcceptor); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ACCEPTOR, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":446
 * ERROR = kError
 * ACCEPTOR = kAcceptor
 * NOT_ACCEPTOR = kNotAcceptor             # <<<<<<<<<<<<<<
 * I_DETERMINISTIC = kIDeterministic
 * NON_I_DETERMINISTIC = kNonIDeterministic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotAcceptor); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 446; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_ACCEPTOR, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 446; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":447
 * ACCEPTOR = kAcceptor
 * NOT_ACCEPTOR = kNotAcceptor
 * I_DETERMINISTIC = kIDeterministic             # <<<<<<<<<<<<<<
 * NON_I_DETERMINISTIC = kNonIDeterministic
 * O_DETERMINISTIC = kODeterministic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kIDeterministic); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 447; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_I_DETERMINISTIC, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 447; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":448
 * NOT_ACCEPTOR = kNotAcceptor
 * I_DETERMINISTIC = kIDeterministic
 * NON_I_DETERMINISTIC = kNonIDeterministic             # <<<<<<<<<<<<<<
 * O_DETERMINISTIC = kODeterministic
 * NON_O_DETERMINISTIC = kNonODeterministic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNonIDeterministic); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NON_I_DETERMINISTIC, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":449
 * I_DETERMINISTIC = kIDeterministic
 * NON_I_DETERMINISTIC = kNonIDeterministic
 * O_DETERMINISTIC = kODeterministic             # <<<<<<<<<<<<<<
 * NON_O_DETERMINISTIC = kNonODeterministic
 * EPSILONS = kEpsilons
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kODeterministic); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_O_DETERMINISTIC, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":450
 * NON_I_DETERMINISTIC = kNonIDeterministic
 * O_DETERMINISTIC = kODeterministic
 * NON_O_DETERMINISTIC = kNonODeterministic             # <<<<<<<<<<<<<<
 * EPSILONS = kEpsilons
 * NO_EPSILONS = kNoEpsilons
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNonODeterministic); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 450; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NON_O_DETERMINISTIC, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 450; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":451
 * O_DETERMINISTIC = kODeterministic
 * NON_O_DETERMINISTIC = kNonODeterministic
 * EPSILONS = kEpsilons             # <<<<<<<<<<<<<<
 * NO_EPSILONS = kNoEpsilons
 * I_EPSILONS = kIEpsilons
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kEpsilons); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_EPSILONS, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":452
 * NON_O_DETERMINISTIC = kNonODeterministic
 * EPSILONS = kEpsilons
 * NO_EPSILONS = kNoEpsilons             # <<<<<<<<<<<<<<
 * I_EPSILONS = kIEpsilons
 * NO_I_EPSILONS = kNoIEpsilons
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNoEpsilons); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NO_EPSILONS, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":453
 * EPSILONS = kEpsilons
 * NO_EPSILONS = kNoEpsilons
 * I_EPSILONS = kIEpsilons             # <<<<<<<<<<<<<<
 * NO_I_EPSILONS = kNoIEpsilons
 * O_EPSILONS = kOEpsilons
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kIEpsilons); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_I_EPSILONS, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":454
 * NO_EPSILONS = kNoEpsilons
 * I_EPSILONS = kIEpsilons
 * NO_I_EPSILONS = kNoIEpsilons             # <<<<<<<<<<<<<<
 * O_EPSILONS = kOEpsilons
 * NO_O_EPSILSONS = kNoOEpsilons
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNoIEpsilons); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NO_I_EPSILONS, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":455
 * I_EPSILONS = kIEpsilons
 * NO_I_EPSILONS = kNoIEpsilons
 * O_EPSILONS = kOEpsilons             # <<<<<<<<<<<<<<
 * NO_O_EPSILSONS = kNoOEpsilons
 * I_LABEL_SORTED = kILabelSorted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kOEpsilons); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 455; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_O_EPSILONS, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 455; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":456
 * NO_I_EPSILONS = kNoIEpsilons
 * O_EPSILONS = kOEpsilons
 * NO_O_EPSILSONS = kNoOEpsilons             # <<<<<<<<<<<<<<
 * I_LABEL_SORTED = kILabelSorted
 * NOT_I_LABEL_SORTED = kNotILabelSorted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNoOEpsilons); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NO_O_EPSILSONS, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":457
 * O_EPSILONS = kOEpsilons
 * NO_O_EPSILSONS = kNoOEpsilons
 * I_LABEL_SORTED = kILabelSorted             # <<<<<<<<<<<<<<
 * NOT_I_LABEL_SORTED = kNotILabelSorted
 * O_LABEL_SORTED = kOLabelSorted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kILabelSorted); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_I_LABEL_SORTED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":458
 * NO_O_EPSILSONS = kNoOEpsilons
 * I_LABEL_SORTED = kILabelSorted
 * NOT_I_LABEL_SORTED = kNotILabelSorted             # <<<<<<<<<<<<<<
 * O_LABEL_SORTED = kOLabelSorted
 * NOT_O_LABEL_SORTED = kNotOLabelSorted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotILabelSorted); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 458; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_I_LABEL_SORTED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 458; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":459
 * I_LABEL_SORTED = kILabelSorted
 * NOT_I_LABEL_SORTED = kNotILabelSorted
 * O_LABEL_SORTED = kOLabelSorted             # <<<<<<<<<<<<<<
 * NOT_O_LABEL_SORTED = kNotOLabelSorted
 * WEIGHTED = kWeighted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kOLabelSorted); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_O_LABEL_SORTED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":460
 * NOT_I_LABEL_SORTED = kNotILabelSorted
 * O_LABEL_SORTED = kOLabelSorted
 * NOT_O_LABEL_SORTED = kNotOLabelSorted             # <<<<<<<<<<<<<<
 * WEIGHTED = kWeighted
 * UNWEIGHTED = kUnweighted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotOLabelSorted); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 460; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_O_LABEL_SORTED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 460; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":461
 * O_LABEL_SORTED = kOLabelSorted
 * NOT_O_LABEL_SORTED = kNotOLabelSorted
 * WEIGHTED = kWeighted             # <<<<<<<<<<<<<<
 * UNWEIGHTED = kUnweighted
 * CYCLIC = kCyclic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kWeighted); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_WEIGHTED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":462
 * NOT_O_LABEL_SORTED = kNotOLabelSorted
 * WEIGHTED = kWeighted
 * UNWEIGHTED = kUnweighted             # <<<<<<<<<<<<<<
 * CYCLIC = kCyclic
 * ACYCLIC = kAcyclic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kUnweighted); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_UNWEIGHTED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":463
 * WEIGHTED = kWeighted
 * UNWEIGHTED = kUnweighted
 * CYCLIC = kCyclic             # <<<<<<<<<<<<<<
 * ACYCLIC = kAcyclic
 * INITIAL_CYCLIC = kInitialCyclic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kCyclic); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 463; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CYCLIC, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 463; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":464
 * UNWEIGHTED = kUnweighted
 * CYCLIC = kCyclic
 * ACYCLIC = kAcyclic             # <<<<<<<<<<<<<<
 * INITIAL_CYCLIC = kInitialCyclic
 * INITIAL_ACYCLIC = kInitialAcyclic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kAcyclic); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 464; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ACYCLIC, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 464; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":465
 * CYCLIC = kCyclic
 * ACYCLIC = kAcyclic
 * INITIAL_CYCLIC = kInitialCyclic             # <<<<<<<<<<<<<<
 * INITIAL_ACYCLIC = kInitialAcyclic
 * TOP_SORTED = kTopSorted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kInitialCyclic); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 465; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_INITIAL_CYCLIC, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 465; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":466
 * ACYCLIC = kAcyclic
 * INITIAL_CYCLIC = kInitialCyclic
 * INITIAL_ACYCLIC = kInitialAcyclic             # <<<<<<<<<<<<<<
 * TOP_SORTED = kTopSorted
 * NOT_TOP_SORTED = kNotTopSorted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kInitialAcyclic); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_INITIAL_ACYCLIC, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":467
 * INITIAL_CYCLIC = kInitialCyclic
 * INITIAL_ACYCLIC = kInitialAcyclic
 * TOP_SORTED = kTopSorted             # <<<<<<<<<<<<<<
 * NOT_TOP_SORTED = kNotTopSorted
 * ACCESSIBLE = kAccessible
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kTopSorted); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_TOP_SORTED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":468
 * INITIAL_ACYCLIC = kInitialAcyclic
 * TOP_SORTED = kTopSorted
 * NOT_TOP_SORTED = kNotTopSorted             # <<<<<<<<<<<<<<
 * ACCESSIBLE = kAccessible
 * NOT_ACCESSIBLE = kNotAccessible
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotTopSorted); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 468; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_TOP_SORTED, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 468; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":469
 * TOP_SORTED = kTopSorted
 * NOT_TOP_SORTED = kNotTopSorted
 * ACCESSIBLE = kAccessible             # <<<<<<<<<<<<<<
 * NOT_ACCESSIBLE = kNotAccessible
 * COACCESSIBLE = kCoAccessible
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kAccessible); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ACCESSIBLE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":470
 * NOT_TOP_SORTED = kNotTopSorted
 * ACCESSIBLE = kAccessible
 * NOT_ACCESSIBLE = kNotAccessible             # <<<<<<<<<<<<<<
 * COACCESSIBLE = kCoAccessible
 * NOT_COACCESSIBLE = kNotCoAccessible
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotAccessible); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 470; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_ACCESSIBLE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 470; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":471
 * ACCESSIBLE = kAccessible
 * NOT_ACCESSIBLE = kNotAccessible
 * COACCESSIBLE = kCoAccessible             # <<<<<<<<<<<<<<
 * NOT_COACCESSIBLE = kNotCoAccessible
 * STRING = kString
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kCoAccessible); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_COACCESSIBLE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":472
 * NOT_ACCESSIBLE = kNotAccessible
 * COACCESSIBLE = kCoAccessible
 * NOT_COACCESSIBLE = kNotCoAccessible             # <<<<<<<<<<<<<<
 * STRING = kString
 * NOT_STRING = kNotString
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotCoAccessible); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_COACCESSIBLE, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":473
 * COACCESSIBLE = kCoAccessible
 * NOT_COACCESSIBLE = kNotCoAccessible
 * STRING = kString             # <<<<<<<<<<<<<<
 * NOT_STRING = kNotString
 * NULL_PROPERTIES = kNullProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kString); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 473; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_STRING, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 473; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":474
 * NOT_COACCESSIBLE = kNotCoAccessible
 * STRING = kString
 * NOT_STRING = kNotString             # <<<<<<<<<<<<<<
 * NULL_PROPERTIES = kNullProperties
 * COPY_PROPERTIES = kCopyProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotString); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 474; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_STRING, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 474; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":475
 * STRING = kString
 * NOT_STRING = kNotString
 * NULL_PROPERTIES = kNullProperties             # <<<<<<<<<<<<<<
 * COPY_PROPERTIES = kCopyProperties
 * INTRINSIC_PROPERTIES = kIntrinsicProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNullProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NULL_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":476
 * NOT_STRING = kNotString
 * NULL_PROPERTIES = kNullProperties
 * COPY_PROPERTIES = kCopyProperties             # <<<<<<<<<<<<<<
 * INTRINSIC_PROPERTIES = kIntrinsicProperties
 * EXTRINSIC_PROPERTIES = kExtrinsicProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kCopyProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 476; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_COPY_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 476; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":477
 * NULL_PROPERTIES = kNullProperties
 * COPY_PROPERTIES = kCopyProperties
 * INTRINSIC_PROPERTIES = kIntrinsicProperties             # <<<<<<<<<<<<<<
 * EXTRINSIC_PROPERTIES = kExtrinsicProperties
 * SET_START_PROPERTIES = kSetStartProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kIntrinsicProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 477; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_INTRINSIC_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 477; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":478
 * COPY_PROPERTIES = kCopyProperties
 * INTRINSIC_PROPERTIES = kIntrinsicProperties
 * EXTRINSIC_PROPERTIES = kExtrinsicProperties             # <<<<<<<<<<<<<<
 * SET_START_PROPERTIES = kSetStartProperties
 * SET_FINAL_PROPERTIES = kSetFinalProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kExtrinsicProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_EXTRINSIC_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":479
 * INTRINSIC_PROPERTIES = kIntrinsicProperties
 * EXTRINSIC_PROPERTIES = kExtrinsicProperties
 * SET_START_PROPERTIES = kSetStartProperties             # <<<<<<<<<<<<<<
 * SET_FINAL_PROPERTIES = kSetFinalProperties
 * ADD_STATE_PROPERTIES = kAddStateProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kSetStartProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 479; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SET_START_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 479; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":480
 * EXTRINSIC_PROPERTIES = kExtrinsicProperties
 * SET_START_PROPERTIES = kSetStartProperties
 * SET_FINAL_PROPERTIES = kSetFinalProperties             # <<<<<<<<<<<<<<
 * ADD_STATE_PROPERTIES = kAddStateProperties
 * ADD_ARC_PROPERTIES = kAddArcProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kSetFinalProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SET_FINAL_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":481
 * SET_START_PROPERTIES = kSetStartProperties
 * SET_FINAL_PROPERTIES = kSetFinalProperties
 * ADD_STATE_PROPERTIES = kAddStateProperties             # <<<<<<<<<<<<<<
 * ADD_ARC_PROPERTIES = kAddArcProperties
 * SET_ARC_PROPERTIES = kSetArcProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kAddStateProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 481; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ADD_STATE_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 481; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":482
 * SET_FINAL_PROPERTIES = kSetFinalProperties
 * ADD_STATE_PROPERTIES = kAddStateProperties
 * ADD_ARC_PROPERTIES = kAddArcProperties             # <<<<<<<<<<<<<<
 * SET_ARC_PROPERTIES = kSetArcProperties
 * DELETE_STATE_PROPERTIES = kDeleteStatesProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kAddArcProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 482; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ADD_ARC_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 482; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":483
 * ADD_STATE_PROPERTIES = kAddStateProperties
 * ADD_ARC_PROPERTIES = kAddArcProperties
 * SET_ARC_PROPERTIES = kSetArcProperties             # <<<<<<<<<<<<<<
 * DELETE_STATE_PROPERTIES = kDeleteStatesProperties
 * DELETE_ARC_PROPERTIES = kDeleteArcsProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kSetArcProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SET_ARC_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":484
 * ADD_ARC_PROPERTIES = kAddArcProperties
 * SET_ARC_PROPERTIES = kSetArcProperties
 * DELETE_STATE_PROPERTIES = kDeleteStatesProperties             # <<<<<<<<<<<<<<
 * DELETE_ARC_PROPERTIES = kDeleteArcsProperties
 * STATE_SORT_PROPERTIES = kStateSortProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kDeleteStatesProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DELETE_STATE_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":485
 * SET_ARC_PROPERTIES = kSetArcProperties
 * DELETE_STATE_PROPERTIES = kDeleteStatesProperties
 * DELETE_ARC_PROPERTIES = kDeleteArcsProperties             # <<<<<<<<<<<<<<
 * STATE_SORT_PROPERTIES = kStateSortProperties
 * ARC_SORT_PROPERTIES = kArcSortProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kDeleteArcsProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DELETE_ARC_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":486
 * DELETE_STATE_PROPERTIES = kDeleteStatesProperties
 * DELETE_ARC_PROPERTIES = kDeleteArcsProperties
 * STATE_SORT_PROPERTIES = kStateSortProperties             # <<<<<<<<<<<<<<
 * ARC_SORT_PROPERTIES = kArcSortProperties
 * I_LABEL_INVARIANT_PROPERTIES = kILabelInvariantProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kStateSortProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 486; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_STATE_SORT_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 486; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":487
 * DELETE_ARC_PROPERTIES = kDeleteArcsProperties
 * STATE_SORT_PROPERTIES = kStateSortProperties
 * ARC_SORT_PROPERTIES = kArcSortProperties             # <<<<<<<<<<<<<<
 * I_LABEL_INVARIANT_PROPERTIES = kILabelInvariantProperties
 * O_LABEL_INVARIANT_PROPERTIES = kOLabelInvariantProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kArcSortProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ARC_SORT_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":488
 * STATE_SORT_PROPERTIES = kStateSortProperties
 * ARC_SORT_PROPERTIES = kArcSortProperties
 * I_LABEL_INVARIANT_PROPERTIES = kILabelInvariantProperties             # <<<<<<<<<<<<<<
 * O_LABEL_INVARIANT_PROPERTIES = kOLabelInvariantProperties
 * WEIGHT_INVARIANT_PROPERTIES = kWeightInvariantProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kILabelInvariantProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_I_LABEL_INVARIANT_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":489
 * ARC_SORT_PROPERTIES = kArcSortProperties
 * I_LABEL_INVARIANT_PROPERTIES = kILabelInvariantProperties
 * O_LABEL_INVARIANT_PROPERTIES = kOLabelInvariantProperties             # <<<<<<<<<<<<<<
 * WEIGHT_INVARIANT_PROPERTIES = kWeightInvariantProperties
 * ADD_SUPERFINAL_PROPERTIES = kAddSuperFinalProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kOLabelInvariantProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 489; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_O_LABEL_INVARIANT_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 489; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":490
 * I_LABEL_INVARIANT_PROPERTIES = kILabelInvariantProperties
 * O_LABEL_INVARIANT_PROPERTIES = kOLabelInvariantProperties
 * WEIGHT_INVARIANT_PROPERTIES = kWeightInvariantProperties             # <<<<<<<<<<<<<<
 * ADD_SUPERFINAL_PROPERTIES = kAddSuperFinalProperties
 * RM_SUPERFINAL_PROPERTIES = kRmSuperFinalProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kWeightInvariantProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 490; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_WEIGHT_INVARIANT_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 490; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":491
 * O_LABEL_INVARIANT_PROPERTIES = kOLabelInvariantProperties
 * WEIGHT_INVARIANT_PROPERTIES = kWeightInvariantProperties
 * ADD_SUPERFINAL_PROPERTIES = kAddSuperFinalProperties             # <<<<<<<<<<<<<<
 * RM_SUPERFINAL_PROPERTIES = kRmSuperFinalProperties
 * BINARY_PROPERTIES = kBinaryProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kAddSuperFinalProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 491; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ADD_SUPERFINAL_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 491; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":492
 * WEIGHT_INVARIANT_PROPERTIES = kWeightInvariantProperties
 * ADD_SUPERFINAL_PROPERTIES = kAddSuperFinalProperties
 * RM_SUPERFINAL_PROPERTIES = kRmSuperFinalProperties             # <<<<<<<<<<<<<<
 * BINARY_PROPERTIES = kBinaryProperties
 * TRINARY_PROPERTIES = kTrinaryProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kRmSuperFinalProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_RM_SUPERFINAL_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":493
 * ADD_SUPERFINAL_PROPERTIES = kAddSuperFinalProperties
 * RM_SUPERFINAL_PROPERTIES = kRmSuperFinalProperties
 * BINARY_PROPERTIES = kBinaryProperties             # <<<<<<<<<<<<<<
 * TRINARY_PROPERTIES = kTrinaryProperties
 * POS_TRINARY_PROPERTIES = kPosTrinaryProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kBinaryProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_BINARY_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":494
 * RM_SUPERFINAL_PROPERTIES = kRmSuperFinalProperties
 * BINARY_PROPERTIES = kBinaryProperties
 * TRINARY_PROPERTIES = kTrinaryProperties             # <<<<<<<<<<<<<<
 * POS_TRINARY_PROPERTIES = kPosTrinaryProperties
 * NEG_TRINARY_PROPERTIES = kNegTrinaryProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kTrinaryProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 494; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_TRINARY_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 494; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":495
 * BINARY_PROPERTIES = kBinaryProperties
 * TRINARY_PROPERTIES = kTrinaryProperties
 * POS_TRINARY_PROPERTIES = kPosTrinaryProperties             # <<<<<<<<<<<<<<
 * NEG_TRINARY_PROPERTIES = kNegTrinaryProperties
 * FST_PROPERTIES = kFstProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kPosTrinaryProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 495; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_POS_TRINARY_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 495; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":496
 * TRINARY_PROPERTIES = kTrinaryProperties
 * POS_TRINARY_PROPERTIES = kPosTrinaryProperties
 * NEG_TRINARY_PROPERTIES = kNegTrinaryProperties             # <<<<<<<<<<<<<<
 * FST_PROPERTIES = kFstProperties
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNegTrinaryProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 496; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NEG_TRINARY_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 496; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":497
 * POS_TRINARY_PROPERTIES = kPosTrinaryProperties
 * NEG_TRINARY_PROPERTIES = kNegTrinaryProperties
 * FST_PROPERTIES = kFstProperties             # <<<<<<<<<<<<<<
 * 
 * # Exception and warnings classes for FST issues.
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kFstProperties); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FST_PROPERTIES, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":502
 * 
 * 
 * class FstWarning(UserWarning):             # <<<<<<<<<<<<<<
 * 
 *   """Warning for FST operations."""
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_builtin_UserWarning);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_builtin_UserWarning);
  __Pyx_GIVEREF(__pyx_builtin_UserWarning);
  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_FstWarning, __pyx_n_s_FstWarning, (PyObject *) NULL, __pyx_n_s_fst, __pyx_kp_s_Warning_for_FST_operations); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_FstWarning, __pyx_t_1, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FstWarning, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":509
 * 
 * 
 * class FstError(ValueError):             # <<<<<<<<<<<<<<
 * 
 *   """Exception thrown when FST operations fails."""
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_builtin_ValueError);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_builtin_ValueError);
  __Pyx_GIVEREF(__pyx_builtin_ValueError);
  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_FstError, __pyx_n_s_FstError, (PyObject *) NULL, __pyx_n_s_fst, __pyx_kp_s_Exception_thrown_when_FST_operat); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_FstError, __pyx_t_1, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FstError, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":550
 * 
 * 
 * def _get_compose_filter(string cf):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate ComposeFilter enum value.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_1_get_compose_filter, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 550; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_compose_filter, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 550; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":579
 * 
 * 
 * def _get_queue_type(string qt):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate QueueType enum value.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_3_get_queue_type, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_queue_type, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":609
 * 
 * 
 * def _get_rand_arc_selection(string ras):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate RandArcSelection enum value.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_5_get_rand_arc_selection, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_rand_arc_selection, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":633
 * 
 * 
 * def _get_replace_label_type(string rlt, bool epsilon_on_replace):             # <<<<<<<<<<<<<<
 *   """Matches string with the appropriate ReplaceLabelType enum value.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_7_get_replace_label_type, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_replace_label_type, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":707
 * 
 *   @property
 *   def type(self):             # <<<<<<<<<<<<<<
 *     return self.weight.Type()
 * 
 */
  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_3fst_Weight, __pyx_n_s_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 707; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);

  /* "fst.pyx":706
 *       raise NotImplementedError("Invalid operator {!r}".format(op))
 * 
 *   @property             # <<<<<<<<<<<<<<
 *   def type(self):
 *     return self.weight.Type()
 */
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 706; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 706; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_3fst_Weight->tp_dict, __pyx_n_s_type, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 707; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_3fst_Weight);

  /* "fst.pyx":711
 * 
 *   @property
 *   def string(self):             # <<<<<<<<<<<<<<
 *     return self.weight.to_string()
 * 
 */
  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_3fst_Weight, __pyx_n_s_string); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 711; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);

  /* "fst.pyx":710
 *     return self.weight.Type()
 * 
 *   @property             # <<<<<<<<<<<<<<
 *   def string(self):
 *     return self.weight.to_string()
 */
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 710; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 710; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_3fst_Weight->tp_dict, __pyx_n_s_string, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 711; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_3fst_Weight);

  /* "fst.pyx":756
 * 
 *   @property
 *   def _arc_type(self):             # <<<<<<<<<<<<<<
 *     """Returns the arc type of the internal FST.
 * 
 */
  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_3fst__Fst, __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 756; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);

  /* "fst.pyx":755
 *     return self.fst.Properties(mask, test)
 * 
 *   @property             # <<<<<<<<<<<<<<
 *   def _arc_type(self):
 *     """Returns the arc type of the internal FST.
 */
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 755; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 755; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_3fst__Fst->tp_dict, __pyx_n_s_arc_type, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 756; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_3fst__Fst);

  /* "fst.pyx":765
 * 
 *   @property
 *   def _fst_type(self):             # <<<<<<<<<<<<<<
 *     """Returns the type (i.e., data structure) of the internal FST.
 * 
 */
  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_3fst__Fst, __pyx_n_s_fst_type); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);

  /* "fst.pyx":764
 *     return self.fst.ArcType()
 * 
 *   @property             # <<<<<<<<<<<<<<
 *   def _fst_type(self):
 *     """Returns the type (i.e., data structure) of the internal FST.
 */
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 764; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 764; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_3fst__Fst->tp_dict, __pyx_n_s_fst_type, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_3fst__Fst);

  /* "fst.pyx":774
 * 
 *   @property
 *   def _weight_type(self):             # <<<<<<<<<<<<<<
 *     """Returns the weight type of the internal FST.
 * 
 */
  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_3fst__Fst, __pyx_n_s_weight_type_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 774; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);

  /* "fst.pyx":773
 *     return self.fst.FstType()
 * 
 *   @property             # <<<<<<<<<<<<<<
 *   def _weight_type(self):
 *     """Returns the weight type of the internal FST.
 */
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 773; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 773; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_3fst__Fst->tp_dict, __pyx_n_s_weight_type_2, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 774; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_3fst__Fst);

  /* "fst.pyx":921
 *     self._check_mutating_imethod()
 * 
 *   def minimize(self, float delta=kDelta):             # <<<<<<<<<<<<<<
 *     """Minimizes the FST.
 * 
 */
  __pyx_k__4 = fst::kDelta;

  /* "fst.pyx":959
 *     self._check_mutating_imethod()
 * 
 *   def prune(self, float delta=kDelta, int64 nstate=kNoStateId, weight=b""):             # <<<<<<<<<<<<<<
 *     """Removes paths with weights below a certain threshold.
 * 
 */
  __pyx_k__6 = fst::kDelta;
  __pyx_k__7 = fst::kNoStateId;

  /* "fst.pyx":979
 *     self._check_mutating_imethod()
 * 
 *   def push(self, float delta=kDelta, remove_total_weight=False,             # <<<<<<<<<<<<<<
 *            to_final=False):
 *     """Pushes weights towards the initial or final states.
 */
  __pyx_k__8 = fst::kDelta;

  /* "fst.pyx":1059
 *     self._check_mutating_imethod()
 * 
 *   def rmepsilon(self, bool connect=True, float delta=kDelta,             # <<<<<<<<<<<<<<
 *                 int64 nstate=kNoStateId, weight=b""):
 *     """Removes epsilon transitions.
 */
  __pyx_k__10 = fst::kDelta;

  /* "fst.pyx":1060
 * 
 *   def rmepsilon(self, bool connect=True, float delta=kDelta,
 *                 int64 nstate=kNoStateId, weight=b""):             # <<<<<<<<<<<<<<
 *     """Removes epsilon transitions.
 * 
 */
  __pyx_k__11 = fst::kNoStateId;

  /* "fst.pyx":1141
 * 
 * 
 * def Fst(filename, fst_type=b""):             # <<<<<<<<<<<<<<
 *   """Constructs an FST from a file.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_9Fst, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Fst, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1169
 * 
 * 
 * def arcmap(_Fst ifst, float delta=kDelta, map_type=b"identity", weight=b""):             # <<<<<<<<<<<<<<
 *   """Constructively applies a transform to all arcs and final states.
 * 
 */
  __pyx_k__16 = fst::kDelta;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_11arcmap, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_arcmap, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1229
 * 
 * 
 * def compose(_Fst ifst1, _Fst ifst2, cf=b"auto", bool connect=True):             # <<<<<<<<<<<<<<
 *   """Constructively composes two FSTs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_13compose, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_compose, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1262
 * 
 * 
 * def convert(_Fst ifst, fst_type=b""):             # <<<<<<<<<<<<<<
 *   """Constructively converts an FST to a new internal representation.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_15convert, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_convert, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1280
 * 
 * 
 * def determinize(_Fst ifst, float delta=kDelta, det_type=b"functional",             # <<<<<<<<<<<<<<
 *                 int64 nstate=kNoStateId, int64 subsequential_label=0,
 *                 weight=b"", bool increment_subsequential_label=False):
 */
  __pyx_k__18 = fst::kDelta;

  /* "fst.pyx":1281
 * 
 * def determinize(_Fst ifst, float delta=kDelta, det_type=b"functional",
 *                 int64 nstate=kNoStateId, int64 subsequential_label=0,             # <<<<<<<<<<<<<<
 *                 weight=b"", bool increment_subsequential_label=False):
 *   """Constructively determinizes a weighted FST.
 */
  __pyx_k__19 = fst::kNoStateId;

  /* "fst.pyx":1280
 * 
 * 
 * def determinize(_Fst ifst, float delta=kDelta, det_type=b"functional",             # <<<<<<<<<<<<<<
 *                 int64 nstate=kNoStateId, int64 subsequential_label=0,
 *                 weight=b"", bool increment_subsequential_label=False):
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_17determinize, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_determinize, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1328
 * 
 * 
 * def difference(_Fst ifst1, _Fst ifst2, cf=b"auto", bool connect=True):             # <<<<<<<<<<<<<<
 *   """Constructively computes the difference of two FSTs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_19difference, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_difference, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1355
 * 
 * 
 * def disambiguate(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId,             # <<<<<<<<<<<<<<
 *                  int64 subsequential_label=0, string weight=b""):
 *   """Constructively disambiguates a weighted transducer.
 */
  __pyx_k__20 = fst::kDelta;
  __pyx_k__21 = fst::kNoStateId;

  /* "fst.pyx":1356
 * 
 * def disambiguate(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId,
 *                  int64 subsequential_label=0, string weight=b""):             # <<<<<<<<<<<<<<
 *   """Constructively disambiguates a weighted transducer.
 * 
 */
  __pyx_t_5 = __pyx_convert_string_from_py_(__pyx_kp_b__5); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1356; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_k__22 = __pyx_t_5;

  /* "fst.pyx":1355
 * 
 * 
 * def disambiguate(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId,             # <<<<<<<<<<<<<<
 *                  int64 subsequential_label=0, string weight=b""):
 *   """Constructively disambiguates a weighted transducer.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_21disambiguate, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_disambiguate, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1387
 * 
 * 
 * def epsnormalize(_Fst ifst, bool eps_norm_output=False):             # <<<<<<<<<<<<<<
 *   """Constructively epsilon-normalizes an FST.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_23epsnormalize, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_epsnormalize, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1412
 * 
 * 
 * def equal(_Fst ifst1, _Fst ifst2, float delta=kDelta):             # <<<<<<<<<<<<<<
 *   """Are two FSTs equal?
 * 
 */
  __pyx_k__23 = fst::kDelta;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_25equal, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_equal, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1432
 * 
 * 
 * def equivalent(_Fst ifst1, _Fst ifst2, float delta=kDelta):             # <<<<<<<<<<<<<<
 *   """Are the two acceptors equivalent?
 * 
 */
  __pyx_k__24 = fst::kDelta;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_27equivalent, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_equivalent, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1459
 * 
 * 
 * def intersect(_Fst ifst1, _Fst ifst2, cf=b"auto", bool connect=True):             # <<<<<<<<<<<<<<
 *   """Constructively intersects two FSTs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_29intersect, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_intersect, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1484
 * 
 * 
 * def isomorphic(_Fst ifst1, _Fst ifst2, float delta=kDelta):             # <<<<<<<<<<<<<<
 *   """Are the two acceptors isomorphic?
 * 
 */
  __pyx_k__26 = fst::kDelta;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_31isomorphic, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_isomorphic, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1514
 * 
 * 
 * def prune(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId, weight=b""):             # <<<<<<<<<<<<<<
 *   """Constructively removes paths with weights below a certain threshold.
 * 
 */
  __pyx_k__28 = fst::kDelta;
  __pyx_k__29 = fst::kNoStateId;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_33prune, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_prune, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1540
 * 
 * 
 * def push(_Fst ifst, float delta=kDelta, bool push_weights=False,             # <<<<<<<<<<<<<<
 *          bool push_labels=False, bool remove_common_affix=False,
 *          bool remove_total_weight=False, bool to_final=False):
 */
  __pyx_k__30 = fst::kDelta;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_35push, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_push, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1593
 * 
 * 
 * def randequivalent(_Fst ifst1, _Fst ifst2, float delta=kDelta,             # <<<<<<<<<<<<<<
 *                    int32 max_length=INT_MAX, int32 npath=1,
 *                    int32 seed=time(NULL), select=b"uniform"):
 */
  __pyx_k__31 = fst::kDelta;

  /* "fst.pyx":1594
 * 
 * def randequivalent(_Fst ifst1, _Fst ifst2, float delta=kDelta,
 *                    int32 max_length=INT_MAX, int32 npath=1,             # <<<<<<<<<<<<<<
 *                    int32 seed=time(NULL), select=b"uniform"):
 *   """Are two acceptors stochastically equivalent?
 */
  __pyx_k__32 = INT_MAX;

  /* "fst.pyx":1595
 * def randequivalent(_Fst ifst1, _Fst ifst2, float delta=kDelta,
 *                    int32 max_length=INT_MAX, int32 npath=1,
 *                    int32 seed=time(NULL), select=b"uniform"):             # <<<<<<<<<<<<<<
 *   """Are two acceptors stochastically equivalent?
 * 
 */
  __pyx_k__33 = time(NULL);

  /* "fst.pyx":1593
 * 
 * 
 * def randequivalent(_Fst ifst1, _Fst ifst2, float delta=kDelta,             # <<<<<<<<<<<<<<
 *                    int32 max_length=INT_MAX, int32 npath=1,
 *                    int32 seed=time(NULL), select=b"uniform"):
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_37randequivalent, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1593; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_randequivalent, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1593; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1632
 * 
 * 
 * def randgen(_Fst ifst, int32 max_length=INT_MAX, int32 npath=1,             # <<<<<<<<<<<<<<
 *             bool remove_total_weight=False, int32 seed=time(NULL),
 *             select=b"uniform", bool weighted=False):
 */
  __pyx_k__35 = INT_MAX;

  /* "fst.pyx":1633
 * 
 * def randgen(_Fst ifst, int32 max_length=INT_MAX, int32 npath=1,
 *             bool remove_total_weight=False, int32 seed=time(NULL),             # <<<<<<<<<<<<<<
 *             select=b"uniform", bool weighted=False):
 *   """Randomly generate successful paths in an FST.
 */
  __pyx_k__36 = time(NULL);

  /* "fst.pyx":1632
 * 
 * 
 * def randgen(_Fst ifst, int32 max_length=INT_MAX, int32 npath=1,             # <<<<<<<<<<<<<<
 *             bool remove_total_weight=False, int32 seed=time(NULL),
 *             select=b"uniform", bool weighted=False):
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_39randgen, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_randgen, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1669
 * 
 * 
 * def replace(pairs, call_arc_labeling=b"input", return_arc_labeling=b"neither",             # <<<<<<<<<<<<<<
 *             bool epsilon_on_replace=False, int64 return_label=0):
 *   """Recursively replaces arcs in the FST with other FST(s).
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_41replace, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_replace, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1724
 * 
 * 
 * def reverse(_Fst ifst, bool require_superinitial=True):             # <<<<<<<<<<<<<<
 *   """Constructively reverses an FST's transduction.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_43reverse, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1724; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_reverse, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1724; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1745
 * 
 * 
 * def rmepsilon(_Fst ifst, bool connect=True, float delta=kDelta,             # <<<<<<<<<<<<<<
 *               int64 nstate=kNoStateId, queue_type=b"auto", bool reverse=False,
 *               weight=b""):
 */
  __pyx_k__37 = fst::kDelta;

  /* "fst.pyx":1746
 * 
 * def rmepsilon(_Fst ifst, bool connect=True, float delta=kDelta,
 *               int64 nstate=kNoStateId, queue_type=b"auto", bool reverse=False,             # <<<<<<<<<<<<<<
 *               weight=b""):
 *   """Constructively removes epsilon transitions from an FST.
 */
  __pyx_k__38 = fst::kNoStateId;

  /* "fst.pyx":1745
 * 
 * 
 * def rmepsilon(_Fst ifst, bool connect=True, float delta=kDelta,             # <<<<<<<<<<<<<<
 *               int64 nstate=kNoStateId, queue_type=b"auto", bool reverse=False,
 *               weight=b""):
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_45rmepsilon, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1745; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_rmepsilon, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1745; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1776
 * 
 * 
 * def shortestdistance(_Fst ifst, float delta=kDelta, int64 nstate=kNoStateId,             # <<<<<<<<<<<<<<
 *                      queue_type=b"auto", bool reverse=False):
 *   """Compute the shortest distance from the initial or final state.
 */
  __pyx_k__39 = fst::kDelta;
  __pyx_k__40 = fst::kNoStateId;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_47shortestdistance, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1776; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_shortestdistance, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1776; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1826
 * 
 * 
 * def shortestpath(_Fst ifst, float delta=kDelta, int64 nshortest=1,             # <<<<<<<<<<<<<<
 *                  int64 nstate=kNoStateId, queue_type=b"auto",
 *                  bool unique=False, weight=b""):
 */
  __pyx_k__41 = fst::kDelta;

  /* "fst.pyx":1827
 * 
 * def shortestpath(_Fst ifst, float delta=kDelta, int64 nshortest=1,
 *                  int64 nstate=kNoStateId, queue_type=b"auto",             # <<<<<<<<<<<<<<
 *                  bool unique=False, weight=b""):
 *   """Construct an FST containing the shortest path(s) in the input FST.
 */
  __pyx_k__42 = fst::kNoStateId;

  /* "fst.pyx":1826
 * 
 * 
 * def shortestpath(_Fst ifst, float delta=kDelta, int64 nshortest=1,             # <<<<<<<<<<<<<<
 *                  int64 nstate=kNoStateId, queue_type=b"auto",
 *                  bool unique=False, weight=b""):
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_49shortestpath, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_shortestpath, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1865
 * 
 * 
 * def synchronize(_Fst ifst):             # <<<<<<<<<<<<<<
 *   """Constructively synchronizes an FST.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3fst_51synchronize, NULL, __pyx_n_s_fst); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_synchronize, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1887
 * 
 * # Mask fst_error_fatal flags.
 * _fst_error_fatal_old = FLAGS_fst_error_fatal             # <<<<<<<<<<<<<<
 * FLAGS_fst_error_fatal = False
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(FLAGS_fst_error_fatal); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1887; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fst_error_fatal_old, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1887; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "fst.pyx":1888
 * # Mask fst_error_fatal flags.
 * _fst_error_fatal_old = FLAGS_fst_error_fatal
 * FLAGS_fst_error_fatal = False             # <<<<<<<<<<<<<<
 */
  FLAGS_fst_error_fatal = 0;

  /* "fst.pyx":1
 * """Python interface to //nlp/fst/script.             # <<<<<<<<<<<<<<
 * 
 * Operations which construct new FSTs are implemented as traditional functions,
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test_2, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "string.to_py":30
 * 
 * @cname("__pyx_convert_string_to_py_")
 * cdef object __pyx_convert_string_to_py_(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * 
 */

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init fst", __pyx_clineno, __pyx_lineno, __pyx_filename);
      Py_DECREF(__pyx_d); __pyx_d = 0;
    }
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init fst");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* Runtime support code */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->exc_type;
    *value = tstate->exc_value;
    *tb = tstate->exc_traceback;
    Py_XINCREF(*type);
    Py_XINCREF(*value);
    Py_XINCREF(*tb);
#else
    PyErr_GetExcInfo(type, value, tb);
#endif
}
static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(type, value, tb);
#endif
}

static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *local_type, *local_value, *local_tb;
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    local_type = tstate->curexc_type;
    local_value = tstate->curexc_value;
    local_tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(&local_type, &local_value, &local_tb);
#endif
    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
#if CYTHON_COMPILING_IN_CPYTHON
    if (unlikely(tstate->curexc_type))
#else
    if (unlikely(PyErr_Occurred()))
#endif
        goto bad;
    #if PY_MAJOR_VERSION >= 3
    if (local_tb) {
        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
            goto bad;
    }
    #endif
    Py_XINCREF(local_tb);
    Py_XINCREF(local_type);
    Py_XINCREF(local_value);
    *type = local_type;
    *value = local_value;
    *tb = local_tb;
#if CYTHON_COMPILING_IN_CPYTHON
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = local_type;
    tstate->exc_value = local_value;
    tstate->exc_traceback = local_tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(local_type, local_value, local_tb);
#endif
    return 0;
bad:
    *type = 0;
    *value = 0;
    *tb = 0;
    Py_XDECREF(local_type);
    Py_XDECREF(local_value);
    Py_XDECREF(local_tb);
    return -1;
}

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject* args = PyTuple_Pack(1, arg);
    return (likely(args)) ? __Pyx_PyObject_Call(func, args, NULL) : NULL;
}
#endif

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_Restore(type, value, tb);
#endif
}
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(type, value, tb);
#endif
}

#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                if (PyObject_IsSubclass(instance_class, type)) {
                    type = instance_class;
                } else {
                    instance_class = NULL;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
#if PY_VERSION_HEX >= 0x03030000
    if (cause) {
#else
    if (cause && cause != Py_None) {
#endif
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
    PyObject *result;
#if CYTHON_COMPILING_IN_CPYTHON
    result = PyDict_GetItem(__pyx_d, name);
    if (likely(result)) {
        Py_INCREF(result);
    } else {
#else
    result = PyObject_GetItem(__pyx_d, name);
    if (!result) {
        PyErr_Clear();
#endif
        result = __Pyx_GetBuiltinName(name);
    }
    return result;
}

static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
                                  int full_traceback) {
    PyObject *old_exc, *old_val, *old_tb;
    PyObject *ctx;
    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
    if (full_traceback) {
        Py_XINCREF(old_exc);
        Py_XINCREF(old_val);
        Py_XINCREF(old_tb);
        __Pyx_ErrRestore(old_exc, old_val, old_tb);
        PyErr_PrintEx(1);
    }
    #if PY_MAJOR_VERSION < 3
    ctx = PyString_FromString(name);
    #else
    ctx = PyUnicode_FromString(name);
    #endif
    __Pyx_ErrRestore(old_exc, old_val, old_tb);
    if (!ctx) {
        PyErr_WriteUnraisable(Py_None);
    } else {
        PyErr_WriteUnraisable(ctx);
        Py_DECREF(ctx);
    }
}

static void __Pyx_RaiseArgumentTypeInvalid(const char* name, PyObject *obj, PyTypeObject *type) {
    PyErr_Format(PyExc_TypeError,
        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
}
static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact)
{
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (none_allowed && obj == Py_None) return 1;
    else if (exact) {
        if (likely(Py_TYPE(obj) == type)) return 1;
        #if PY_MAJOR_VERSION == 2
        else if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
        #endif
    }
    else {
        if (likely(PyObject_TypeCheck(obj, type))) return 1;
    }
    __Pyx_RaiseArgumentTypeInvalid(name, obj, type);
    return 0;
}

static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
    if (s1 == s2) {
        return (equals == Py_EQ);
    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
        const char *ps1, *ps2;
        Py_ssize_t length = PyBytes_GET_SIZE(s1);
        if (length != PyBytes_GET_SIZE(s2))
            return (equals == Py_NE);
        ps1 = PyBytes_AS_STRING(s1);
        ps2 = PyBytes_AS_STRING(s2);
        if (ps1[0] != ps2[0]) {
            return (equals == Py_NE);
        } else if (length == 1) {
            return (equals == Py_EQ);
        } else {
            int result = memcmp(ps1, ps2, (size_t)length);
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
        return (equals == Py_NE);
    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
        return (equals == Py_NE);
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
#endif
}

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
    PyErr_Format(PyExc_ValueError,
                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
}

static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
                 index, (index == 1) ? "" : "s");
}

static CYTHON_INLINE int __Pyx_IterFinish(void) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    PyObject* exc_type = tstate->curexc_type;
    if (unlikely(exc_type)) {
        if (likely(exc_type == PyExc_StopIteration) || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)) {
            PyObject *exc_value, *exc_tb;
            exc_value = tstate->curexc_value;
            exc_tb = tstate->curexc_traceback;
            tstate->curexc_type = 0;
            tstate->curexc_value = 0;
            tstate->curexc_traceback = 0;
            Py_DECREF(exc_type);
            Py_XDECREF(exc_value);
            Py_XDECREF(exc_tb);
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#else
    if (unlikely(PyErr_Occurred())) {
        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
            PyErr_Clear();
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#endif
}

static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
    if (unlikely(retval)) {
        Py_DECREF(retval);
        __Pyx_RaiseTooManyValuesError(expected);
        return -1;
    } else {
        return __Pyx_IterFinish();
    }
    return 0;
}

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(PyObject_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = *type;
    tstate->exc_value = *value;
    tstate->exc_traceback = *tb;
#else
    PyErr_GetExcInfo(&tmp_type, &tmp_value, &tmp_tb);
    PyErr_SetExcInfo(*type, *value, *tb);
#endif
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}

static CYTHON_INLINE PyObject *__Pyx_PyIter_Next2(PyObject* iterator, PyObject* defval) {
    PyObject* next;
    iternextfunc iternext = Py_TYPE(iterator)->tp_iternext;
#if CYTHON_COMPILING_IN_CPYTHON
    if (unlikely(!iternext)) {
#else
    if (unlikely(!iternext) || unlikely(!PyIter_Check(iterator))) {
#endif
        PyErr_Format(PyExc_TypeError,
            "%.200s object is not an iterator", Py_TYPE(iterator)->tp_name);
        return NULL;
    }
    next = iternext(iterator);
    if (likely(next))
        return next;
#if CYTHON_COMPILING_IN_CPYTHON
#if PY_VERSION_HEX >= 0x02070000
    if (unlikely(iternext == &_PyObject_NextNotImplemented))
        return NULL;
#endif
#endif
    if (defval) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
            if (unlikely(exc_type != PyExc_StopIteration) &&
                    !PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))
                return NULL;
            PyErr_Clear();
        }
        Py_INCREF(defval);
        return defval;
    }
    if (!PyErr_Occurred())
        PyErr_SetNone(PyExc_StopIteration);
    return NULL;
}

static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases) {
    Py_ssize_t i, nbases = PyTuple_GET_SIZE(bases);
    for (i=0; i < nbases; i++) {
        PyTypeObject *tmptype;
        PyObject *tmp = PyTuple_GET_ITEM(bases, i);
        tmptype = Py_TYPE(tmp);
#if PY_MAJOR_VERSION < 3
        if (tmptype == &PyClass_Type)
            continue;
#endif
        if (!metaclass) {
            metaclass = tmptype;
            continue;
        }
        if (PyType_IsSubtype(metaclass, tmptype))
            continue;
        if (PyType_IsSubtype(tmptype, metaclass)) {
            metaclass = tmptype;
            continue;
        }
        PyErr_SetString(PyExc_TypeError,
                        "metaclass conflict: "
                        "the metaclass of a derived class "
                        "must be a (non-strict) subclass "
                        "of the metaclasses of all its bases");
        return NULL;
    }
    if (!metaclass) {
#if PY_MAJOR_VERSION < 3
        metaclass = &PyClass_Type;
#else
        metaclass = &PyType_Type;
#endif
    }
    Py_INCREF((PyObject*) metaclass);
    return (PyObject*) metaclass;
}

static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name,
                                           PyObject *qualname, PyObject *mkw, PyObject *modname, PyObject *doc) {
    PyObject *ns;
    if (metaclass) {
        PyObject *prep = __Pyx_PyObject_GetAttrStr(metaclass, __pyx_n_s_prepare);
        if (prep) {
            PyObject *pargs = PyTuple_Pack(2, name, bases);
            if (unlikely(!pargs)) {
                Py_DECREF(prep);
                return NULL;
            }
            ns = PyObject_Call(prep, pargs, mkw);
            Py_DECREF(prep);
            Py_DECREF(pargs);
        } else {
            if (unlikely(!PyErr_ExceptionMatches(PyExc_AttributeError)))
                return NULL;
            PyErr_Clear();
            ns = PyDict_New();
        }
    } else {
        ns = PyDict_New();
    }
    if (unlikely(!ns))
        return NULL;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_module, modname) < 0)) goto bad;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_qualname, qualname) < 0)) goto bad;
    if (unlikely(doc && PyObject_SetItem(ns, __pyx_n_s_doc, doc) < 0)) goto bad;
    return ns;
bad:
    Py_DECREF(ns);
    return NULL;
}
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases,
                                      PyObject *dict, PyObject *mkw,
                                      int calculate_metaclass, int allow_py2_metaclass) {
    PyObject *result, *margs;
    PyObject *owned_metaclass = NULL;
    if (allow_py2_metaclass) {
        owned_metaclass = PyObject_GetItem(dict, __pyx_n_s_metaclass);
        if (owned_metaclass) {
            metaclass = owned_metaclass;
        } else if (likely(PyErr_ExceptionMatches(PyExc_KeyError))) {
            PyErr_Clear();
        } else {
            return NULL;
        }
    }
    if (calculate_metaclass && (!metaclass || PyType_Check(metaclass))) {
        metaclass = __Pyx_CalculateMetaclass((PyTypeObject*) metaclass, bases);
        Py_XDECREF(owned_metaclass);
        if (unlikely(!metaclass))
            return NULL;
        owned_metaclass = metaclass;
    }
    margs = PyTuple_Pack(3, name, bases, dict);
    if (unlikely(!margs)) {
        result = NULL;
    } else {
        result = PyObject_Call(metaclass, margs, mkw);
        Py_DECREF(margs);
    }
    Py_XDECREF(owned_metaclass);
    return result;
}

static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name) {
    PyObject *result;
    result = __Pyx_PyObject_GetAttrStr(nmspace, name);
    if (!result)
        result = __Pyx_GetModuleGlobalName(name);
    return result;
}

static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = (start + end) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, (size_t)new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        __pyx_d,      /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = py_line;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint64_t(uint64_t value) {
    const uint64_t neg_one = (uint64_t) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(uint64_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint64_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(uint64_t) <= sizeof(unsigned long long)) {
            return PyLong_FromUnsignedLongLong((unsigned long long) value);
        }
    } else {
        if (sizeof(uint64_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint64_t) <= sizeof(long long)) {
            return PyLong_FromLongLong((long long) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(uint64_t),
                                     little, !is_unsigned);
    }
}

#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)       \
    {                                                                     \
        func_type value = func_value;                                     \
        if (sizeof(target_type) < sizeof(func_type)) {                    \
            if (unlikely(value != (func_type) (target_type) value)) {     \
                func_type zero = 0;                                       \
                if (is_unsigned && unlikely(value < zero))                \
                    goto raise_neg_overflow;                              \
                else                                                      \
                    goto raise_overflow;                                  \
            }                                                             \
        }                                                                 \
        return (target_type) value;                                       \
    }

#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
 #endif
#endif

static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT(int, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(int) <= sizeof(unsigned long long)) {
                __PYX_VERIFY_RETURN_INT(int, unsigned long long, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +(((PyLongObject*)x)->ob_digit[0]));
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, -(sdigit) ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT(int, long, PyLong_AsLong(x))
            } else if (sizeof(int) <= sizeof(long long)) {
                __PYX_VERIFY_RETURN_INT(int, long long, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

static CYTHON_INLINE uint64_t __Pyx_PyInt_As_uint64_t(PyObject *x) {
    const uint64_t neg_one = (uint64_t) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(uint64_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(uint64_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (uint64_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(uint64_t, digit, ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
            if (sizeof(uint64_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(uint64_t) <= sizeof(unsigned long long)) {
                __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long long, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(uint64_t,  digit, +(((PyLongObject*)x)->ob_digit[0]));
                case -1: __PYX_VERIFY_RETURN_INT(uint64_t, sdigit, -(sdigit) ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (sizeof(uint64_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT(uint64_t, long, PyLong_AsLong(x))
            } else if (sizeof(uint64_t) <= sizeof(long long)) {
                __PYX_VERIFY_RETURN_INT(uint64_t, long long, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            uint64_t val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (uint64_t) -1;
        }
    } else {
        uint64_t val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (uint64_t) -1;
        val = __Pyx_PyInt_As_uint64_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to uint64_t");
    return (uint64_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to uint64_t");
    return (uint64_t) -1;
}

static CYTHON_INLINE int64_t __Pyx_PyInt_As_int64_t(PyObject *x) {
    const int64_t neg_one = (int64_t) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int64_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int64_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int64_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(int64_t, digit, ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
            if (sizeof(int64_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(int64_t) <= sizeof(unsigned long long)) {
                __PYX_VERIFY_RETURN_INT(int64_t, unsigned long long, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(int64_t,  digit, +(((PyLongObject*)x)->ob_digit[0]));
                case -1: __PYX_VERIFY_RETURN_INT(int64_t, sdigit, -(sdigit) ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (sizeof(int64_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT(int64_t, long, PyLong_AsLong(x))
            } else if (sizeof(int64_t) <= sizeof(long long)) {
                __PYX_VERIFY_RETURN_INT(int64_t, long long, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int64_t val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int64_t) -1;
        }
    } else {
        int64_t val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (int64_t) -1;
        val = __Pyx_PyInt_As_int64_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int64_t");
    return (int64_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int64_t");
    return (int64_t) -1;
}

static CYTHON_INLINE int32_t __Pyx_PyInt_As_int32_t(PyObject *x) {
    const int32_t neg_one = (int32_t) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int32_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int32_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int32_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(int32_t, digit, ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
            if (sizeof(int32_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(int32_t) <= sizeof(unsigned long long)) {
                __PYX_VERIFY_RETURN_INT(int32_t, unsigned long long, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(int32_t,  digit, +(((PyLongObject*)x)->ob_digit[0]));
                case -1: __PYX_VERIFY_RETURN_INT(int32_t, sdigit, -(sdigit) ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (sizeof(int32_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT(int32_t, long, PyLong_AsLong(x))
            } else if (sizeof(int32_t) <= sizeof(long long)) {
                __PYX_VERIFY_RETURN_INT(int32_t, long long, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int32_t val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int32_t) -1;
        }
    } else {
        int32_t val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (int32_t) -1;
        val = __Pyx_PyInt_As_int32_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int32_t");
    return (int32_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int32_t");
    return (int32_t) -1;
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
    const int neg_one = (int) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(int) <= sizeof(unsigned long long)) {
            return PyLong_FromUnsignedLongLong((unsigned long long) value);
        }
    } else {
        if (sizeof(int) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(long long)) {
            return PyLong_FromLongLong((long long) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int),
                                     little, !is_unsigned);
    }
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(long) <= sizeof(unsigned long long)) {
            return PyLong_FromUnsignedLongLong((unsigned long long) value);
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(long long)) {
            return PyLong_FromLongLong((long long) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT(long, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(long) <= sizeof(unsigned long long)) {
                __PYX_VERIFY_RETURN_INT(long, unsigned long long, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +(((PyLongObject*)x)->ob_digit[0]));
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, -(sdigit) ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT(long, long, PyLong_AsLong(x))
            } else if (sizeof(long) <= sizeof(long long)) {
                __PYX_VERIFY_RETURN_INT(long, long long, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

static int __Pyx_ExportFunction(const char *name, void (*f)(void), const char *sig) {
    PyObject *d = 0;
    PyObject *cobj = 0;
    union {
        void (*fp)(void);
        void *p;
    } tmp;
    d = PyObject_GetAttrString(__pyx_m, (char *)"__pyx_capi__");
    if (!d) {
        PyErr_Clear();
        d = PyDict_New();
        if (!d)
            goto bad;
        Py_INCREF(d);
        if (PyModule_AddObject(__pyx_m, (char *)"__pyx_capi__", d) < 0)
            goto bad;
    }
    tmp.fp = f;
#if PY_VERSION_HEX >= 0x02070000
    cobj = PyCapsule_New(tmp.p, sig, 0);
#else
    cobj = PyCObject_FromVoidPtrAndDesc(tmp.p, (void *)sig, 0);
#endif
    if (!cobj)
        goto bad;
    if (PyDict_SetItemString(d, name, cobj) < 0)
        goto bad;
    Py_DECREF(cobj);
    Py_DECREF(d);
    return 0;
bad:
    Py_XDECREF(cobj);
    Py_XDECREF(d);
    return -1;
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
#if PY_VERSION_HEX < 0x03030000
        char* defenc_c;
        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
        if (!defenc) return NULL;
        defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        {
            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
            char* c;
            for (c = defenc_c; c < end; c++) {
                if ((unsigned char) (*c) >= 128) {
                    PyUnicode_AsASCIIString(o);
                    return NULL;
                }
            }
        }
#endif
        *length = PyBytes_GET_SIZE(defenc);
        return defenc_c;
#else
        if (__Pyx_PyUnicode_READY(o) == -1) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        if (PyUnicode_IS_ASCII(o)) {
            *length = PyUnicode_GET_LENGTH(o);
            return PyUnicode_AsUTF8(o);
        } else {
            PyUnicode_AsASCIIString(o);
            return NULL;
        }
#else
        return PyUnicode_AsUTF8AndSize(o, length);
#endif
#endif
    } else
#endif
#if !CYTHON_COMPILING_IN_PYPY
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return Py_INCREF(x), x;
  m = Py_TYPE(x)->tp_as_number;
#if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_MAJOR_VERSION < 3
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%.4s__ returned non-%.4s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b)))
      return PyInt_AS_LONG(b);
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
     #if CYTHON_USE_PYLONG_INTERNALS
       switch (Py_SIZE(b)) {
       case -1: return -(sdigit)((PyLongObject*)b)->ob_digit[0];
       case  0: return 0;
       case  1: return ((PyLongObject*)b)->ob_digit[0];
       }
     #endif
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
